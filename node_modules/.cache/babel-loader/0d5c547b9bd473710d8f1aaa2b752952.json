{"ast":null,"code":"\"use strict\";\n/**\n * Copyright 2013 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nvar __extends = this && this.__extends || function () {\n  var extendStatics = Object.setPrototypeOf || {\n    __proto__: []\n  } instanceof Array && function (d, b) {\n    d.__proto__ = b;\n  } || function (d, b) {\n    for (var p in b) {\n      if (b.hasOwnProperty(p)) d[p] = b[p];\n    }\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : new P(function (resolve) {\n        resolve(result.value);\n      }).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nvar __generator = this && this.__generator || function (thisArg, body) {\n  var _ = {\n    label: 0,\n    sent: function sent() {\n      if (t[0] & 1) throw t[1];\n      return t[1];\n    },\n    trys: [],\n    ops: []\n  },\n      f,\n      y,\n      t,\n      g;\n  return g = {\n    next: verb(0),\n    \"throw\": verb(1),\n    \"return\": verb(2)\n  }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function () {\n    return this;\n  }), g;\n\n  function verb(n) {\n    return function (v) {\n      return step([n, v]);\n    };\n  }\n\n  function step(op) {\n    if (f) throw new TypeError(\"Generator is already executing.\");\n\n    while (_) {\n      try {\n        if (f = 1, y && (t = y[op[0] & 2 ? \"return\" : op[0] ? \"throw\" : \"next\"]) && !(t = t.call(y, op[1])).done) return t;\n        if (y = 0, t) op = [0, t.value];\n\n        switch (op[0]) {\n          case 0:\n          case 1:\n            t = op;\n            break;\n\n          case 4:\n            _.label++;\n            return {\n              value: op[1],\n              done: false\n            };\n\n          case 5:\n            _.label++;\n            y = op[1];\n            op = [0];\n            continue;\n\n          case 7:\n            op = _.ops.pop();\n\n            _.trys.pop();\n\n            continue;\n\n          default:\n            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n              _ = 0;\n              continue;\n            }\n\n            if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n              _.label = op[1];\n              break;\n            }\n\n            if (op[0] === 6 && _.label < t[1]) {\n              _.label = t[1];\n              t = op;\n              break;\n            }\n\n            if (t && _.label < t[2]) {\n              _.label = t[2];\n\n              _.ops.push(op);\n\n              break;\n            }\n\n            if (t[2]) _.ops.pop();\n\n            _.trys.pop();\n\n            continue;\n        }\n\n        op = body.call(thisArg, _);\n      } catch (e) {\n        op = [6, e];\n        y = 0;\n      } finally {\n        f = t = 0;\n      }\n    }\n\n    if (op[0] & 5) throw op[1];\n    return {\n      value: op[0] ? op[1] : void 0,\n      done: true\n    };\n  }\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) {\n    if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\n  }\n  result[\"default\"] = mod;\n  return result;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar axios_1 = __importDefault(require(\"axios\"));\n\nvar gcpMetadata = __importStar(require(\"gcp-metadata\"));\n\nvar rax = __importStar(require(\"retry-axios\"));\n\nvar oauth2client_1 = require(\"./oauth2client\"); // Create a scoped axios instance that will retry 3 times by default\n\n\nvar ax = axios_1.default.create();\nrax.attach(ax);\n\nvar Compute =\n/** @class */\nfunction (_super) {\n  __extends(Compute, _super);\n  /**\n   * Google Compute Engine service account credentials.\n   *\n   * Retrieve access token from the metadata server.\n   * See: https://developers.google.com/compute/docs/authentication\n   */\n\n\n  function Compute(options) {\n    if (options === void 0) {\n      options = {};\n    }\n\n    var _this = _super.call(this, options) || this; // Start with an expired refresh token, which will automatically be\n    // refreshed before the first API call is made.\n\n\n    _this.credentials = {\n      expiry_date: 1,\n      refresh_token: 'compute-placeholder'\n    };\n    _this.serviceAccountEmail = options.serviceAccountEmail || 'default';\n    return _this;\n  }\n  /**\n   * Indicates whether the credential requires scopes to be created by calling\n   * createdScoped before use.\n   * @return Boolean indicating if scope is required.\n   */\n\n\n  Compute.prototype.createScopedRequired = function () {\n    // On compute engine, scopes are specified at the compute instance's\n    // creation time, and cannot be changed. For this reason, always return\n    // false.\n    return false;\n  };\n  /**\n   * Refreshes the access token.\n   * @param refreshToken Unused parameter\n   */\n\n\n  Compute.prototype.refreshTokenNoCache = function (refreshToken) {\n    return __awaiter(this, void 0, void 0, function () {\n      var _a, url, res, e_1, tokens;\n\n      return __generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            url = this.tokenUrl || \"\" + gcpMetadata.HOST_ADDRESS + gcpMetadata.BASE_PATH + \"/instance/service-accounts/\" + this.serviceAccountEmail + \"/token\";\n            _b.label = 1;\n\n          case 1:\n            _b.trys.push([1, 3,, 4]);\n\n            return [4\n            /*yield*/\n            , ax.request({\n              url: url,\n              headers: (_a = {}, _a[gcpMetadata.HEADER_NAME] = 'Google', _a),\n              raxConfig: {\n                noResponseRetries: 3,\n                retry: 3,\n                instance: ax\n              }\n            })];\n\n          case 2:\n            // TODO: In 2.0, we should remove the ability to configure the tokenUrl,\n            // and switch this over to use the gcp-metadata package instead.\n            res = _b.sent();\n            return [3\n            /*break*/\n            , 4];\n\n          case 3:\n            e_1 = _b.sent();\n            e_1.message = 'Could not refresh access token.';\n            throw e_1;\n\n          case 4:\n            tokens = res.data;\n\n            if (res.data && res.data.expires_in) {\n              tokens.expiry_date = new Date().getTime() + res.data.expires_in * 1000;\n              delete tokens.expires_in;\n            }\n\n            this.emit('tokens', tokens);\n            return [2\n            /*return*/\n            , {\n              tokens: tokens,\n              res: res\n            }];\n        }\n      });\n    });\n  };\n\n  Compute.prototype.requestAsync = function (opts, retry) {\n    if (retry === void 0) {\n      retry = false;\n    }\n\n    return _super.prototype.requestAsync.call(this, opts, retry).catch(function (e) {\n      var res = e.response;\n\n      if (res && res.status) {\n        var helpfulMessage = null;\n\n        if (res.status === 403) {\n          helpfulMessage = 'A Forbidden error was returned while attempting to retrieve an access ' + 'token for the Compute Engine built-in service account. This may be because the Compute ' + 'Engine instance does not have the correct permission scopes specified.';\n        } else if (res.status === 404) {\n          helpfulMessage = 'A Not Found error was returned while attempting to retrieve an access' + 'token for the Compute Engine built-in service account. This may be because the Compute ' + 'Engine instance does not have any permission scopes specified.';\n        }\n\n        if (helpfulMessage) {\n          if (e && e.message && !retry) {\n            helpfulMessage += ' ' + e.message;\n          }\n\n          if (e) {\n            e.message = helpfulMessage;\n          } else {\n            e = new Error(helpfulMessage);\n            e.code = res.status.toString();\n          }\n        }\n      }\n\n      throw e;\n    });\n  };\n\n  return Compute;\n}(oauth2client_1.OAuth2Client);\n\nexports.Compute = Compute;","map":null,"metadata":{},"sourceType":"script"}