{"ast":null,"code":"/*!\n * Copyright 2016 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/*!\n * @module common/operation\n */\n'use strict';\n\nvar events = require('events');\n\nvar extend = require('extend');\n\nvar modelo = require('modelo');\n/**\n * @type {module:common/serviceObject}\n * @private\n */\n\n\nvar ServiceObject = require('./service-object.js'); // jscs:disable maximumLineLength\n\n/**\n * An Operation object allows you to interact with APIs that take longer to\n * process things.\n *\n * @constructor\n * @alias module:common/operation\n *\n * @param {object} config - Configuration object.\n * @param {module:common/service|module:common/serviceObject|module:common/grpcService|module:common/grpcServiceObject} config.parent - The\n *     parent object.\n * @param {string} id - The operation ID.\n */\n// jscs:enable maximumLineLength\n\n\nfunction Operation(config) {\n  var methods = {\n    /**\n     * Checks to see if an operation exists.\n     */\n    exists: true,\n\n    /**\n     * Retrieves the operation.\n     */\n    get: true,\n\n    /**\n     * Retrieves metadata for the operation.\n     */\n    getMetadata: {\n      reqOpts: {\n        name: config.id\n      }\n    }\n  };\n  config = extend({\n    baseUrl: ''\n  }, config);\n  config.methods = config.methods || methods;\n  ServiceObject.call(this, config);\n  events.EventEmitter.call(this);\n  this.completeListeners = 0;\n  this.hasActiveListeners = false;\n  this.listenForEvents_();\n}\n\nmodelo.inherits(Operation, ServiceObject, events.EventEmitter);\n/**\n * Wraps the `complete` and `error` events in a Promise.\n *\n * @return {promise}\n */\n\nOperation.prototype.promise = function () {\n  var self = this;\n  return new self.Promise(function (resolve, reject) {\n    self.on('error', reject).on('complete', function (metadata) {\n      resolve([metadata]);\n    });\n  });\n};\n/**\n * Begin listening for events on the operation. This method keeps track of how\n * many \"complete\" listeners are registered and removed, making sure polling is\n * handled automatically.\n *\n * As long as there is one active \"complete\" listener, the connection is open.\n * When there are no more listeners, the polling stops.\n *\n * @private\n */\n\n\nOperation.prototype.listenForEvents_ = function () {\n  var self = this;\n  this.on('newListener', function (event) {\n    if (event === 'complete') {\n      self.completeListeners++;\n\n      if (!self.hasActiveListeners) {\n        self.hasActiveListeners = true;\n        self.startPolling_();\n      }\n    }\n  });\n  this.on('removeListener', function (event) {\n    if (event === 'complete' && --self.completeListeners === 0) {\n      self.hasActiveListeners = false;\n    }\n  });\n};\n/**\n * Poll for a status update. Execute the callback:\n *\n *   - callback(err): Operation failed\n *   - callback(): Operation incomplete\n *   - callback(null, metadata): Operation complete\n *\n * @private\n *\n * @param {function} callback\n */\n\n\nOperation.prototype.poll_ = function (callback) {\n  this.getMetadata(function (err, resp) {\n    if (err || resp.error) {\n      callback(err || resp.error);\n      return;\n    }\n\n    if (!resp.done) {\n      callback();\n      return;\n    }\n\n    callback(null, resp);\n  });\n};\n/**\n * Poll `getMetadata` to check the operation's status. This runs a loop to ping\n * the API on an interval.\n *\n * Note: This method is automatically called once a \"complete\" event handler is\n * registered on the operation.\n *\n * @private\n */\n\n\nOperation.prototype.startPolling_ = function () {\n  var self = this;\n\n  if (!this.hasActiveListeners) {\n    return;\n  }\n\n  this.poll_(function (err, metadata) {\n    if (err) {\n      self.emit('error', err);\n      return;\n    }\n\n    if (!metadata) {\n      setTimeout(self.startPolling_.bind(self), 500);\n      return;\n    }\n\n    self.emit('complete', metadata);\n  });\n};\n\nmodule.exports = Operation;","map":null,"metadata":{},"sourceType":"script"}