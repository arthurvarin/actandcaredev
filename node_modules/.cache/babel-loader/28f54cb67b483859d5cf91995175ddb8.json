{"ast":null,"code":"'use strict';\n\nexports.__esModule = true;\n\nvar _keys = require('babel-runtime/core-js/object/keys');\n\nvar _keys2 = _interopRequireDefault(_keys);\n\nvar _freeze = require('babel-runtime/core-js/object/freeze');\n\nvar _freeze2 = _interopRequireDefault(_freeze);\n\nvar _getIterator2 = require('babel-runtime/core-js/get-iterator');\n\nvar _getIterator3 = _interopRequireDefault(_getIterator2);\n\nvar _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');\n\nvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\nvar _createClass2 = require('babel-runtime/helpers/createClass');\n\nvar _createClass3 = _interopRequireDefault(_createClass2);\n\nvar _cubic2quad = require('cubic2quad');\n\nvar _cubic2quad2 = _interopRequireDefault(_cubic2quad);\n\nvar _BBox = require('./BBox');\n\nvar _BBox2 = _interopRequireDefault(_BBox);\n\nvar _Polygon = require('./Polygon');\n\nvar _Polygon2 = _interopRequireDefault(_Polygon);\n\nvar _Point = require('./Point');\n\nvar _Point2 = _interopRequireDefault(_Point);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nvar SVG_COMMANDS = {\n  moveTo: 'M',\n  lineTo: 'L',\n  quadraticCurveTo: 'Q',\n  bezierCurveTo: 'C',\n  closePath: 'Z'\n}; // This constant is used to approximate a symmetrical arc using a cubic Bezier curve.\n\nvar KAPPA = 4.0 * ((Math.sqrt(2) - 1.0) / 3.0);\n/**\n * Path objects are returned by glyphs and represent the actual\n * vector outlines for each glyph in the font. Paths can be converted\n * to SVG path data strings, or to functions that can be applied to\n * render the path to a graphics context.\n */\n\nvar Path = function () {\n  function Path() {\n    (0, _classCallCheck3.default)(this, Path);\n    this.commands = [];\n    this._bbox = null;\n    this._cbox = null;\n    this._bezier = false;\n    this._quadratic = false;\n  }\n\n  Path.prototype.rect = function rect(x, y, width, height) {\n    this.moveTo(x, y);\n    this.lineTo(x + width, y);\n    this.lineTo(x + width, y + height);\n    this.lineTo(x, y + height);\n    this.closePath();\n    return this;\n  };\n\n  Path.prototype.ellipse = function ellipse(x, y, r1) {\n    var r2 = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : r1; // based on http://stackoverflow.com/questions/2172798/how-to-draw-an-oval-in-html5-canvas/2173084#2173084\n\n    x -= r1;\n    y -= r2;\n    var ox = r1 * KAPPA;\n    var oy = r2 * KAPPA;\n    var xe = x + r1 * 2;\n    var ye = y + r2 * 2;\n    var xm = x + r1;\n    var ym = y + r2;\n    this.moveTo(x, ym);\n    this.bezierCurveTo(x, ym - oy, xm - ox, y, xm, y);\n    this.bezierCurveTo(xm + ox, y, xe, ym - oy, xe, ym);\n    this.bezierCurveTo(xe, ym + oy, xm + ox, ye, xm, ye);\n    this.bezierCurveTo(xm - ox, ye, x, ym + oy, x, ym);\n    this.closePath();\n    return this;\n  };\n\n  Path.prototype.circle = function circle(x, y, radius) {\n    this.ellipse(x, y, radius);\n  };\n\n  Path.prototype.append = function append(path) {\n    for (var _iterator = path.commands, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : (0, _getIterator3.default)(_iterator);;) {\n      var _ref2;\n\n      if (_isArray) {\n        if (_i >= _iterator.length) break;\n        _ref2 = _iterator[_i++];\n      } else {\n        _i = _iterator.next();\n        if (_i.done) break;\n        _ref2 = _i.value;\n      }\n\n      var _ref = _ref2;\n      var command = _ref.command,\n          args = _ref.args;\n      this[command].apply(this, args);\n    }\n\n    return this;\n  };\n  /**\n   * Compiles the path to a JavaScript function that can be applied with\n   * a graphics context in order to render the path.\n   * @return {string}\n   */\n\n\n  Path.prototype.toFunction = function toFunction() {\n    var cmds = this.commands.map(function (c) {\n      return '  ctx.' + c.command + '(' + c.args.join(', ') + ');';\n    });\n    return new Function('ctx', cmds.join('\\n'));\n  };\n  /**\n   * Converts the path to an SVG path data string\n   * @return {string}\n   */\n\n\n  Path.prototype.toSVG = function toSVG() {\n    var cmds = this.commands.map(function (c) {\n      var args = c.args.map(function (arg) {\n        return Math.round(arg * 100) / 100;\n      });\n      return '' + SVG_COMMANDS[c.command] + args.join(' ');\n    });\n    return cmds.join('');\n  };\n  /**\n   * Gets the 'control box' of a path.\n   * This is like the bounding box, but it includes all points including\n   * control points of bezier segments and is much faster to compute than\n   * the real bounding box.\n   * @type {BBox}\n   */\n\n\n  Path.prototype.mapPoints = function mapPoints(fn) {\n    var path = new Path();\n\n    for (var _iterator2 = this.commands, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : (0, _getIterator3.default)(_iterator2);;) {\n      var _ref3;\n\n      if (_isArray2) {\n        if (_i2 >= _iterator2.length) break;\n        _ref3 = _iterator2[_i2++];\n      } else {\n        _i2 = _iterator2.next();\n        if (_i2.done) break;\n        _ref3 = _i2.value;\n      }\n\n      var c = _ref3;\n      var args = [];\n\n      for (var _i3 = 0; _i3 < c.args.length; _i3 += 2) {\n        var _fn = fn(c.args[_i3], c.args[_i3 + 1]),\n            x = _fn[0],\n            y = _fn[1];\n\n        args.push(x, y);\n      }\n\n      path[c.command].apply(path, args);\n    }\n\n    return path;\n  };\n\n  Path.prototype.transform = function transform(m0, m1, m2, m3, m4, m5) {\n    return this.mapPoints(function (x, y) {\n      x = m0 * x + m2 * y + m4;\n      y = m1 * x + m3 * y + m5;\n      return [x, y];\n    });\n  };\n\n  Path.prototype.translate = function translate(x, y) {\n    return this.transform(1, 0, 0, 1, x, y);\n  };\n\n  Path.prototype.rotate = function rotate(angle) {\n    var cos = Math.cos(angle);\n    var sin = Math.sin(angle);\n    return this.transform(cos, sin, -sin, cos, 0, 0);\n  };\n\n  Path.prototype.scale = function scale(scaleX) {\n    var scaleY = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : scaleX;\n    return this.transform(scaleX, 0, 0, scaleY, 0, 0);\n  };\n\n  Path.prototype.quadraticToBezier = function quadraticToBezier() {\n    if (!this._quadratic) {\n      return this;\n    }\n\n    var path = new Path();\n    var x = 0;\n    var y = 0;\n\n    for (var _iterator3 = this.commands, _isArray3 = Array.isArray(_iterator3), _i4 = 0, _iterator3 = _isArray3 ? _iterator3 : (0, _getIterator3.default)(_iterator3);;) {\n      var _ref4;\n\n      if (_isArray3) {\n        if (_i4 >= _iterator3.length) break;\n        _ref4 = _iterator3[_i4++];\n      } else {\n        _i4 = _iterator3.next();\n        if (_i4.done) break;\n        _ref4 = _i4.value;\n      }\n\n      var c = _ref4;\n\n      if (c.command === 'quadraticCurveTo') {\n        var quads = _quadraticToBezier.apply(undefined, [x, y].concat(c.args));\n\n        for (var _i5 = 2; _i5 < quads.length; _i5 += 6) {\n          path.bezierCurveTo(quads[_i5], quads[_i5 + 1], quads[_i5 + 2], quads[_i5 + 3], quads[_i5 + 4], quads[_i5 + 5]);\n        }\n      } else {\n        path[c.command].apply(path, c.args);\n        x = c.args[c.args.length - 2] || 0;\n        y = c.args[c.args.length - 1] || 0;\n      }\n    }\n\n    return path;\n  };\n\n  Path.prototype.bezierToQuadratic = function bezierToQuadratic() {\n    if (!this._bezier) {\n      return this;\n    }\n\n    var path = new Path();\n    var x = 0;\n    var y = 0;\n\n    for (var _iterator4 = this.commands, _isArray4 = Array.isArray(_iterator4), _i6 = 0, _iterator4 = _isArray4 ? _iterator4 : (0, _getIterator3.default)(_iterator4);;) {\n      var _ref5;\n\n      if (_isArray4) {\n        if (_i6 >= _iterator4.length) break;\n        _ref5 = _iterator4[_i6++];\n      } else {\n        _i6 = _iterator4.next();\n        if (_i6.done) break;\n        _ref5 = _i6.value;\n      }\n\n      var c = _ref5;\n\n      if (c.command === 'bezierCurveTo') {\n        var quads = _cubic2quad2.default.apply(undefined, [x, y].concat(c.args, [0.1]));\n\n        for (var _i7 = 2; _i7 < quads.length; _i7 += 4) {\n          path.quadraticCurveTo(quads[_i7], quads[_i7 + 1], quads[_i7 + 2], quads[_i7 + 3]);\n        }\n      } else {\n        path[c.command].apply(path, c.args);\n        x = c.args[c.args.length - 2] || 0;\n        y = c.args[c.args.length - 1] || 0;\n      }\n    }\n\n    return path;\n  };\n\n  Path.prototype.flatten = function flatten() {\n    if (this.isFlat) {\n      return this;\n    }\n\n    var res = new Path();\n    var cx = 0;\n    var cy = 0;\n    var sx = 0;\n    var sy = 0;\n\n    for (var _iterator5 = this.commands, _isArray5 = Array.isArray(_iterator5), _i8 = 0, _iterator5 = _isArray5 ? _iterator5 : (0, _getIterator3.default)(_iterator5);;) {\n      var _ref7;\n\n      if (_isArray5) {\n        if (_i8 >= _iterator5.length) break;\n        _ref7 = _iterator5[_i8++];\n      } else {\n        _i8 = _iterator5.next();\n        if (_i8.done) break;\n        _ref7 = _i8.value;\n      }\n\n      var _ref6 = _ref7;\n      var command = _ref6.command,\n          args = _ref6.args;\n\n      switch (command) {\n        case 'moveTo':\n          res.moveTo.apply(res, args);\n          cx = sx = args[0];\n          cy = sy = args[1];\n          break;\n\n        case 'lineTo':\n          res.lineTo.apply(res, args);\n          cx = args[0];\n          cy = args[1];\n          break;\n\n        case 'quadraticCurveTo':\n          args = _quadraticToBezier.apply(undefined, [cx, cy].concat(args));\n        // fall through!\n\n        case 'bezierCurveTo':\n          subdivideBezierWithFlatness.apply(undefined, [res, 0.6, cx, cy].concat(args));\n          cx = args[4];\n          cy = args[5];\n          break;\n\n        case 'closePath':\n          cx = sx;\n          cy = sy;\n          res.closePath();\n          break;\n\n        default:\n          throw new Error('Unknown path command: ' + command);\n      }\n    }\n\n    return res;\n  };\n\n  Path.prototype.reverse = function reverse() {\n    var res = new Path();\n    var commands = this.commands;\n    var start = commands[0];\n\n    for (var _i9 = 1; _i9 < commands.length; _i9++) {\n      var _commands$_i = commands[_i9],\n          command = _commands$_i.command,\n          args = _commands$_i.args;\n\n      if (command !== 'moveTo' && _i9 + 1 < commands.length) {\n        continue;\n      }\n\n      var closed = false;\n      var j = _i9;\n\n      if (command === 'moveTo') {\n        j--;\n      }\n\n      var move = commands[j].command === 'closePath' ? start : commands[j];\n      res.moveTo(move.args[0], move.args[1]);\n\n      for (; commands[j].command !== 'moveTo'; j--) {\n        var prev = commands[j - 1];\n        var cur = commands[j];\n        var px = prev.args[prev.args.length - 2];\n        var py = prev.args[prev.args.length - 1];\n\n        switch (cur.command) {\n          case 'lineTo':\n            if (closed && prev.command === 'moveTo') {\n              res.closePath();\n            } else {\n              res.lineTo(px, py);\n            }\n\n            break;\n\n          case 'bezierCurveTo':\n            res.bezierCurveTo(cur.args[2], cur.args[3], cur.args[0], cur.args[1], px, py);\n\n            if (closed && prev.command === 'moveTo') {\n              prev.closePath();\n            }\n\n            break;\n\n          case 'quadraticCurveTo':\n            res.quadraticCurveTo(cur.args[0], cur.args[1], px, py);\n\n            if (closed && prev.command === 'moveTo') {\n              prev.closePath();\n            }\n\n            break;\n\n          case 'closePath':\n            closed = true;\n            res.lineTo(px, py);\n            break;\n\n          default:\n            throw new Error('Unknown path command: ' + command);\n        }\n      }\n\n      start = commands[_i9];\n    }\n\n    return res;\n  };\n\n  Path.prototype.toPolygon = function toPolygon() {\n    // Flatten and canonicalize the path.\n    var path = this.flatten();\n\n    if (!path.isClockwise) {\n      path = path.reverse();\n    }\n\n    var contour = [];\n    var polygon = new _Polygon2.default();\n\n    for (var _iterator6 = path.commands, _isArray6 = Array.isArray(_iterator6), _i10 = 0, _iterator6 = _isArray6 ? _iterator6 : (0, _getIterator3.default)(_iterator6);;) {\n      var _ref9;\n\n      if (_isArray6) {\n        if (_i10 >= _iterator6.length) break;\n        _ref9 = _iterator6[_i10++];\n      } else {\n        _i10 = _iterator6.next();\n        if (_i10.done) break;\n        _ref9 = _i10.value;\n      }\n\n      var _ref8 = _ref9;\n      var command = _ref8.command,\n          args = _ref8.args;\n\n      switch (command) {\n        case 'moveTo':\n          if (contour.length) {\n            polygon.addContour(contour);\n            contour = [];\n          }\n\n          contour.push(new _Point2.default(args[0], args[1]));\n          break;\n\n        case 'lineTo':\n          contour.push(new _Point2.default(args[0], args[1]));\n          break;\n\n        case 'closePath':\n          if (contour.length) {\n            polygon.addContour(contour);\n            contour = [];\n          }\n\n          break;\n\n        default:\n          throw new Error('Unsupported path command: ' + command);\n      }\n    }\n\n    return polygon;\n  };\n\n  (0, _createClass3.default)(Path, [{\n    key: 'cbox',\n    get: function get() {\n      if (!this._cbox) {\n        var cbox = new _BBox2.default();\n\n        for (var _iterator7 = this.commands, _isArray7 = Array.isArray(_iterator7), _i11 = 0, _iterator7 = _isArray7 ? _iterator7 : (0, _getIterator3.default)(_iterator7);;) {\n          var _ref10;\n\n          if (_isArray7) {\n            if (_i11 >= _iterator7.length) break;\n            _ref10 = _iterator7[_i11++];\n          } else {\n            _i11 = _iterator7.next();\n            if (_i11.done) break;\n            _ref10 = _i11.value;\n          }\n\n          var command = _ref10;\n\n          for (var _i12 = 0; _i12 < command.args.length; _i12 += 2) {\n            cbox.addPoint(command.args[_i12], command.args[_i12 + 1]);\n          }\n        }\n\n        this._cbox = (0, _freeze2.default)(cbox);\n      }\n\n      return this._cbox;\n    }\n    /**\n     * Gets the exact bounding box of the path by evaluating curve segments.\n     * Slower to compute than the control box, but more accurate.\n     * @type {BBox}\n     */\n\n  }, {\n    key: 'bbox',\n    get: function get() {\n      if (this._bbox) {\n        return this._bbox;\n      }\n\n      var bbox = new _BBox2.default();\n      var cx = 0;\n      var cy = 0;\n\n      var f = function f(t) {\n        return Math.pow(1 - t, 3) * p0[i] + 3 * Math.pow(1 - t, 2) * t * p1[i] + 3 * (1 - t) * Math.pow(t, 2) * p2[i] + Math.pow(t, 3) * p3[i];\n      };\n\n      for (var _iterator8 = this.commands, _isArray8 = Array.isArray(_iterator8), _i13 = 0, _iterator8 = _isArray8 ? _iterator8 : (0, _getIterator3.default)(_iterator8);;) {\n        var _ref12;\n\n        if (_isArray8) {\n          if (_i13 >= _iterator8.length) break;\n          _ref12 = _iterator8[_i13++];\n        } else {\n          _i13 = _iterator8.next();\n          if (_i13.done) break;\n          _ref12 = _i13.value;\n        }\n\n        var _ref11 = _ref12;\n        var command = _ref11.command,\n            args = _ref11.args;\n\n        switch (command) {\n          case 'moveTo':\n          case 'lineTo':\n            var _args = args,\n                x = _args[0],\n                y = _args[1];\n            bbox.addPoint(x, y);\n            cx = x;\n            cy = y;\n            break;\n\n          case 'quadraticCurveTo':\n            args = _quadraticToBezier.apply(undefined, [cx, cy].concat(args));\n          // fall through\n\n          case 'bezierCurveTo':\n            var _args2 = args,\n                cp1x = _args2[0],\n                cp1y = _args2[1],\n                cp2x = _args2[2],\n                cp2y = _args2[3],\n                p3x = _args2[4],\n                p3y = _args2[5]; // http://blog.hackers-cafe.net/2009/06/how-to-calculate-bezier-curves-bounding.html\n\n            bbox.addPoint(p3x, p3y);\n            var _p = [cx, cy];\n            var _p2 = [cp1x, cp1y];\n            var _p3 = [cp2x, cp2y];\n            var _p4 = [p3x, p3y];\n\n            for (var _i14 = 0; _i14 <= 1; _i14++) {\n              var b = 6 * _p[_i14] - 12 * _p2[_i14] + 6 * _p3[_i14];\n              var a = -3 * _p[_i14] + 9 * _p2[_i14] - 9 * _p3[_i14] + 3 * _p4[_i14];\n              var c = 3 * _p2[_i14] - 3 * _p[_i14];\n\n              if (a === 0) {\n                if (b === 0) {\n                  continue;\n                }\n\n                var t = -c / b;\n\n                if (0 < t && t < 1) {\n                  if (_i14 === 0) {\n                    bbox.addPoint(f(t), bbox.maxY);\n                  } else if (_i14 === 1) {\n                    bbox.addPoint(bbox.maxX, f(t));\n                  }\n                }\n\n                continue;\n              }\n\n              var b2ac = Math.pow(b, 2) - 4 * c * a;\n\n              if (b2ac < 0) {\n                continue;\n              }\n\n              var t1 = (-b + Math.sqrt(b2ac)) / (2 * a);\n\n              if (0 < t1 && t1 < 1) {\n                if (_i14 === 0) {\n                  bbox.addPoint(f(t1), bbox.maxY);\n                } else if (_i14 === 1) {\n                  bbox.addPoint(bbox.maxX, f(t1));\n                }\n              }\n\n              var t2 = (-b - Math.sqrt(b2ac)) / (2 * a);\n\n              if (0 < t2 && t2 < 1) {\n                if (_i14 === 0) {\n                  bbox.addPoint(f(t2), bbox.maxY);\n                } else if (_i14 === 1) {\n                  bbox.addPoint(bbox.maxX, f(t2));\n                }\n              }\n            }\n\n            cx = p3x;\n            cy = p3y;\n            break;\n\n          default:\n            break;\n        }\n      }\n\n      return this._bbox = (0, _freeze2.default)(bbox);\n    }\n  }, {\n    key: 'isFlat',\n    get: function get() {\n      return !this._bezier && !this._quadratic;\n    }\n  }, {\n    key: 'isClockwise',\n    get: function get() {\n      // Source: http://stackoverflow.com/questions/1165647/how-to-determine-if-a-list-of-polygon-points-are-in-clockwise-order\n      // Original solution define that f the sum is positive, the points are in clockwise order.\n      // We check for the opposite condition because we are in an inverted cartesian coordinate system\n      var sx = 0;\n      var sy = 0;\n      var cx = 0;\n      var cy = 0;\n      var sum = 0;\n      var path = this.flatten();\n\n      for (var _iterator9 = path.commands, _isArray9 = Array.isArray(_iterator9), _i15 = 0, _iterator9 = _isArray9 ? _iterator9 : (0, _getIterator3.default)(_iterator9);;) {\n        var _ref14;\n\n        if (_isArray9) {\n          if (_i15 >= _iterator9.length) break;\n          _ref14 = _iterator9[_i15++];\n        } else {\n          _i15 = _iterator9.next();\n          if (_i15.done) break;\n          _ref14 = _i15.value;\n        }\n\n        var _ref13 = _ref14;\n        var command = _ref13.command,\n            args = _ref13.args;\n        var x = args[0],\n            y = args[1];\n\n        switch (command) {\n          case 'moveTo':\n            cx = x;\n            cy = y;\n            sx = x;\n            sy = y;\n            break;\n\n          case 'lineTo':\n            sum += (x - cx) * (cy + y);\n            cx = x;\n            cy = y;\n            break;\n\n          case 'closePath':\n            sum += (sx - cx) * (sy + cy);\n            break;\n\n          default:\n            throw new Error('Unknown path command: ' + command);\n        }\n      }\n\n      return sum < 0;\n    }\n  }]);\n  return Path;\n}();\n\nvar _loop = function _loop(command) {\n  Path.prototype[command] = function () {\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    this._bbox = this._cbox = null;\n    this.commands.push({\n      command: command,\n      args: args\n    });\n\n    if (command === 'bezierCurveTo') {\n      this._bezier = true;\n    } else if (command === 'quadraticCurveTo') {\n      this._quadratic = true;\n    }\n\n    return this;\n  };\n};\n\nfor (var _iterator10 = (0, _keys2.default)(SVG_COMMANDS), _isArray10 = Array.isArray(_iterator10), _i16 = 0, _iterator10 = _isArray10 ? _iterator10 : (0, _getIterator3.default)(_iterator10);;) {\n  var _ref15;\n\n  if (_isArray10) {\n    if (_i16 >= _iterator10.length) break;\n    _ref15 = _iterator10[_i16++];\n  } else {\n    _i16 = _iterator10.next();\n    if (_i16.done) break;\n    _ref15 = _i16.value;\n  }\n\n  var command = _ref15;\n\n  _loop(command);\n}\n\nfunction _quadraticToBezier(cx, cy, qp1x, qp1y, x, y) {\n  // http://fontforge.org/bezier.html\n  var cp1x = cx + 2 / 3 * (qp1x - cx); // CP1 = QP0 + 2/3 * (QP1-QP0)\n\n  var cp1y = cy + 2 / 3 * (qp1y - cy);\n  var cp2x = x + 2 / 3 * (qp1x - x); // CP2 = QP2 + 2/3 * (QP1-QP2)\n\n  var cp2y = y + 2 / 3 * (qp1y - y);\n  return [cp1x, cp1y, cp2x, cp2y, x, y];\n}\n\nfunction subdivideBezierWithFlatness(path, flatness, cx, cy, cp1x, cp1y, cp2x, cp2y, x, y) {\n  var dx1 = cp1x - cx;\n  var dx2 = cp2x - cp1x;\n  var dx3 = x - cp2x;\n  var dx4 = dx2 - dx1;\n  var dx5 = dx3 - dx2;\n  var dx6 = dx5 - dx4;\n  var dy1 = cp1y - cy;\n  var dy2 = cp2y - cp1y;\n  var dy3 = y - cp2y;\n  var dy4 = dy2 - dy1;\n  var dy5 = dy3 - dy2;\n  var dy6 = dy5 - dy4;\n  var d1 = dx4 * dx4 + dy4 * dy4;\n  var d2 = dx5 * dx5 + dy5 * dy5;\n  var flatnessSqr = flatness * flatness;\n  var wat = 9 * Math.max(d1, d2) / 16;\n  var wat2 = 6 * dx6;\n  var wat3 = 6 * (dx4 + dx6);\n  var wat4 = 3 * (dx1 + dx4) + dx6;\n  var wat5 = 6 * dy6;\n  var wat6 = 6 * (dy4 + dy6);\n  var wat7 = 3 * (dy1 + dy4) + dy6;\n  var f = 1;\n\n  while (wat > flatnessSqr && f <= 65535) {\n    wat2 /= 8;\n    wat3 = wat3 / 4 - wat2;\n    wat4 = wat4 / 2 - wat3 / 2;\n    wat5 /= 8;\n    wat6 = wat6 / 4 - wat5;\n    wat7 = wat7 / 2 - wat6 / 2;\n    wat /= 16;\n    f <<= 1;\n  }\n\n  while (--f > 0) {\n    cx += wat4;\n    wat4 += wat3;\n    wat3 += wat2;\n    cy += wat7;\n    wat7 += wat6;\n    wat6 += wat5;\n    path.lineTo(cx, cy);\n  }\n\n  path.lineTo(x, y);\n}\n\nexports.default = Path;","map":null,"metadata":{},"sourceType":"script"}