{"ast":null,"code":"\"use strict\";\n/*!\n * Copyright 2017 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nvar _classCallCheck = require(\"/Users/cvoisin/Repos/actandcaredev/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/cvoisin/Repos/actandcaredev/node_modules/@babel/runtime/helpers/createClass\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar assert = require(\"assert\");\n\nvar document_1 = require(\"./document\");\n\nvar logger_1 = require(\"./logger\");\n\nvar path_1 = require(\"./path\");\n\nvar serializer_1 = require(\"./serializer\");\n\nvar timestamp_1 = require(\"./timestamp\");\n\nvar util_1 = require(\"./util\");\n/*!\n * Google Cloud Functions terminates idle connections after two minutes. After\n * longer periods of idleness, we issue transactional commits to allow for\n * retries.\n */\n\n\nvar GCF_IDLE_TIMEOUT_MS = 110 * 1000;\n/**\n * A WriteResult wraps the write time set by the Firestore servers on sets(),\n * updates(), and creates().\n *\n * @class\n */\n\nvar WriteResult =\n/*#__PURE__*/\nfunction () {\n  /**\n   * @private\n   * @hideconstructor\n   *\n   * @param _writeTime The time of the corresponding document write.\n   */\n  function WriteResult(_writeTime) {\n    _classCallCheck(this, WriteResult);\n\n    this._writeTime = _writeTime;\n  }\n  /**\n   * The write time as set by the Firestore servers.\n   *\n   * @type {Timestamp}\n   * @name WriteResult#writeTime\n   * @readonly\n   *\n   * @example\n   * let documentRef = firestore.doc('col/doc');\n   *\n   * documentRef.set({foo: 'bar'}).then(writeResult => {\n   *   console.log(`Document written at: ${writeResult.toDate()}`);\n   * });\n   */\n\n\n  _createClass(WriteResult, [{\n    key: \"isEqual\",\n\n    /**\n     * Returns true if this `WriteResult` is equal to the provided value.\n     *\n     * @param {*} other The value to compare against.\n     * @return true if this `WriteResult` is equal to the provided value.\n     */\n    value: function isEqual(other) {\n      return this === other || other instanceof WriteResult && this._writeTime.isEqual(other._writeTime);\n    }\n  }, {\n    key: \"writeTime\",\n    get: function get() {\n      return this._writeTime;\n    }\n  }]);\n\n  return WriteResult;\n}();\n\nexports.WriteResult = WriteResult;\n/**\n * A Firestore WriteBatch that can be used to atomically commit multiple write\n * operations at once.\n *\n * @class\n */\n\nvar WriteBatch =\n/*#__PURE__*/\nfunction () {\n  /**\n   * @private\n   * @hideconstructor\n   *\n   * @param {Firestore} firestore The Firestore Database client.\n   */\n  function WriteBatch(firestore) {\n    _classCallCheck(this, WriteBatch);\n\n    this._writes = [];\n    this._committed = false;\n    this._firestore = firestore;\n    this._validator = firestore._validator;\n    this._serializer = new serializer_1.Serializer(firestore);\n  }\n  /**\n   * Checks if this write batch has any pending operations.\n   *\n   * @private\n   */\n\n\n  _createClass(WriteBatch, [{\n    key: \"verifyNotCommitted\",\n\n    /**\n     * Throws an error if this batch has already been committed.\n     *\n     * @private\n     */\n    value: function verifyNotCommitted() {\n      if (this._committed) {\n        throw new Error('Cannot modify a WriteBatch that has been committed.');\n      }\n    }\n    /**\n     * Create a document with the provided object values. This will fail the batch\n     * if a document exists at its location.\n     *\n     * @param {DocumentReference} documentRef A reference to the document to be\n     * created.\n     * @param {DocumentData} data The object to serialize as the document.\n     * @returns {WriteBatch} This WriteBatch instance. Used for chaining\n     * method calls.\n     *\n     * @example\n     * let writeBatch = firestore.batch();\n     * let documentRef = firestore.collection('col').doc();\n     *\n     * writeBatch.create(documentRef, {foo: 'bar'});\n     *\n     * writeBatch.commit().then(() => {\n     *   console.log('Successfully executed batch.');\n     * });\n     */\n\n  }, {\n    key: \"create\",\n    value: function create(documentRef, data) {\n      this._validator.isDocumentReference('documentRef', documentRef);\n\n      this._validator.isDocument('data', data, {\n        allowEmpty: true,\n        allowDeletes: 'none',\n        allowTransforms: true\n      });\n\n      this.verifyNotCommitted();\n      var document = document_1.DocumentSnapshot.fromObject(documentRef, data);\n      var precondition = new document_1.Precondition({\n        exists: false\n      });\n      var transform = document_1.DocumentTransform.fromObject(documentRef, data);\n      transform.validate();\n\n      this._writes.push({\n        write: !document.isEmpty || transform.isEmpty ? document.toProto() : null,\n        transform: transform.toProto(this._serializer),\n        precondition: precondition.toProto()\n      });\n\n      return this;\n    }\n    /**\n     * Deletes a document from the database.\n     *\n     * @param {DocumentReference} documentRef A reference to the document to be\n     * deleted.\n     * @param {Precondition=} precondition A precondition to enforce for this\n     * delete.\n     * @param {Timestamp=} precondition.lastUpdateTime If set, enforces that the\n     * document was last updated at lastUpdateTime. Fails the batch if the\n     * document doesn't exist or was last updated at a different time.\n     * @returns {WriteBatch} This WriteBatch instance. Used for chaining\n     * method calls.\n     *\n     * @example\n     * let writeBatch = firestore.batch();\n     * let documentRef = firestore.doc('col/doc');\n     *\n     * writeBatch.delete(documentRef);\n     *\n     * writeBatch.commit().then(() => {\n     *   console.log('Successfully executed batch.');\n     * });\n     */\n\n  }, {\n    key: \"delete\",\n    value: function _delete(documentRef, precondition) {\n      this._validator.isDocumentReference('documentRef', documentRef);\n\n      this._validator.isOptionalDeletePrecondition('precondition', precondition);\n\n      this.verifyNotCommitted();\n      var conditions = new document_1.Precondition(precondition);\n\n      this._writes.push({\n        write: {\n          delete: documentRef.formattedName\n        },\n        precondition: conditions.toProto()\n      });\n\n      return this;\n    }\n    /**\n     * Write to the document referred to by the provided\n     * [DocumentReference]{@link DocumentReference}.\n     * If the document does not exist yet, it will be created. If you pass\n     * [SetOptions]{@link SetOptions}., the provided data can be merged\n     * into the existing document.\n     *\n     * @param {DocumentReference} documentRef A reference to the document to be\n     * set.\n     * @param {DocumentData} data The object to serialize as the document.\n     * @param {SetOptions=} options An object to configure the set behavior.\n     * @param {boolean=} options.merge - If true, set() merges the values\n     * specified in its data argument. Fields omitted from this set() call\n     * remain untouched.\n     * @param {Array.<string|FieldPath>=} options.mergeFields - If provided,\n     * set() only replaces the specified field paths. Any field path that is not\n     * specified is ignored and remains untouched.\n     * @returns {WriteBatch} This WriteBatch instance. Used for chaining\n     * method calls.\n     *\n     * @example\n     * let writeBatch = firestore.batch();\n     * let documentRef = firestore.doc('col/doc');\n     *\n     * writeBatch.set(documentRef, {foo: 'bar'});\n     *\n     * writeBatch.commit().then(() => {\n     *   console.log('Successfully executed batch.');\n     * });\n     */\n\n  }, {\n    key: \"set\",\n    value: function set(documentRef, data, options) {\n      this._validator.isOptionalSetOptions('options', options);\n\n      var mergeLeaves = options && options.merge === true;\n      var mergePaths = options && options.mergeFields;\n\n      this._validator.isDocumentReference('documentRef', documentRef);\n\n      this._validator.isDocument('data', data, {\n        allowEmpty: true,\n        allowDeletes: mergePaths || mergeLeaves ? 'all' : 'none',\n        allowTransforms: true\n      });\n\n      this.verifyNotCommitted();\n      var documentMask;\n\n      if (mergePaths) {\n        documentMask = document_1.DocumentMask.fromFieldMask(options.mergeFields);\n        data = documentMask.applyTo(data);\n      }\n\n      var transform = document_1.DocumentTransform.fromObject(documentRef, data);\n      transform.validate();\n      var document = document_1.DocumentSnapshot.fromObject(documentRef, data);\n\n      if (mergePaths) {\n        documentMask.removeFields(transform.fields);\n      } else {\n        documentMask = document_1.DocumentMask.fromObject(data);\n      }\n\n      var hasDocumentData = !document.isEmpty || !documentMask.isEmpty;\n      var write;\n\n      if (!mergePaths && !mergeLeaves) {\n        write = document.toProto();\n      } else if (hasDocumentData || transform.isEmpty) {\n        write = document.toProto();\n        write.updateMask = documentMask.toProto(this._serializer);\n      }\n\n      this._writes.push({\n        write: write,\n        transform: transform.toProto(this._serializer)\n      });\n\n      return this;\n    }\n    /**\n     * Update fields of the document referred to by the provided\n     * [DocumentReference]{@link DocumentReference}. If the document\n     * doesn't yet exist, the update fails and the entire batch will be rejected.\n     *\n     * The update() method accepts either an object with field paths encoded as\n     * keys and field values encoded as values, or a variable number of arguments\n     * that alternate between field paths and field values. Nested fields can be\n     * updated by providing dot-separated field path strings or by providing\n     * FieldPath objects.\n     *\n     * A Precondition restricting this update can be specified as the last\n     * argument.\n     *\n     * @param {DocumentReference} documentRef A reference to the document to be\n     * updated.\n     * @param {UpdateData|string|FieldPath} dataOrField An object\n     * containing the fields and values with which to update the document\n     * or the path of the first field to update.\n     * @param {\n     * ...(Precondition|*|string|FieldPath)} preconditionOrValues -\n     * An alternating list of field paths and values to update or a Precondition\n     * to restrict this update.\n     * @returns {WriteBatch} This WriteBatch instance. Used for chaining\n     * method calls.\n     *\n     * @example\n     * let writeBatch = firestore.batch();\n     * let documentRef = firestore.doc('col/doc');\n     *\n     * writeBatch.update(documentRef, {foo: 'bar'});\n     *\n     * writeBatch.commit().then(() => {\n     *   console.log('Successfully executed batch.');\n     * });\n     */\n\n  }, {\n    key: \"update\",\n    value: function update(documentRef, dataOrField) {\n      var _this = this;\n\n      for (var _len = arguments.length, preconditionOrValues = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n        preconditionOrValues[_key - 2] = arguments[_key];\n      }\n\n      this._validator.minNumberOfArguments('update', arguments, 2);\n\n      this._validator.isDocumentReference('documentRef', documentRef);\n\n      this.verifyNotCommitted();\n      var updateMap = new Map();\n      var precondition = new document_1.Precondition({\n        exists: true\n      });\n      var argumentError = 'Update() requires either a single JavaScript ' + 'object or an alternating list of field/value pairs that can be ' + 'followed by an optional precondition.';\n      var usesVarargs = typeof dataOrField === 'string' || dataOrField instanceof path_1.FieldPath;\n\n      if (usesVarargs) {\n        try {\n          for (var i = 1; i < arguments.length; i += 2) {\n            if (i === arguments.length - 1) {\n              this._validator.isUpdatePrecondition(i, arguments[i]);\n\n              precondition = new document_1.Precondition(arguments[i]);\n            } else {\n              this._validator.isFieldPath(i, arguments[i]);\n\n              this._validator.minNumberOfArguments('update', arguments, i + 1);\n\n              var fieldPath = path_1.FieldPath.fromArgument(arguments[i]);\n\n              this._validator.isFieldValue(i, arguments[i + 1], {\n                allowDeletes: 'root',\n                allowTransforms: true\n              }, fieldPath);\n\n              updateMap.set(fieldPath, arguments[i + 1]);\n            }\n          }\n        } catch (err) {\n          logger_1.logger('WriteBatch.update', null, 'Varargs validation failed:', err); // We catch the validation error here and re-throw to provide a better\n          // error message.\n\n          throw new Error(\"\".concat(argumentError, \" \").concat(err.message));\n        }\n      } else {\n        try {\n          this._validator.isDocument('dataOrField', dataOrField, {\n            allowEmpty: false,\n            allowDeletes: 'root',\n            allowTransforms: true\n          });\n\n          this._validator.maxNumberOfArguments('update', arguments, 3);\n\n          Object.keys(dataOrField).forEach(function (key) {\n            _this._validator.isFieldPath(key, key);\n\n            updateMap.set(path_1.FieldPath.fromArgument(key), dataOrField[key]);\n          });\n\n          if (preconditionOrValues.length > 0) {\n            this._validator.isUpdatePrecondition('preconditionOrValues', preconditionOrValues[0]);\n\n            precondition = new document_1.Precondition(preconditionOrValues[0]);\n          }\n        } catch (err) {\n          logger_1.logger('WriteBatch.update', null, 'Non-varargs validation failed:', err); // We catch the validation error here and prefix the error with a custom\n          // message to describe the usage of update() better.\n\n          throw new Error(\"\".concat(argumentError, \" \").concat(err.message));\n        }\n      }\n\n      this._validator.isUpdateMap('dataOrField', updateMap);\n\n      var document = document_1.DocumentSnapshot.fromUpdateMap(documentRef, updateMap);\n      var documentMask = document_1.DocumentMask.fromUpdateMap(updateMap);\n      var write = null;\n\n      if (!document.isEmpty || !documentMask.isEmpty) {\n        write = document.toProto();\n        write.updateMask = documentMask.toProto();\n      }\n\n      var transform = document_1.DocumentTransform.fromUpdateMap(documentRef, updateMap);\n      transform.validate();\n\n      this._writes.push({\n        write: write,\n        transform: transform.toProto(this._serializer),\n        precondition: precondition.toProto()\n      });\n\n      return this;\n    }\n    /**\n     * Atomically commits all pending operations to the database and verifies all\n     * preconditions. Fails the entire write if any precondition is not met.\n     *\n     * @returns {Promise.<Array.<WriteResult>>} A Promise that resolves\n     * when this batch completes.\n     *\n     * @example\n     * let writeBatch = firestore.batch();\n     * let documentRef = firestore.doc('col/doc');\n     *\n     * writeBatch.set(documentRef, {foo: 'bar'});\n     *\n     * writeBatch.commit().then(() => {\n     *   console.log('Successfully executed batch.');\n     * });\n     */\n\n  }, {\n    key: \"commit\",\n    value: function commit() {\n      return this.commit_();\n    }\n    /**\n     * Commit method that takes an optional transaction ID.\n     *\n     * @private\n     * @param commitOptions Options to use for this commit.\n     * @param commitOptions.transactionId The transaction ID of this commit.\n     * @param commitOptions.requestTag A unique client-assigned identifier for\n     * this request.\n     * @returns  A Promise that resolves when this batch completes.\n     */\n\n  }, {\n    key: \"commit_\",\n    value: function commit_(commitOptions) {\n      var _this2 = this;\n\n      // Note: We don't call `verifyNotCommitted()` to allow for retries.\n      var explicitTransaction = commitOptions && commitOptions.transactionId;\n      var tag = commitOptions && commitOptions.requestTag || util_1.requestTag();\n      var request = {\n        database: this._firestore.formattedName\n      }; // On GCF, we periodically force transactional commits to allow for\n      // request retries in case GCF closes our backend connection.\n\n      if (!explicitTransaction && this._shouldCreateTransaction()) {\n        logger_1.logger('WriteBatch.commit', tag, 'Using transaction for commit');\n        return this._firestore.request('beginTransaction', request, tag, true).then(function (resp) {\n          return _this2.commit_({\n            transactionId: resp.transaction\n          });\n        });\n      }\n\n      request.writes = [];\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = this._writes[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var req = _step.value;\n          assert(req.write || req.transform, 'Either a write or transform must be set');\n\n          if (req.precondition) {\n            (req.write || req.transform).currentDocument = req.precondition;\n          }\n\n          if (req.write) {\n            request.writes.push(req.write);\n          }\n\n          if (req.transform) {\n            request.writes.push(req.transform);\n          }\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return != null) {\n            _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n\n      logger_1.logger('WriteBatch.commit', tag, 'Sending %d writes', request.writes.length);\n\n      if (explicitTransaction) {\n        request.transaction = explicitTransaction;\n      }\n\n      this._committed = true;\n      return this._firestore.request('commit', request, tag,\n      /* allowRetries= */\n      false).then(function (resp) {\n        var writeResults = [];\n\n        if (request.writes.length > 0) {\n          assert(Array.isArray(resp.writeResults) && request.writes.length === resp.writeResults.length, \"Expected one write result per operation, but got \".concat(resp.writeResults.length, \" results for \").concat(request.writes.length, \" operations.\"));\n          var commitTime = timestamp_1.Timestamp.fromProto(resp.commitTime);\n          var offset = 0;\n\n          for (var i = 0; i < _this2._writes.length; ++i) {\n            var writeRequest = _this2._writes[i]; // Don't return two write results for a write that contains a\n            // transform, as the fact that we have to split one write\n            // operation into two distinct write requests is an implementation\n            // detail.\n\n            if (writeRequest.write && writeRequest.transform) {\n              // The document transform is always sent last and produces the\n              // latest update time.\n              ++offset;\n            }\n\n            var writeResult = resp.writeResults[i + offset];\n            writeResults.push(new WriteResult(writeResult.updateTime ? timestamp_1.Timestamp.fromProto(writeResult.updateTime) : commitTime));\n          }\n        }\n\n        return writeResults;\n      });\n    }\n    /**\n     * Determines whether we should issue a transactional commit. On GCF, this\n     * happens after two minutes of idleness.\n     *\n     * @private\n     * @returns Whether to use a transaction.\n     */\n\n  }, {\n    key: \"_shouldCreateTransaction\",\n    value: function _shouldCreateTransaction() {\n      if (!this._firestore._preferTransactions) {\n        return false;\n      }\n\n      if (this._firestore._lastSuccessfulRequest) {\n        var now = new Date().getTime();\n        return now - this._firestore._lastSuccessfulRequest > GCF_IDLE_TIMEOUT_MS;\n      }\n\n      return true;\n    }\n  }, {\n    key: \"isEmpty\",\n    get: function get() {\n      return this._writes.length === 0;\n    }\n  }]);\n\n  return WriteBatch;\n}();\n\nexports.WriteBatch = WriteBatch;\n/*!\n * Validates that the update data does not contain any ambiguous field\n * definitions (such as 'a.b' and 'a').\n *\n * @param data An update map with field/value pairs.\n * @returns 'true' if the input is a valid update map.\n */\n\nfunction validateUpdateMap(data) {\n  var fields = [];\n  data.forEach(function (value, key) {\n    fields.push(key);\n  });\n  fields.sort(function (left, right) {\n    return left.compareTo(right);\n  });\n\n  for (var i = 1; i < fields.length; ++i) {\n    if (fields[i - 1].isPrefixOf(fields[i])) {\n      throw new Error(\"Field \\\"\".concat(fields[i - 1], \"\\\" was specified multiple times.\"));\n    }\n  }\n\n  return true;\n}\n\nexports.validateUpdateMap = validateUpdateMap;","map":null,"metadata":{},"sourceType":"script"}