{"ast":null,"code":"\"use strict\";\n/**\r\n * Various utility functions.\r\n * @namespace\r\n */\n\nvar util = module.exports = require(\"./util/minimal\");\n\nvar roots = require(\"./roots\");\n\nvar Type, // cyclic\nEnum;\nutil.codegen = require(\"@protobufjs/codegen\");\nutil.fetch = require(\"@protobufjs/fetch\");\nutil.path = require(\"@protobufjs/path\");\n/**\r\n * Node's fs module if available.\r\n * @type {Object.<string,*>}\r\n */\n\nutil.fs = util.inquire(\"fs\");\n/**\r\n * Converts an object's values to an array.\r\n * @param {Object.<string,*>} object Object to convert\r\n * @returns {Array.<*>} Converted array\r\n */\n\nutil.toArray = function toArray(object) {\n  if (object) {\n    var keys = Object.keys(object),\n        array = new Array(keys.length),\n        index = 0;\n\n    while (index < keys.length) {\n      array[index] = object[keys[index++]];\n    }\n\n    return array;\n  }\n\n  return [];\n};\n/**\r\n * Converts an array of keys immediately followed by their respective value to an object, omitting undefined values.\r\n * @param {Array.<*>} array Array to convert\r\n * @returns {Object.<string,*>} Converted object\r\n */\n\n\nutil.toObject = function toObject(array) {\n  var object = {},\n      index = 0;\n\n  while (index < array.length) {\n    var key = array[index++],\n        val = array[index++];\n    if (val !== undefined) object[key] = val;\n  }\n\n  return object;\n};\n\nvar safePropBackslashRe = /\\\\/g,\n    safePropQuoteRe = /\"/g;\n/**\r\n * Tests whether the specified name is a reserved word in JS.\r\n * @param {string} name Name to test\r\n * @returns {boolean} `true` if reserved, otherwise `false`\r\n */\n\nutil.isReserved = function isReserved(name) {\n  return /^(?:do|if|in|for|let|new|try|var|case|else|enum|eval|false|null|this|true|void|with|break|catch|class|const|super|throw|while|yield|delete|export|import|public|return|static|switch|typeof|default|extends|finally|package|private|continue|debugger|function|arguments|interface|protected|implements|instanceof)$/.test(name);\n};\n/**\r\n * Returns a safe property accessor for the specified property name.\r\n * @param {string} prop Property name\r\n * @returns {string} Safe accessor\r\n */\n\n\nutil.safeProp = function safeProp(prop) {\n  if (!/^[$\\w_]+$/.test(prop) || util.isReserved(prop)) return \"[\\\"\" + prop.replace(safePropBackslashRe, \"\\\\\\\\\").replace(safePropQuoteRe, \"\\\\\\\"\") + \"\\\"]\";\n  return \".\" + prop;\n};\n/**\r\n * Converts the first character of a string to upper case.\r\n * @param {string} str String to convert\r\n * @returns {string} Converted string\r\n */\n\n\nutil.ucFirst = function ucFirst(str) {\n  return str.charAt(0).toUpperCase() + str.substring(1);\n};\n\nvar camelCaseRe = /_([a-z])/g;\n/**\r\n * Converts a string to camel case.\r\n * @param {string} str String to convert\r\n * @returns {string} Converted string\r\n */\n\nutil.camelCase = function camelCase(str) {\n  return str.substring(0, 1) + str.substring(1).replace(camelCaseRe, function ($0, $1) {\n    return $1.toUpperCase();\n  });\n};\n/**\r\n * Compares reflected fields by id.\r\n * @param {Field} a First field\r\n * @param {Field} b Second field\r\n * @returns {number} Comparison value\r\n */\n\n\nutil.compareFieldsById = function compareFieldsById(a, b) {\n  return a.id - b.id;\n};\n/**\r\n * Decorator helper for types (TypeScript).\r\n * @param {Constructor<T>} ctor Constructor function\r\n * @param {string} [typeName] Type name, defaults to the constructor's name\r\n * @returns {Type} Reflected type\r\n * @template T extends Message<T>\r\n * @property {Root} root Decorators root\r\n */\n\n\nutil.decorateType = function decorateType(ctor, typeName) {\n  /* istanbul ignore if */\n  if (ctor.$type) {\n    if (typeName && ctor.$type.name !== typeName) {\n      util.decorateRoot.remove(ctor.$type);\n      ctor.$type.name = typeName;\n      util.decorateRoot.add(ctor.$type);\n    }\n\n    return ctor.$type;\n  }\n  /* istanbul ignore next */\n\n\n  if (!Type) Type = require(\"./type\");\n  var type = new Type(typeName || ctor.name);\n  util.decorateRoot.add(type);\n  type.ctor = ctor; // sets up .encode, .decode etc.\n\n  Object.defineProperty(ctor, \"$type\", {\n    value: type,\n    enumerable: false\n  });\n  Object.defineProperty(ctor.prototype, \"$type\", {\n    value: type,\n    enumerable: false\n  });\n  return type;\n};\n\nvar decorateEnumIndex = 0;\n/**\r\n * Decorator helper for enums (TypeScript).\r\n * @param {Object} object Enum object\r\n * @returns {Enum} Reflected enum\r\n */\n\nutil.decorateEnum = function decorateEnum(object) {\n  /* istanbul ignore if */\n  if (object.$type) return object.$type;\n  /* istanbul ignore next */\n\n  if (!Enum) Enum = require(\"./enum\");\n  var enm = new Enum(\"Enum\" + decorateEnumIndex++, object);\n  util.decorateRoot.add(enm);\n  Object.defineProperty(object, \"$type\", {\n    value: enm,\n    enumerable: false\n  });\n  return enm;\n};\n/**\r\n * Decorator root (TypeScript).\r\n * @name util.decorateRoot\r\n * @type {Root}\r\n * @readonly\r\n */\n\n\nObject.defineProperty(util, \"decorateRoot\", {\n  get: function get() {\n    return roots[\"decorated\"] || (roots[\"decorated\"] = new (require(\"./root\"))());\n  }\n});","map":null,"metadata":{},"sourceType":"script"}