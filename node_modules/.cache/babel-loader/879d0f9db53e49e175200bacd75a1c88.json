{"ast":null,"code":"\"use strict\";\n/*!\n * Copyright 2017 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nvar _classCallCheck = require(\"/Users/cvoisin/Repos/actandcaredev/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/cvoisin/Repos/actandcaredev/node_modules/@babel/runtime/helpers/createClass\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar logger_1 = require(\"./logger\");\n/*\n * @module firestore/backoff\n * @private\n *\n * Contains backoff logic to facilitate RPC error handling. This class derives\n * its implementation from the Firestore Mobile Web Client.\n *\n * @see https://github.com/firebase/firebase-js-sdk/blob/master/packages/firestore/src/remote/backoff.ts\n */\n\n/*!\n * The default initial backoff time in milliseconds after an error.\n * Set to 1s according to https://cloud.google.com/apis/design/errors.\n */\n\n\nvar DEFAULT_BACKOFF_INITIAL_DELAY_MS = 1000;\n/*!\n * The default maximum backoff time in milliseconds.\n */\n\nvar DEFAULT_BACKOFF_MAX_DELAY_MS = 60 * 1000;\n/*!\n * The default factor to increase the backup by after each failed attempt.\n */\n\nvar DEFAULT_BACKOFF_FACTOR = 1.5;\n/*!\n * The default jitter to distribute the backoff attempts by (0 means no\n * randomization, 1.0 means +/-50% randomization).\n */\n\nvar DEFAULT_JITTER_FACTOR = 1.0;\n/*!\n * The timeout handler used by `ExponentialBackoff`.\n */\n\nvar delayExecution = setTimeout;\n/**\n * Allows overriding of the timeout handler used by the exponential backoff\n * implementation. If not invoked, we default to `setTimeout()`.\n *\n * Used only in testing.\n *\n * @private\n * @param {function} handler A handler than matches the API of `setTimeout()`.\n */\n\nfunction setTimeoutHandler(handler) {\n  delayExecution = handler;\n}\n\nexports.setTimeoutHandler = setTimeoutHandler;\n/**\n * A helper for running delayed tasks following an exponential backoff curve\n * between attempts.\n *\n * Each delay is made up of a \"base\" delay which follows the exponential\n * backoff curve, and a \"jitter\" (+/- 50% by default)  that is calculated and\n * added to the base delay. This prevents clients from accidentally\n * synchronizing their delays causing spikes of load to the backend.\n *\n * @private\n */\n\nvar ExponentialBackoff =\n/*#__PURE__*/\nfunction () {\n  function ExponentialBackoff() {\n    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _classCallCheck(this, ExponentialBackoff);\n\n    /**\n     * The backoff delay of the current attempt.\n     */\n    this.currentBaseMs = 0;\n    this.initialDelayMs = options.initialDelayMs !== undefined ? options.initialDelayMs : DEFAULT_BACKOFF_INITIAL_DELAY_MS;\n    this.backoffFactor = options.backoffFactor !== undefined ? options.backoffFactor : DEFAULT_BACKOFF_FACTOR;\n    this.maxDelayMs = options.maxDelayMs !== undefined ? options.maxDelayMs : DEFAULT_BACKOFF_MAX_DELAY_MS;\n    this.jitterFactor = options.jitterFactor !== undefined ? options.jitterFactor : DEFAULT_JITTER_FACTOR;\n  }\n  /**\n   * Resets the backoff delay.\n   *\n   * The very next backoffAndWait() will have no delay. If it is called again\n   * (i.e. due to an error), initialDelayMs (plus jitter) will be used, and\n   * subsequent ones will increase according to the backoffFactor.\n   */\n\n\n  _createClass(ExponentialBackoff, [{\n    key: \"reset\",\n    value: function reset() {\n      this.currentBaseMs = 0;\n    }\n    /**\n     * Resets the backoff delay to the maximum delay (e.g. for use after a\n     * RESOURCE_EXHAUSTED error).\n     */\n\n  }, {\n    key: \"resetToMax\",\n    value: function resetToMax() {\n      this.currentBaseMs = this.maxDelayMs;\n    }\n    /**\n     * Returns a promise that resolves after currentDelayMs, and increases the\n     * delay for any subsequent attempts.\n     *\n     * @return A Promise that resolves when the current delay elapsed.\n     */\n\n  }, {\n    key: \"backoffAndWait\",\n    value: function backoffAndWait() {\n      // First schedule using the current base (which may be 0 and should be\n      // honored as such).\n      var delayWithJitterMs = this.currentBaseMs + this.jitterDelayMs();\n\n      if (this.currentBaseMs > 0) {\n        logger_1.logger('ExponentialBackoff.backoffAndWait', null, \"Backing off for \".concat(delayWithJitterMs, \" ms \") + \"(base delay: \".concat(this.currentBaseMs, \" ms)\"));\n      } // Apply backoff factor to determine next delay and ensure it is within\n      // bounds.\n\n\n      this.currentBaseMs *= this.backoffFactor;\n      this.currentBaseMs = Math.max(this.currentBaseMs, this.initialDelayMs);\n      this.currentBaseMs = Math.min(this.currentBaseMs, this.maxDelayMs);\n      return new Promise(function (resolve) {\n        delayExecution(resolve, delayWithJitterMs);\n      });\n    }\n    /**\n     * Returns a randomized \"jitter\" delay based on the current base and jitter\n     * factor.\n     *\n     * @private\n     * @returns {number} The jitter to apply based on the current delay.\n     */\n\n  }, {\n    key: \"jitterDelayMs\",\n    value: function jitterDelayMs() {\n      return (Math.random() - 0.5) * this.jitterFactor * this.currentBaseMs;\n    }\n  }]);\n\n  return ExponentialBackoff;\n}();\n\nexports.ExponentialBackoff = ExponentialBackoff;","map":null,"metadata":{},"sourceType":"script"}