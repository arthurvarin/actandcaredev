{"ast":null,"code":"/**\n * @license\n * Copyright 2015 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n'use strict';\n\nvar path = require('path');\n\nvar fs = require('fs');\n\nvar util = require('util');\n\nvar SSL_ROOTS_PATH = path.resolve(__dirname, 'deps', 'grpc', 'etc', 'roots.pem');\n\nvar client = require('./src/client.js');\n\nvar server = require('./src/server.js');\n\nvar common = require('./src/common.js');\n\nvar Metadata = require('./src/metadata.js');\n\nvar grpc = require('./src/grpc_extension');\n\nvar protobuf_js_5_common = require('./src/protobuf_js_5_common');\n\nvar protobuf_js_6_common = require('./src/protobuf_js_6_common');\n\nvar constants = require('./src/constants.js');\n\ngrpc.setDefaultRootsPem(fs.readFileSync(SSL_ROOTS_PATH, 'ascii'));\n/**\n * @namespace grpc\n */\n\n/**\n * Load a ProtoBuf.js object as a gRPC object.\n * @memberof grpc\n * @alias grpc.loadObject\n * @param {Object} value The ProtoBuf.js reflection object to load\n * @param {Object=} options Options to apply to the loaded file\n * @param {bool=} [options.binaryAsBase64=false] deserialize bytes values as\n *     base64 strings instead of Buffers\n * @param {bool=} [options.longsAsStrings=true] deserialize long values as\n *     strings instead of objects\n * @param {bool=} [options.enumsAsStrings=true] deserialize enum values as\n *     strings instead of numbers. Only works with Protobuf.js 6 values.\n * @param {bool=} [options.deprecatedArgumentOrder=false] use the beta method\n *     argument order for client methods, with optional arguments after the\n *     callback. This option is only a temporary stopgap measure to smooth an\n *     API breakage. It is deprecated, and new code should not use it.\n * @param {(number|string)=} [options.protobufjsVersion='detect'] 5 and 6\n *     respectively indicate that an object from the corresponding version of\n *     Protobuf.js is provided in the value argument. If the option is 'detect',\n *     gRPC will guess what the version is based on the structure of the value.\n * @return {Object<string, *>} The resulting gRPC object.\n */\n\nexports.loadObject = function loadObject(value, options) {\n  options = Object.assign({}, common.defaultGrpcOptions, options);\n  options = Object.assign({}, {\n    'protobufjsVersion': 'detect'\n  }, options);\n  var protobufjsVersion;\n\n  if (options.protobufjsVersion === 'detect') {\n    if (protobuf_js_6_common.isProbablyProtobufJs6(value)) {\n      protobufjsVersion = 6;\n    } else if (protobuf_js_5_common.isProbablyProtobufJs5(value)) {\n      protobufjsVersion = 5;\n    } else {\n      var error_message = 'Could not detect ProtoBuf.js version. Please ' + 'specify the version number with the \"protobufjsVersion\" option';\n      throw new Error(error_message);\n    }\n  } else {\n    protobufjsVersion = options.protobufjsVersion;\n  }\n\n  switch (protobufjsVersion) {\n    case 6:\n      return protobuf_js_6_common.loadObject(value, options);\n\n    case 5:\n      return protobuf_js_5_common.loadObject(value, options);\n\n    default:\n      throw new Error('Unrecognized protobufjsVersion', protobufjsVersion);\n  }\n};\n\nvar loadObject = exports.loadObject;\n/**\n * Load a gRPC object from a .proto file.\n * @deprecated Use the {@link https://www.npmjs.com/package/@grpc/proto-loader|proto-loader module}\n       with grpc.loadPackageDefinition instead.\n * @memberof grpc\n * @alias grpc.load\n * @param {string|{root: string, file: string}} filename The file to load\n * @param {string=} format The file format to expect. Must be either 'proto' or\n *     'json'. Defaults to 'proto'\n * @param {Object=} options Options to apply to the loaded file\n * @param {bool=} [options.convertFieldsToCamelCase=false] Load this file with\n *     field names in camel case instead of their original case\n * @param {bool=} [options.binaryAsBase64=false] deserialize bytes values as\n *     base64 strings instead of Buffers\n * @param {bool=} [options.longsAsStrings=true] deserialize long values as\n *     strings instead of objects\n * @param {bool=} [options.deprecatedArgumentOrder=false] use the beta method\n *     argument order for client methods, with optional arguments after the\n *     callback. This option is only a temporary stopgap measure to smooth an\n *     API breakage. It is deprecated, and new code should not use it.\n * @return {Object<string, *>} The resulting gRPC object\n */\n\nexports.load = util.deprecate(function load(filename, format, options) {\n  var ProtoBuf = require('protobufjs');\n\n  options = Object.assign({}, common.defaultGrpcOptions, options);\n  options.protobufjsVersion = 5;\n\n  if (!format) {\n    format = 'proto';\n  }\n\n  var convertFieldsToCamelCaseOriginal = ProtoBuf.convertFieldsToCamelCase;\n\n  if (options && options.hasOwnProperty('convertFieldsToCamelCase')) {\n    ProtoBuf.convertFieldsToCamelCase = options.convertFieldsToCamelCase;\n  }\n\n  var builder;\n\n  try {\n    switch (format) {\n      case 'proto':\n        builder = ProtoBuf.loadProtoFile(filename);\n        break;\n\n      case 'json':\n        builder = ProtoBuf.loadJsonFile(filename);\n        break;\n\n      default:\n        throw new Error('Unrecognized format \"' + format + '\"');\n    }\n  } finally {\n    ProtoBuf.convertFieldsToCamelCase = convertFieldsToCamelCaseOriginal;\n  }\n\n  if (!builder) {\n    throw new Error('Could not load file \"' + filename + '\"');\n  }\n\n  return loadObject(builder.ns, options);\n}, 'grpc.load: Use the @grpc/proto-loader module with grpc.loadPackageDefinition instead');\n/**\n * Load a gRPC package definition as a gRPC object hierarchy\n * @param packageDef grpc~PackageDefinition The package definition object\n * @return {Object<string, *>} The resulting gRPC object\n */\n\nexports.loadPackageDefinition = function loadPackageDefintion(packageDef) {\n  var result = {};\n\n  for (var serviceFqn in packageDef) {\n    var service = packageDef[serviceFqn];\n    var nameComponents = serviceFqn.split('.');\n    var serviceName = nameComponents[nameComponents.length - 1];\n    var current = result;\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n    var _iteratorError = undefined;\n\n    try {\n      for (var _iterator = nameComponents.slice(0, -1)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n        var packageName = _step.value;\n\n        if (!current[packageName]) {\n          current[packageName] = {};\n        }\n\n        current = current[packageName];\n      }\n    } catch (err) {\n      _didIteratorError = true;\n      _iteratorError = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion && _iterator.return != null) {\n          _iterator.return();\n        }\n      } finally {\n        if (_didIteratorError) {\n          throw _iteratorError;\n        }\n      }\n    }\n\n    if (service.hasOwnProperty('format')) {\n      current[serviceName] = service;\n    } else {\n      current[serviceName] = client.makeClientConstructor(service, serviceName, {});\n    }\n  }\n\n  return result;\n};\n\nvar log_template = function log_template(args) {\n  var file = args.file;\n  var line = args.line;\n  var severity = args.severity;\n  var message = args.message;\n  var timestamp = args.timestamp;\n  return \"\".concat(severity, \" \").concat(timestamp, \"\\t\").concat(file, \":\").concat(line, \"]\\t\").concat(message);\n};\n/**\n * Sets the logger function for the gRPC module. For debugging purposes, the C\n * core will log synchronously directly to stdout unless this function is\n * called. Note: the output format here is intended to be informational, and\n * is not guaranteed to stay the same in the future.\n * Logs will be directed to logger.error.\n * @memberof grpc\n * @alias grpc.setLogger\n * @param {Console} logger A Console-like object.\n */\n\n\nexports.setLogger = function setLogger(logger) {\n  common.logger = logger;\n  grpc.setDefaultLoggerCallback(function (file, line, severity, message, timestamp) {\n    logger.error(log_template({\n      file: path.basename(file),\n      line: line,\n      severity: severity,\n      message: message,\n      timestamp: timestamp.toISOString()\n    }));\n  });\n};\n/**\n * Sets the logger verbosity for gRPC module logging. The options are members\n * of the grpc.logVerbosity map.\n * @memberof grpc\n * @alias grpc.setLogVerbosity\n * @param {Number} verbosity The minimum severity to log\n */\n\n\nexports.setLogVerbosity = function setLogVerbosity(verbosity) {\n  common.logVerbosity = verbosity;\n  grpc.setLogVerbosity(verbosity);\n};\n\nexports.Server = server.Server;\nexports.Metadata = Metadata;\nexports.status = constants.status;\nexports.propagate = constants.propagate;\nexports.callError = constants.callError;\nexports.writeFlags = constants.writeFlags;\nexports.logVerbosity = constants.logVerbosity;\nexports.methodTypes = constants.methodTypes;\nexports.connectivityState = constants.connectivityState;\nexports.credentials = require('./src/credentials.js');\n/**\n * ServerCredentials factories\n * @constructor ServerCredentials\n * @memberof grpc\n */\n\nexports.ServerCredentials = grpc.ServerCredentials;\n/**\n * Create insecure server credentials\n * @name grpc.ServerCredentials.createInsecure\n * @kind function\n * @return {grpc.ServerCredentials}\n */\n\n/**\n * A private key and certificate pair\n * @typedef {Object} grpc.ServerCredentials~keyCertPair\n * @property {Buffer} private_key The server's private key\n * @property {Buffer} cert_chain The server's certificate chain\n */\n\n/**\n * Create SSL server credentials\n * @name grpc.ServerCredentials.createSsl\n * @kind function\n * @param {?Buffer} rootCerts Root CA certificates for validating client\n *     certificates\n * @param {Array<grpc.ServerCredentials~keyCertPair>} keyCertPairs A list of\n *     private key and certificate chain pairs to be used for authenticating\n *     the server\n * @param {boolean} [checkClientCertificate=false] Indicates that the server\n *     should request and verify the client's certificates\n * @return {grpc.ServerCredentials}\n */\n\nexports.makeGenericClientConstructor = client.makeClientConstructor;\nexports.getClientChannel = client.getClientChannel;\nexports.waitForClientReady = client.waitForClientReady;\nexports.StatusBuilder = client.StatusBuilder;\nexports.ListenerBuilder = client.ListenerBuilder;\nexports.RequesterBuilder = client.RequesterBuilder;\nexports.InterceptingCall = client.InterceptingCall;\n/**\n * @memberof grpc\n * @alias grpc.closeClient\n * @param {grpc.Client} client_obj The client to close\n */\n\nexports.closeClient = function closeClient(client_obj) {\n  client.Client.prototype.close.apply(client_obj);\n};\n\nexports.Client = client.Client;\n/**\n * @typedef {Object.<string, string | number>} grpc~ChannelOptions\n */\n\n/**\n * This constructor API is almost identical to the Client constructor,\n * except that some of the options for the Client constructor are not valid\n * here.\n * @constructor Channel\n * @memberof grpc\n * @param {string} target The address of the server to connect to\n * @param {grpc.ChannelCredentials} credentials Channel credentials to use when connecting\n * @param {grpc~ChannelOptions} options A map of channel options that will be passed to the core\n */\n\nexports.Channel = grpc.Channel;\n/**\n * Close the channel. This has the same functionality as the existing grpc.Client#close\n * @name grpc.Channel#close\n * @kind function\n */\n\n/**\n * Return the target that this channel connects to\n * @name grpc.Channel#getTarget\n * @kind function\n * @return {string} The target\n */\n\n/**\n * Get the channel's current connectivity state.\n * @name grpc.Channel#getConnectivityState\n * @kind function\n * @param {boolean} tryToConnect If true, the channel will start connecting if it is\n *     idle. Otherwise, idle channels will only start connecting when a\n *     call starts.\n * @return {grpc.connectivityState} The current connectivity state\n */\n\n/**\n * @callback grpc.Channel~watchConnectivityStateCallback\n * @param {Error?} error\n */\n\n/**\n * Watch for connectivity state changes.\n * @name grpc.Channel#watchConnectivityState\n * @kind function\n * @param {grpc.ConnectivityState} currentState The state to watch for\n *     transitions from. This should always be populated by calling\n *     getConnectivityState immediately before.\n * @param {grpc~Deadline} deadline A deadline for waiting for a state change\n * @param {grpc.Channel~watchConnectivityStateCallback} callback Called with no\n *     error when the state changes, or with an error if the deadline passes\n *     without a state change\n */\n\n/**\n * @name grpc~Call\n * @kind class\n */\n\n/**\n * Create a call object. Call is an opaque type used by the {@link grpc.Client}\n * and {@link grpc.Server} classes. This function is called by the gRPC library\n * when starting a request. Implementers should return an instance of Call that\n * is returned from calling createCall on an instance of the provided Channel\n * class.\n * @name grpc.Channel#createCall\n * @kind function\n * @param {string} method The full method string to request\n * @param {grpc~Deadline} deadline The call deadline\n * @param {string|null} host A host string override for making the request\n * @param {grpc~Call|null} parentCall A server call to propagate some\n *     information from\n * @param {number|null} propagateFlags A bitwise combination of elements of\n *     {@link grpc.propagate} that indicates what information to propagate\n *     from parentCall\n * @return {grpc~Call}\n */","map":null,"metadata":{},"sourceType":"script"}