{"ast":null,"code":"\"use strict\";\n\nvar _possibleConstructorReturn = require(\"/Users/cvoisin/Repos/actandcaredev/node_modules/@babel/runtime/helpers/possibleConstructorReturn\");\n\nvar _getPrototypeOf = require(\"/Users/cvoisin/Repos/actandcaredev/node_modules/@babel/runtime/helpers/getPrototypeOf\");\n\nvar _inherits = require(\"/Users/cvoisin/Repos/actandcaredev/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _regeneratorRuntime = require(\"/Users/cvoisin/Repos/actandcaredev/node_modules/@babel/runtime/regenerator\");\n\nvar _classCallCheck = require(\"/Users/cvoisin/Repos/actandcaredev/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/cvoisin/Repos/actandcaredev/node_modules/@babel/runtime/helpers/createClass\");\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : new P(function (resolve) {\n        resolve(result.value);\n      }).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar zlib = require(\"zlib\");\n\nvar filter_1 = require(\"./filter\");\n\nvar CompressionHandler =\n/*#__PURE__*/\nfunction () {\n  function CompressionHandler() {\n    _classCallCheck(this, CompressionHandler);\n  }\n\n  _createClass(CompressionHandler, [{\n    key: \"writeMessage\",\n\n    /**\n     * @param message Raw uncompressed message bytes\n     * @param compress Indicates whether the message should be compressed\n     * @return Framed message, compressed if applicable\n     */\n    value: function writeMessage(message, compress) {\n      return __awaiter(this, void 0, void 0,\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee() {\n        var messageBuffer, output;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                messageBuffer = message;\n\n                if (!compress) {\n                  _context.next = 5;\n                  break;\n                }\n\n                _context.next = 4;\n                return this.compressMessage(messageBuffer);\n\n              case 4:\n                messageBuffer = _context.sent;\n\n              case 5:\n                output = Buffer.allocUnsafe(messageBuffer.length + 5);\n                output.writeUInt8(compress ? 1 : 0, 0);\n                output.writeUInt32BE(messageBuffer.length, 1);\n                messageBuffer.copy(output, 5);\n                return _context.abrupt(\"return\", output);\n\n              case 10:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n    }\n    /**\n     * @param data Framed message, possibly compressed\n     * @return Uncompressed message\n     */\n\n  }, {\n    key: \"readMessage\",\n    value: function readMessage(data) {\n      return __awaiter(this, void 0, void 0,\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee2() {\n        var compressed, messageBuffer;\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                compressed = data.readUInt8(0) === 1;\n                messageBuffer = data.slice(5);\n\n                if (!compressed) {\n                  _context2.next = 6;\n                  break;\n                }\n\n                _context2.next = 5;\n                return this.decompressMessage(messageBuffer);\n\n              case 5:\n                messageBuffer = _context2.sent;\n\n              case 6:\n                return _context2.abrupt(\"return\", messageBuffer);\n\n              case 7:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n    }\n  }]);\n\n  return CompressionHandler;\n}();\n\nvar IdentityHandler =\n/*#__PURE__*/\nfunction (_CompressionHandler) {\n  _inherits(IdentityHandler, _CompressionHandler);\n\n  function IdentityHandler() {\n    _classCallCheck(this, IdentityHandler);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(IdentityHandler).apply(this, arguments));\n  }\n\n  _createClass(IdentityHandler, [{\n    key: \"compressMessage\",\n    value: function compressMessage(message) {\n      return __awaiter(this, void 0, void 0,\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee3() {\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                return _context3.abrupt(\"return\", message);\n\n              case 1:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n    }\n  }, {\n    key: \"writeMessage\",\n    value: function writeMessage(message, compress) {\n      return __awaiter(this, void 0, void 0,\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee4() {\n        var output;\n        return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                output = Buffer.allocUnsafe(message.length + 5);\n                /* With \"identity\" compression, messages should always be marked as\n                 * uncompressed */\n\n                output.writeUInt8(0, 0);\n                output.writeUInt32BE(message.length, 1);\n                message.copy(output, 5);\n                return _context4.abrupt(\"return\", output);\n\n              case 5:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this);\n      }));\n    }\n  }, {\n    key: \"decompressMessage\",\n    value: function decompressMessage(message) {\n      return Promise.reject(new Error('Received compressed message but \"grpc-encoding\" header was identity'));\n    }\n  }]);\n\n  return IdentityHandler;\n}(CompressionHandler);\n\nvar DeflateHandler =\n/*#__PURE__*/\nfunction (_CompressionHandler2) {\n  _inherits(DeflateHandler, _CompressionHandler2);\n\n  function DeflateHandler() {\n    _classCallCheck(this, DeflateHandler);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(DeflateHandler).apply(this, arguments));\n  }\n\n  _createClass(DeflateHandler, [{\n    key: \"compressMessage\",\n    value: function compressMessage(message) {\n      return new Promise(function (resolve, reject) {\n        zlib.deflate(message, function (err, output) {\n          if (err) {\n            reject(err);\n          } else {\n            resolve(output);\n          }\n        });\n      });\n    }\n  }, {\n    key: \"decompressMessage\",\n    value: function decompressMessage(message) {\n      return new Promise(function (resolve, reject) {\n        zlib.inflate(message, function (err, output) {\n          if (err) {\n            reject(err);\n          } else {\n            resolve(output);\n          }\n        });\n      });\n    }\n  }]);\n\n  return DeflateHandler;\n}(CompressionHandler);\n\nvar GzipHandler =\n/*#__PURE__*/\nfunction (_CompressionHandler3) {\n  _inherits(GzipHandler, _CompressionHandler3);\n\n  function GzipHandler() {\n    _classCallCheck(this, GzipHandler);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(GzipHandler).apply(this, arguments));\n  }\n\n  _createClass(GzipHandler, [{\n    key: \"compressMessage\",\n    value: function compressMessage(message) {\n      return new Promise(function (resolve, reject) {\n        zlib.gzip(message, function (err, output) {\n          if (err) {\n            reject(err);\n          } else {\n            resolve(output);\n          }\n        });\n      });\n    }\n  }, {\n    key: \"decompressMessage\",\n    value: function decompressMessage(message) {\n      return new Promise(function (resolve, reject) {\n        zlib.unzip(message, function (err, output) {\n          if (err) {\n            reject(err);\n          } else {\n            resolve(output);\n          }\n        });\n      });\n    }\n  }]);\n\n  return GzipHandler;\n}(CompressionHandler);\n\nvar UnknownHandler =\n/*#__PURE__*/\nfunction (_CompressionHandler4) {\n  _inherits(UnknownHandler, _CompressionHandler4);\n\n  function UnknownHandler(compressionName) {\n    var _this;\n\n    _classCallCheck(this, UnknownHandler);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(UnknownHandler).call(this));\n    _this.compressionName = compressionName;\n    return _this;\n  }\n\n  _createClass(UnknownHandler, [{\n    key: \"compressMessage\",\n    value: function compressMessage(message) {\n      return Promise.reject(new Error(\"Received message compressed wth unsupported compression method \".concat(this.compressionName)));\n    }\n  }, {\n    key: \"decompressMessage\",\n    value: function decompressMessage(message) {\n      // This should be unreachable\n      return Promise.reject(new Error(\"Compression method not supported: \".concat(this.compressionName)));\n    }\n  }]);\n\n  return UnknownHandler;\n}(CompressionHandler);\n\nfunction getCompressionHandler(compressionName) {\n  switch (compressionName) {\n    case 'identity':\n      return new IdentityHandler();\n\n    case 'deflate':\n      return new DeflateHandler();\n\n    case 'gzip':\n      return new GzipHandler();\n\n    default:\n      return new UnknownHandler(compressionName);\n  }\n}\n\nvar CompressionFilter =\n/*#__PURE__*/\nfunction (_filter_1$BaseFilter) {\n  _inherits(CompressionFilter, _filter_1$BaseFilter);\n\n  function CompressionFilter() {\n    var _this2;\n\n    _classCallCheck(this, CompressionFilter);\n\n    _this2 = _possibleConstructorReturn(this, _getPrototypeOf(CompressionFilter).apply(this, arguments));\n    _this2.sendCompression = new IdentityHandler();\n    _this2.receiveCompression = new IdentityHandler();\n    return _this2;\n  }\n\n  _createClass(CompressionFilter, [{\n    key: \"sendMetadata\",\n    value: function sendMetadata(metadata) {\n      return __awaiter(this, void 0, void 0,\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee5() {\n        var headers;\n        return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                _context5.next = 2;\n                return metadata;\n\n              case 2:\n                headers = _context5.sent;\n                headers.set('grpc-encoding', 'identity');\n                headers.set('grpc-accept-encoding', 'identity,deflate,gzip');\n                return _context5.abrupt(\"return\", headers);\n\n              case 6:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5, this);\n      }));\n    }\n  }, {\n    key: \"receiveMetadata\",\n    value: function receiveMetadata(metadata) {\n      return __awaiter(this, void 0, void 0,\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee6() {\n        var headers, receiveEncoding, encoding;\n        return _regeneratorRuntime.wrap(function _callee6$(_context6) {\n          while (1) {\n            switch (_context6.prev = _context6.next) {\n              case 0:\n                _context6.next = 2;\n                return metadata;\n\n              case 2:\n                headers = _context6.sent;\n                receiveEncoding = headers.get('grpc-encoding');\n\n                if (receiveEncoding.length > 0) {\n                  encoding = receiveEncoding[0];\n\n                  if (typeof encoding === 'string') {\n                    this.receiveCompression = getCompressionHandler(encoding);\n                  }\n                }\n\n                headers.remove('grpc-encoding');\n                headers.remove('grpc-accept-encoding');\n                return _context6.abrupt(\"return\", headers);\n\n              case 8:\n              case \"end\":\n                return _context6.stop();\n            }\n          }\n        }, _callee6, this);\n      }));\n    }\n  }, {\n    key: \"sendMessage\",\n    value: function sendMessage(message) {\n      return __awaiter(this, void 0, void 0,\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee7() {\n        var resolvedMessage, compress;\n        return _regeneratorRuntime.wrap(function _callee7$(_context7) {\n          while (1) {\n            switch (_context7.prev = _context7.next) {\n              case 0:\n                _context7.next = 2;\n                return message;\n\n              case 2:\n                resolvedMessage = _context7.sent;\n                compress = resolvedMessage.flags === undefined ? false : (resolvedMessage.flags & 2\n                /* NoCompress */\n                ) === 0;\n                _context7.next = 6;\n                return this.sendCompression.writeMessage(resolvedMessage.message, compress);\n\n              case 6:\n                _context7.t0 = _context7.sent;\n                _context7.t1 = resolvedMessage.flags;\n                return _context7.abrupt(\"return\", {\n                  message: _context7.t0,\n                  flags: _context7.t1\n                });\n\n              case 9:\n              case \"end\":\n                return _context7.stop();\n            }\n          }\n        }, _callee7, this);\n      }));\n    }\n  }, {\n    key: \"receiveMessage\",\n    value: function receiveMessage(message) {\n      return __awaiter(this, void 0, void 0,\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee8() {\n        return _regeneratorRuntime.wrap(function _callee8$(_context8) {\n          while (1) {\n            switch (_context8.prev = _context8.next) {\n              case 0:\n                _context8.t0 = this.receiveCompression;\n                _context8.next = 3;\n                return message;\n\n              case 3:\n                _context8.t1 = _context8.sent;\n                return _context8.abrupt(\"return\", _context8.t0.readMessage.call(_context8.t0, _context8.t1));\n\n              case 5:\n              case \"end\":\n                return _context8.stop();\n            }\n          }\n        }, _callee8, this);\n      }));\n    }\n  }]);\n\n  return CompressionFilter;\n}(filter_1.BaseFilter);\n\nexports.CompressionFilter = CompressionFilter;\n\nvar CompressionFilterFactory =\n/*#__PURE__*/\nfunction () {\n  function CompressionFilterFactory(channel) {\n    _classCallCheck(this, CompressionFilterFactory);\n\n    this.channel = channel;\n  }\n\n  _createClass(CompressionFilterFactory, [{\n    key: \"createFilter\",\n    value: function createFilter(callStream) {\n      return new CompressionFilter();\n    }\n  }]);\n\n  return CompressionFilterFactory;\n}();\n\nexports.CompressionFilterFactory = CompressionFilterFactory;","map":null,"metadata":{},"sourceType":"script"}