{"ast":null,"code":"'use strict';\n\nexports.__esModule = true;\n\nvar _getIterator2 = require('babel-runtime/core-js/get-iterator');\n\nvar _getIterator3 = _interopRequireDefault(_getIterator2);\n\nvar _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');\n\nvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n/**\n * A TextDecorationEngine is used by a Typesetter to generate\n * DecorationLines for a line fragment, including underlines\n * and strikes.\n */\n\n\nexports.default = function () {\n  return function (_ref) {\n    var Rect = _ref.Rect,\n        Range = _ref.Range,\n        DecorationLine = _ref.DecorationLine; // The base font size used for calculating underline thickness.\n\n    var BASE_FONT_SIZE = 16;\n    return function () {\n      function TextDecorationEngine() {\n        (0, _classCallCheck3.default)(this, TextDecorationEngine);\n      }\n\n      TextDecorationEngine.prototype.createDecorationLines = function createDecorationLines(lineFragment) {\n        // Create initial underline and strikethrough lines\n        var x = lineFragment.overflowLeft;\n        var maxX = lineFragment.advanceWidth - lineFragment.overflowRight;\n        var underlines = [];\n\n        for (var _iterator = lineFragment.glyphRuns, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : (0, _getIterator3.default)(_iterator);;) {\n          var _ref2;\n\n          if (_isArray) {\n            if (_i >= _iterator.length) break;\n            _ref2 = _iterator[_i++];\n          } else {\n            _i = _iterator.next();\n            if (_i.done) break;\n            _ref2 = _i.value;\n          }\n\n          var run = _ref2;\n          var width = Math.min(maxX - x, run.advanceWidth);\n          var thickness = Math.max(0.5, Math.floor(run.attributes.fontSize / BASE_FONT_SIZE));\n\n          if (run.attributes.underline) {\n            var rect = new Rect(x, lineFragment.ascent, width, thickness);\n\n            var _line = new DecorationLine(rect, run.attributes.underlineColor, run.attributes.underlineStyle);\n\n            this.addDecorationLine(_line, underlines);\n          }\n\n          if (run.attributes.strike) {\n            var y = lineFragment.ascent - run.ascent / 3;\n\n            var _rect = new Rect(x, y, width, thickness);\n\n            var _line2 = new DecorationLine(_rect, run.attributes.strikeColor, run.attributes.strikeStyle);\n\n            this.addDecorationLine(_line2, lineFragment.decorationLines);\n          }\n\n          x += width;\n        } // Adjust underline y positions, and intersect with glyph descenders.\n\n\n        for (var _iterator2 = underlines, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : (0, _getIterator3.default)(_iterator2);;) {\n          var _lineFragment$decorat;\n\n          var _ref3;\n\n          if (_isArray2) {\n            if (_i2 >= _iterator2.length) break;\n            _ref3 = _iterator2[_i2++];\n          } else {\n            _i2 = _iterator2.next();\n            if (_i2.done) break;\n            _ref3 = _i2.value;\n          }\n\n          var line = _ref3;\n          line.rect.y += line.rect.height * 2;\n\n          (_lineFragment$decorat = lineFragment.decorationLines).push.apply(_lineFragment$decorat, this.intersectWithGlyphs(line, lineFragment));\n        }\n      };\n\n      TextDecorationEngine.prototype.addDecorationLine = function addDecorationLine(line, lines) {\n        var last = lines[lines.length - 1];\n\n        if (!last || !last.merge(line)) {\n          lines.push(line);\n        }\n      };\n      /**\n       * Computes the intersections between an underline and the glyphs in\n       * a line fragment. Returns an array of DecorationLines omitting the\n       * intersections.\n       */\n\n\n      TextDecorationEngine.prototype.intersectWithGlyphs = function intersectWithGlyphs(line, lineFragment) {\n        // Find intersection ranges between underline and glyphs\n        var x = 0;\n        var y = lineFragment.ascent;\n        var ranges = [];\n\n        for (var _iterator3 = lineFragment.glyphRuns, _isArray3 = Array.isArray(_iterator3), _i3 = 0, _iterator3 = _isArray3 ? _iterator3 : (0, _getIterator3.default)(_iterator3);;) {\n          var _ref4;\n\n          if (_isArray3) {\n            if (_i3 >= _iterator3.length) break;\n            _ref4 = _iterator3[_i3++];\n          } else {\n            _i3 = _iterator3.next();\n            if (_i3.done) break;\n            _ref4 = _i3.value;\n          }\n\n          var run = _ref4;\n\n          if (!run.attributes.underline) {\n            x += run.advanceWidth;\n            continue;\n          }\n\n          for (var i = 0; i < run.glyphs.length; i++) {\n            var position = run.positions[i];\n\n            if (x >= line.rect.x && x <= line.rect.maxX) {\n              var gx = x + position.xOffset;\n              var gy = y + position.yOffset; // Standard fonts may not have a path to intersect with\n\n              if (run.glyphs[i].path) {\n                var path = run.glyphs[i].path.scale(run.scale, -run.scale).translate(gx, gy);\n                var range = this.findPathIntersections(path, line.rect);\n\n                if (range) {\n                  ranges.push(range);\n                }\n              }\n            }\n\n            x += position.xAdvance;\n            y += position.yAdvance;\n          }\n        }\n\n        if (ranges.length === 0) {\n          // No intersections. Return the original line.\n          return [line];\n        }\n\n        var merged = Range.merge(ranges); // Generate underline segments omitting the intersections,\n        // but only if the space warrents an underline.\n\n        var lines = [];\n        x = line.rect.x;\n\n        for (var _iterator4 = merged, _isArray4 = Array.isArray(_iterator4), _i4 = 0, _iterator4 = _isArray4 ? _iterator4 : (0, _getIterator3.default)(_iterator4);;) {\n          var _ref6;\n\n          if (_isArray4) {\n            if (_i4 >= _iterator4.length) break;\n            _ref6 = _iterator4[_i4++];\n          } else {\n            _i4 = _iterator4.next();\n            if (_i4.done) break;\n            _ref6 = _i4.value;\n          }\n\n          var _ref5 = _ref6;\n          var start = _ref5.start;\n          var end = _ref5.end;\n\n          if (start - x > line.rect.height) {\n            lines.push(line.slice(x, start));\n          }\n\n          x = end;\n        }\n\n        if (line.rect.maxX - x > line.rect.height) {\n          lines.push(line.slice(x, line.rect.maxX));\n        }\n\n        return lines;\n      };\n      /**\n       * Finds the intersections between a glyph path and an underline rectangle.\n       * It models each contour of the path a straight line, and returns a range\n       * containing the leftmost and rightmost intersection points, if any.\n       */\n\n\n      TextDecorationEngine.prototype.findPathIntersections = function findPathIntersections(path, rect) {\n        var sx = 0;\n        var sy = 0;\n        var cx = 0;\n        var cy = 0;\n        var px = 0;\n        var py = 0;\n        var range = new Range(Infinity, -Infinity);\n        var y1 = rect.y;\n        var y2 = rect.maxY;\n        var dialation = Math.ceil(rect.height);\n\n        for (var _iterator5 = path.commands, _isArray5 = Array.isArray(_iterator5), _i5 = 0, _iterator5 = _isArray5 ? _iterator5 : (0, _getIterator3.default)(_iterator5);;) {\n          var _ref8;\n\n          if (_isArray5) {\n            if (_i5 >= _iterator5.length) break;\n            _ref8 = _iterator5[_i5++];\n          } else {\n            _i5 = _iterator5.next();\n            if (_i5.done) break;\n            _ref8 = _i5.value;\n          }\n\n          var _ref7 = _ref8;\n          var command = _ref7.command;\n          var args = _ref7.args;\n\n          switch (command) {\n            case 'moveTo':\n              sx = cx = args[0];\n              sy = cy = args[1];\n              continue;\n\n            case 'lineTo':\n              px = args[0];\n              py = args[1];\n              break;\n\n            case 'quadraticCurveTo':\n              px = args[2];\n              py = args[3];\n              break;\n\n            case 'bezierCurveTo':\n              px = args[4];\n              py = args[5];\n              break;\n\n            case 'closePath':\n              px = sx;\n              py = sy;\n              break;\n\n            default:\n              break;\n          }\n\n          this.findIntersectionPoint(y1, cx, cy, px, py, range);\n          this.findIntersectionPoint(y2, cx, cy, px, py, range);\n\n          if (cy >= y1 && cy <= y2 || cy <= y1 && cy >= y2) {\n            range.extend(cx);\n          }\n\n          cx = px;\n          cy = py;\n        }\n\n        if (range.start < range.end) {\n          range.start -= dialation;\n          range.end += dialation;\n          return range;\n        }\n\n        return null;\n      };\n\n      TextDecorationEngine.prototype.findIntersectionPoint = function findIntersectionPoint(y, x1, y1, x2, y2, range) {\n        if (y1 < y && y2 > y || y1 > y && y2 < y) {\n          var x = x1 + (y - y1) * (x2 - x1) / (y2 - y1);\n          range.extend(x);\n        }\n      };\n\n      return TextDecorationEngine;\n    }();\n  };\n};","map":null,"metadata":{},"sourceType":"script"}