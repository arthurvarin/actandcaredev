{"ast":null,"code":"'use strict';\n\nexports.__esModule = true;\n\nvar _getIterator2 = require('babel-runtime/core-js/get-iterator');\n\nvar _getIterator3 = _interopRequireDefault(_getIterator2);\n\nvar _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');\n\nvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\nvar _Run = require('./Run');\n\nvar _Run2 = _interopRequireDefault(_Run);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nvar AttributedString = function () {\n  function AttributedString() {\n    var string = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n    var runs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n    (0, _classCallCheck3.default)(this, AttributedString);\n    this.string = string;\n    this.runs = runs;\n    this.length = string.length;\n  }\n\n  AttributedString.fromFragments = function fromFragments() {\n    var fragments = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n    var string = '';\n    var offset = 0;\n    var runs = [];\n    fragments.forEach(function (fragment) {\n      string += fragment.string;\n      runs.push(new _Run2.default(offset, offset + fragment.string.length, fragment.attributes));\n      offset += fragment.string.length;\n    });\n    return new AttributedString(string, runs);\n  };\n\n  AttributedString.prototype.runIndexAt = function runIndexAt(index) {\n    for (var i = 0; i < this.runs.length; i++) {\n      if (this.runs[i].start <= index && index < this.runs[i].end) {\n        return i;\n      }\n    }\n\n    return this.runs.length - 1;\n  };\n\n  AttributedString.prototype.trim = function trim() {\n    var i = void 0;\n\n    for (i = this.string.length - 1; i >= 0; i--) {\n      if (this.string[i] !== ' ') {\n        break;\n      }\n    }\n\n    return this.slice(0, i + 1);\n  };\n\n  AttributedString.prototype.slice = function slice(start, end) {\n    if (this.string.length === 0) return this;\n    var startRunIndex = this.runIndexAt(start);\n    var endRunIndex = Math.max(this.runIndexAt(Math.max(end - 1, 0)), startRunIndex);\n    var startRun = this.runs[startRunIndex];\n    var endRun = this.runs[endRunIndex];\n    var runs = [];\n    runs.push(startRun.slice(start - startRun.start, end - startRun.start));\n\n    if (startRunIndex !== endRunIndex) {\n      runs.push.apply(runs, this.runs.slice(startRunIndex + 1, endRunIndex).map(function (r) {\n        return r.copy();\n      }));\n\n      if (endRun.start !== 0) {\n        runs.push(endRun.slice(0, end - endRun.start));\n      }\n    }\n\n    for (var _iterator = runs, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : (0, _getIterator3.default)(_iterator);;) {\n      var _ref;\n\n      if (_isArray) {\n        if (_i >= _iterator.length) break;\n        _ref = _iterator[_i++];\n      } else {\n        _i = _iterator.next();\n        if (_i.done) break;\n        _ref = _i.value;\n      }\n\n      var run = _ref;\n      run.start -= start;\n      run.end -= start;\n    }\n\n    return new AttributedString(this.string.slice(start, end), runs);\n  };\n\n  return AttributedString;\n}();\n\nexports.default = AttributedString;","map":null,"metadata":{},"sourceType":"script"}