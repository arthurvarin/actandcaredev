{"ast":null,"code":"/*! firebase-admin v6.5.0 */\n\"use strict\";\n/*!\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar fs = require(\"fs\");\n\nvar deep_copy_1 = require(\"./utils/deep-copy\");\n\nvar error_1 = require(\"./utils/error\");\n\nvar firebase_app_1 = require(\"./firebase-app\");\n\nvar credential_1 = require(\"./auth/credential\");\n\nvar validator = require(\"./utils/validator\");\n\nvar DEFAULT_APP_NAME = '[DEFAULT]';\n/**\n * Constant holding the environment variable name with the default config.\n * If the environment variable contains a string that starts with '{' it will be parsed as JSON,\n * otherwise it will be assumed to be pointing to a file.\n */\n\nexports.FIREBASE_CONFIG_VAR = 'FIREBASE_CONFIG';\nvar globalAppDefaultCred;\nvar globalCertCreds = {};\nvar globalRefreshTokenCreds = {};\n/**\n * Internals of a FirebaseNamespace instance.\n */\n\nvar FirebaseNamespaceInternals =\n/** @class */\nfunction () {\n  function FirebaseNamespaceInternals(firebase_) {\n    this.firebase_ = firebase_;\n    this.serviceFactories = {};\n    this.apps_ = {};\n    this.appHooks_ = {};\n  }\n  /**\n   * Initializes the FirebaseApp instance.\n   *\n   * @param {FirebaseAppOptions} options Optional options for the FirebaseApp instance. If none present\n   *                             will try to initialize from the FIREBASE_CONFIG environment variable.\n   *                             If the environment variable contains a string that starts with '{'\n   *                             it will be parsed as JSON,\n   *                             otherwise it will be assumed to be pointing to a file.\n   * @param {string} [appName] Optional name of the FirebaseApp instance.\n   *\n   * @return {FirebaseApp} A new FirebaseApp instance.\n   */\n\n\n  FirebaseNamespaceInternals.prototype.initializeApp = function (options, appName) {\n    if (appName === void 0) {\n      appName = DEFAULT_APP_NAME;\n    }\n\n    if (typeof options === 'undefined') {\n      options = this.loadOptionsFromEnvVar();\n      options.credential = new credential_1.ApplicationDefaultCredential();\n    }\n\n    if (typeof appName !== 'string' || appName === '') {\n      throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_APP_NAME, \"Invalid Firebase app name \\\"\" + appName + \"\\\" provided. App name must be a non-empty string.\");\n    } else if (appName in this.apps_) {\n      if (appName === DEFAULT_APP_NAME) {\n        throw new error_1.FirebaseAppError(error_1.AppErrorCodes.DUPLICATE_APP, 'The default Firebase app already exists. This means you called initializeApp() ' + 'more than once without providing an app name as the second argument. In most cases ' + 'you only need to call initializeApp() once. But if you do want to initialize ' + 'multiple apps, pass a second argument to initializeApp() to give each app a unique ' + 'name.');\n      } else {\n        throw new error_1.FirebaseAppError(error_1.AppErrorCodes.DUPLICATE_APP, \"Firebase app named \\\"\" + appName + \"\\\" already exists. This means you called initializeApp() \" + 'more than once with the same app name as the second argument. Make sure you provide a ' + 'unique name every time you call initializeApp().');\n      }\n    }\n\n    var app = new firebase_app_1.FirebaseApp(options, appName, this);\n    this.apps_[appName] = app;\n    this.callAppHooks_(app, 'create');\n    return app;\n  };\n  /**\n   * Returns the FirebaseApp instance with the provided name (or the default FirebaseApp instance\n   * if no name is provided).\n   *\n   * @param {string} [appName=DEFAULT_APP_NAME] Optional name of the FirebaseApp instance to return.\n   * @return {FirebaseApp} The FirebaseApp instance which has the provided name.\n   */\n\n\n  FirebaseNamespaceInternals.prototype.app = function (appName) {\n    if (appName === void 0) {\n      appName = DEFAULT_APP_NAME;\n    }\n\n    if (typeof appName !== 'string' || appName === '') {\n      throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_APP_NAME, \"Invalid Firebase app name \\\"\" + appName + \"\\\" provided. App name must be a non-empty string.\");\n    } else if (!(appName in this.apps_)) {\n      var errorMessage = appName === DEFAULT_APP_NAME ? 'The default Firebase app does not exist. ' : \"Firebase app named \\\"\" + appName + \"\\\" does not exist. \";\n      errorMessage += 'Make sure you call initializeApp() before using any of the Firebase services.';\n      throw new error_1.FirebaseAppError(error_1.AppErrorCodes.NO_APP, errorMessage);\n    }\n\n    return this.apps_[appName];\n  };\n\n  Object.defineProperty(FirebaseNamespaceInternals.prototype, \"apps\", {\n    /*\n     * Returns an array of all the non-deleted FirebaseApp instances.\n     *\n     * @return {Array<FirebaseApp>} An array of all the non-deleted FirebaseApp instances\n     */\n    get: function get() {\n      var _this = this; // Return a copy so the caller cannot mutate the array\n\n\n      return Object.keys(this.apps_).map(function (appName) {\n        return _this.apps_[appName];\n      });\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /*\n   * Removes the specified FirebaseApp instance.\n   *\n   * @param {string} appName The name of the FirebaseApp instance to remove.\n   */\n\n  FirebaseNamespaceInternals.prototype.removeApp = function (appName) {\n    if (typeof appName === 'undefined') {\n      throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_APP_NAME, \"No Firebase app name provided. App name must be a non-empty string.\");\n    }\n\n    var appToRemove = this.app(appName);\n    this.callAppHooks_(appToRemove, 'delete');\n    delete this.apps_[appName];\n  };\n  /*\n   * Registers a new service on this Firebase namespace.\n   *\n   * @param {string} serviceName The name of the Firebase service to register.\n   * @param {FirebaseServiceFactory} createService A factory method to generate an instance of the Firebase service.\n   * @param {object} [serviceProperties] Optional properties to extend this Firebase namespace with.\n   * @param {AppHook} [appHook] Optional callback that handles app-related events like app creation and deletion.\n   * @return {FirebaseServiceNamespace<FirebaseServiceInterface>} The Firebase service's namespace.\n   */\n\n\n  FirebaseNamespaceInternals.prototype.registerService = function (serviceName, createService, serviceProperties, appHook) {\n    var _this = this;\n\n    var errorMessage;\n\n    if (typeof serviceName === 'undefined') {\n      errorMessage = \"No service name provided. Service name must be a non-empty string.\";\n    } else if (typeof serviceName !== 'string' || serviceName === '') {\n      errorMessage = \"Invalid service name \\\"\" + serviceName + \"\\\" provided. Service name must be a non-empty string.\";\n    } else if (serviceName in this.serviceFactories) {\n      errorMessage = \"Firebase service named \\\"\" + serviceName + \"\\\" has already been registered.\";\n    }\n\n    if (typeof errorMessage !== 'undefined') {\n      throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INTERNAL_ERROR, \"INTERNAL ASSERT FAILED: \" + errorMessage);\n    }\n\n    this.serviceFactories[serviceName] = createService;\n\n    if (appHook) {\n      this.appHooks_[serviceName] = appHook;\n    }\n\n    var serviceNamespace; // The service namespace is an accessor function which takes a FirebaseApp instance\n    // or uses the default app if no FirebaseApp instance is provided\n\n    serviceNamespace = function serviceNamespace(appArg) {\n      if (typeof appArg === 'undefined') {\n        appArg = _this.app();\n      } // Forward service instance lookup to the FirebaseApp\n\n\n      return appArg[serviceName]();\n    }; // ... and a container for service-level properties.\n\n\n    if (serviceProperties !== undefined) {\n      deep_copy_1.deepExtend(serviceNamespace, serviceProperties);\n    } // Monkey-patch the service namespace onto the Firebase namespace\n\n\n    this.firebase_[serviceName] = serviceNamespace;\n    return serviceNamespace;\n  };\n  /**\n   * Calls the app hooks corresponding to the provided event name for each service within the\n   * provided FirebaseApp instance.\n   *\n   * @param {FirebaseApp} app The FirebaseApp instance whose app hooks to call.\n   * @param {string} eventName The event name representing which app hooks to call.\n   */\n\n\n  FirebaseNamespaceInternals.prototype.callAppHooks_ = function (app, eventName) {\n    var _this = this;\n\n    Object.keys(this.serviceFactories).forEach(function (serviceName) {\n      if (_this.appHooks_[serviceName]) {\n        _this.appHooks_[serviceName](eventName, app);\n      }\n    });\n  };\n  /**\n   * Parse the file pointed to by the FIREBASE_CONFIG_VAR, if it exists.\n   * Or if the FIREBASE_CONFIG_ENV contains a valid JSON object, parse it directly.\n   * If the environment variable contains a string that starts with '{' it will be parsed as JSON,\n   * otherwise it will be assumed to be pointing to a file.\n   */\n\n\n  FirebaseNamespaceInternals.prototype.loadOptionsFromEnvVar = function () {\n    var config = process.env[exports.FIREBASE_CONFIG_VAR];\n\n    if (!validator.isNonEmptyString(config)) {\n      return {};\n    }\n\n    try {\n      var contents = config.startsWith('{') ? config : fs.readFileSync(config, 'utf8');\n      return JSON.parse(contents);\n    } catch (error) {\n      // Throw a nicely formed error message if the file contents cannot be parsed\n      throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_APP_OPTIONS, 'Failed to parse app options file: ' + error);\n    }\n  };\n\n  return FirebaseNamespaceInternals;\n}();\n\nexports.FirebaseNamespaceInternals = FirebaseNamespaceInternals;\nvar firebaseCredential = {\n  cert: function cert(serviceAccountPathOrObject, httpAgent) {\n    var stringifiedServiceAccount = JSON.stringify(serviceAccountPathOrObject);\n\n    if (!(stringifiedServiceAccount in globalCertCreds)) {\n      globalCertCreds[stringifiedServiceAccount] = new credential_1.CertCredential(serviceAccountPathOrObject, httpAgent);\n    }\n\n    return globalCertCreds[stringifiedServiceAccount];\n  },\n  refreshToken: function refreshToken(refreshTokenPathOrObject, httpAgent) {\n    var stringifiedRefreshToken = JSON.stringify(refreshTokenPathOrObject);\n\n    if (!(stringifiedRefreshToken in globalRefreshTokenCreds)) {\n      globalRefreshTokenCreds[stringifiedRefreshToken] = new credential_1.RefreshTokenCredential(refreshTokenPathOrObject, httpAgent);\n    }\n\n    return globalRefreshTokenCreds[stringifiedRefreshToken];\n  },\n  applicationDefault: function applicationDefault(httpAgent) {\n    if (typeof globalAppDefaultCred === 'undefined') {\n      globalAppDefaultCred = new credential_1.ApplicationDefaultCredential(httpAgent);\n    }\n\n    return globalAppDefaultCred;\n  }\n};\n/**\n * Global Firebase context object.\n */\n\nvar FirebaseNamespace =\n/** @class */\nfunction () {\n  /* tslint:enable */\n  function FirebaseNamespace() {\n    // Hack to prevent Babel from modifying the object returned as the default admin namespace.\n\n    /* tslint:disable:variable-name */\n    this.__esModule = true;\n    /* tslint:enable:variable-name */\n\n    this.credential = firebaseCredential;\n    this.SDK_VERSION = '6.5.0';\n    /* tslint:disable */\n    // TODO(jwenger): Database is the only consumer of firebase.Promise. We should update it to use\n    // use the native Promise and then remove this.\n\n    this.Promise = Promise;\n    this.INTERNAL = new FirebaseNamespaceInternals(this);\n  }\n\n  Object.defineProperty(FirebaseNamespace.prototype, \"auth\", {\n    /**\n     * Gets the `Auth` service namespace. The returned namespace can be used to get the\n     * `Auth` service for the default app or an explicitly specified app.\n     */\n    get: function get() {\n      var _this = this;\n\n      var fn = function fn(app) {\n        return _this.ensureApp(app).auth();\n      };\n\n      var auth = require('./auth/auth').Auth;\n\n      return Object.assign(fn, {\n        Auth: auth\n      });\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(FirebaseNamespace.prototype, \"database\", {\n    /**\n     * Gets the `Database` service namespace. The returned namespace can be used to get the\n     * `Database` service for the default app or an explicitly specified app.\n     */\n    get: function get() {\n      var _this = this;\n\n      var fn = function fn(app) {\n        return _this.ensureApp(app).database();\n      };\n\n      return Object.assign(fn, require('@firebase/database'));\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(FirebaseNamespace.prototype, \"messaging\", {\n    /**\n     * Gets the `Messaging` service namespace. The returned namespace can be used to get the\n     * `Messaging` service for the default app or an explicitly specified app.\n     */\n    get: function get() {\n      var _this = this;\n\n      var fn = function fn(app) {\n        return _this.ensureApp(app).messaging();\n      };\n\n      var messaging = require('./messaging/messaging').Messaging;\n\n      return Object.assign(fn, {\n        Messaging: messaging\n      });\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(FirebaseNamespace.prototype, \"storage\", {\n    /**\n     * Gets the `Storage` service namespace. The returned namespace can be used to get the\n     * `Storage` service for the default app or an explicitly specified app.\n     */\n    get: function get() {\n      var _this = this;\n\n      var fn = function fn(app) {\n        return _this.ensureApp(app).storage();\n      };\n\n      var storage = require('./storage/storage').Storage;\n\n      return Object.assign(fn, {\n        Storage: storage\n      });\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(FirebaseNamespace.prototype, \"firestore\", {\n    /**\n     * Gets the `Firestore` service namespace. The returned namespace can be used to get the\n     * `Firestore` service for the default app or an explicitly specified app.\n     */\n    get: function get() {\n      var _this = this;\n\n      var fn = function fn(app) {\n        return _this.ensureApp(app).firestore();\n      };\n\n      return Object.assign(fn, require('@google-cloud/firestore'));\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(FirebaseNamespace.prototype, \"instanceId\", {\n    /**\n     * Gets the `InstanceId` service namespace. The returned namespace can be used to get the\n     * `Instance` service for the default app or an explicitly specified app.\n     */\n    get: function get() {\n      var _this = this;\n\n      var fn = function fn(app) {\n        return _this.ensureApp(app).instanceId();\n      };\n\n      var instanceId = require('./instance-id/instance-id').InstanceId;\n\n      return Object.assign(fn, {\n        InstanceId: instanceId\n      });\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(FirebaseNamespace.prototype, \"projectManagement\", {\n    /**\n     * Gets the `ProjectManagement` service namespace. The returned namespace can be used to get the\n     * `ProjectManagement` service for the default app or an explicitly specified app.\n     */\n    get: function get() {\n      var _this = this;\n\n      var fn = function fn(app) {\n        return _this.ensureApp(app).projectManagement();\n      };\n\n      var projectManagement = require('./project-management/project-management').ProjectManagement;\n\n      return Object.assign(fn, {\n        ProjectManagement: projectManagement\n      });\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\n   * Initializes the FirebaseApp instance.\n   *\n   * @param {FirebaseAppOptions} [options] Optional options for the FirebaseApp instance.\n   *   If none present will try to initialize from the FIREBASE_CONFIG environment variable.\n   *   If the environment variable contains a string that starts with '{' it will be parsed as JSON,\n   *   otherwise it will be assumed to be pointing to a file.\n   * @param {string} [appName] Optional name of the FirebaseApp instance.\n   *\n   * @return {FirebaseApp} A new FirebaseApp instance.\n   */\n\n  FirebaseNamespace.prototype.initializeApp = function (options, appName) {\n    return this.INTERNAL.initializeApp(options, appName);\n  };\n  /**\n   * Returns the FirebaseApp instance with the provided name (or the default FirebaseApp instance\n   * if no name is provided).\n   *\n   * @param {string} [appName] Optional name of the FirebaseApp instance to return.\n   * @return {FirebaseApp} The FirebaseApp instance which has the provided name.\n   */\n\n\n  FirebaseNamespace.prototype.app = function (appName) {\n    return this.INTERNAL.app(appName);\n  };\n\n  Object.defineProperty(FirebaseNamespace.prototype, \"apps\", {\n    /*\n     * Returns an array of all the non-deleted FirebaseApp instances.\n     *\n     * @return {Array<FirebaseApp>} An array of all the non-deleted FirebaseApp instances\n     */\n    get: function get() {\n      return this.INTERNAL.apps;\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  FirebaseNamespace.prototype.ensureApp = function (app) {\n    if (typeof app === 'undefined') {\n      app = this.app();\n    }\n\n    return app;\n  };\n\n  return FirebaseNamespace;\n}();\n\nexports.FirebaseNamespace = FirebaseNamespace;","map":null,"metadata":{},"sourceType":"script"}