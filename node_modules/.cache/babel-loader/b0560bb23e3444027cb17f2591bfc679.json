{"ast":null,"code":"\"use strict\";\n/*\n * Copyright 2016, Google Inc.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are\n * met:\n *\n *     * Redistributions of source code must retain the above copyright\n * notice, this list of conditions and the following disclaimer.\n *     * Redistributions in binary form must reproduce the above\n * copyright notice, this list of conditions and the following disclaimer\n * in the documentation and/or other materials provided with the\n * distribution.\n *     * Neither the name of Google Inc. nor the names of its\n * contributors may be used to endorse or promote products derived from\n * this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\nvar _possibleConstructorReturn = require(\"/Users/cvoisin/Repos/actandcaredev/node_modules/@babel/runtime/helpers/possibleConstructorReturn\");\n\nvar _getPrototypeOf = require(\"/Users/cvoisin/Repos/actandcaredev/node_modules/@babel/runtime/helpers/getPrototypeOf\");\n\nvar _inherits = require(\"/Users/cvoisin/Repos/actandcaredev/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _classCallCheck = require(\"/Users/cvoisin/Repos/actandcaredev/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/cvoisin/Repos/actandcaredev/node_modules/@babel/runtime/helpers/createClass\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar Canceller =\n/*#__PURE__*/\nfunction () {\n  /**\n   * Canceller manages callback, API calls, and cancellation\n   * of the API calls.\n   * @param {APICallback=} callback\n   *   The callback to be called asynchronously when the API call\n   *   finishes.\n   * @constructor\n   * @property {APICallback} callback\n   *   The callback function to be called.\n   * @private\n   */\n  function Canceller(callback) {\n    _classCallCheck(this, Canceller);\n\n    this.callback = callback;\n    this.completed = false;\n  }\n  /**\n   * Cancels the ongoing promise.\n   */\n\n\n  _createClass(Canceller, [{\n    key: \"cancel\",\n    value: function cancel() {\n      if (this.completed) {\n        return;\n      }\n\n      this.completed = true;\n\n      if (this.cancelFunc) {\n        this.cancelFunc();\n      } else {\n        this.callback(new Error('cancelled'));\n      }\n    }\n    /**\n     * Call calls the specified function. Result will be used to fulfill\n     * the promise.\n     *\n     * @param {function(Object, APICallback=)} aFunc\n     *   A function for an API call.\n     * @param {Object} argument\n     *   A request object.\n     */\n\n  }, {\n    key: \"call\",\n    value: function call(aFunc, argument) {\n      var _this = this;\n\n      if (this.completed) {\n        return;\n      } // tslint:disable-next-line no-any\n\n\n      var canceller = aFunc(argument, function () {\n        _this.completed = true;\n\n        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n          args[_key] = arguments[_key];\n        }\n\n        args.unshift(_this.callback);\n        setImmediate.apply(null, args);\n      });\n\n      this.cancelFunc = function () {\n        canceller.cancel();\n      };\n    }\n  }]);\n\n  return Canceller;\n}();\n\nexports.Canceller = Canceller; // tslint:disable-next-line no-any\n\nvar PromiseCanceller =\n/*#__PURE__*/\nfunction (_Canceller) {\n  _inherits(PromiseCanceller, _Canceller);\n\n  /**\n   * PromiseCanceller is Canceller, but it holds a promise when\n   * the API call finishes.\n   * @param {Function} PromiseCtor - A constructor for a promise that implements\n   * the ES6 specification of promise.\n   * @constructor\n   * @private\n   */\n  // tslint:disable-next-line variable-name\n  function PromiseCanceller(PromiseCtor) {\n    var _this2;\n\n    _classCallCheck(this, PromiseCanceller);\n\n    _this2 = _possibleConstructorReturn(this, _getPrototypeOf(PromiseCanceller).call(this));\n    _this2.promise = new PromiseCtor(function (resolve, reject) {\n      _this2.callback = function (err, response, next, rawResponse) {\n        if (err) {\n          reject(err);\n        } else {\n          resolve([response, next, rawResponse]);\n        }\n      };\n    });\n\n    _this2.promise.cancel = function () {\n      _this2.cancel();\n    };\n\n    return _this2;\n  }\n\n  return PromiseCanceller;\n}(Canceller);\n\nexports.PromiseCanceller = PromiseCanceller;\n/**\n * Updates aFunc so that it gets called with the timeout as its final arg.\n *\n * This converts a function, aFunc, into another function with updated deadline.\n *\n * @private\n *\n * @param {APIFunc} aFunc - a function to be updated.\n * @param {number} timeout - to be added to the original function as it final\n *   positional arg.\n * @param {Object} otherArgs - the additional arguments to be passed to aFunc.\n * @param {Object=} abTests - the A/B testing key/value pairs.\n * @return {function(Object, APICallback)}\n *  the function with other arguments and the timeout.\n */\n\nfunction addTimeoutArg(aFunc, timeout, otherArgs, abTests) {\n  // TODO: this assumes the other arguments consist of metadata and options,\n  // which is specific to gRPC calls. Remove the hidden dependency on gRPC.\n  return function timeoutFunc(argument, callback) {\n    var now = new Date();\n    var options = otherArgs.options || {};\n    options.deadline = new Date(now.getTime() + timeout);\n    var metadata = otherArgs.metadataBuilder ? otherArgs.metadataBuilder(abTests, otherArgs.headers || {}) : null;\n    return aFunc(argument, metadata, options, callback);\n  };\n}\n/**\n * Creates a function equivalent to aFunc, but that retries on certain\n * exceptions.\n *\n * @private\n *\n * @param {APIFunc} aFunc - A function.\n * @param {RetryOptions} retry - Configures the exceptions upon which the\n *   function eshould retry, and the parameters to the exponential backoff retry\n *   algorithm.\n * @param {Object} otherArgs - the additional arguments to be passed to aFunc.\n * @return {function(Object, APICallback)} A function that will retry.\n */\n\n\nfunction retryable(aFunc, retry, otherArgs) {\n  var delayMult = retry.backoffSettings.retryDelayMultiplier;\n  var maxDelay = retry.backoffSettings.maxRetryDelayMillis;\n  var timeoutMult = retry.backoffSettings.rpcTimeoutMultiplier;\n  var maxTimeout = retry.backoffSettings.maxRpcTimeoutMillis;\n  var delay = retry.backoffSettings.initialRetryDelayMillis;\n  var timeout = retry.backoffSettings.initialRpcTimeoutMillis;\n  /**\n   * Equivalent to ``aFunc``, but retries upon transient failure.\n   *\n   * Retrying is done through an exponential backoff algorithm configured\n   * by the options in ``retry``.\n   * @param {Object} argument The request object.\n   * @param {APICallback} callback The callback.\n   * @return {function()} cancel function.\n   */\n\n  return function retryingFunc(argument, callback) {\n    var canceller;\n    var timeoutId;\n    var now = new Date();\n    var deadline;\n\n    if (retry.backoffSettings.totalTimeoutMillis) {\n      deadline = now.getTime() + retry.backoffSettings.totalTimeoutMillis;\n    }\n\n    var retries = 0;\n    var maxRetries = retry.backoffSettings.maxRetries; // TODO: define A/B testing values for retry behaviors.\n\n    /** Repeat the API call as long as necessary. */\n\n    function repeat() {\n      timeoutId = null;\n\n      if (deadline && now.getTime() >= deadline) {\n        callback(new Error('Retry total timeout exceeded before any ' + 'response was received'));\n        return;\n      }\n\n      if (retries && retries >= maxRetries) {\n        callback(new Error('Exceeded maximum number of retries before any ' + 'response was received'));\n        return;\n      }\n\n      retries++;\n      var toCall = addTimeoutArg(aFunc, timeout, otherArgs);\n      canceller = toCall(argument, function (err, response, next, rawResponse) {\n        if (!err) {\n          callback(null, response, next, rawResponse);\n          return;\n        }\n\n        canceller = null;\n\n        if (retry.retryCodes.indexOf(err.code) < 0) {\n          err.note = 'Exception occurred in retry method that was ' + 'not classified as transient';\n          callback(err);\n        } else {\n          var toSleep = Math.random() * delay;\n          timeoutId = setTimeout(function () {\n            now = new Date();\n            delay = Math.min(delay * delayMult, maxDelay);\n            timeout = Math.min(timeout * timeoutMult, maxTimeout, deadline - now.getTime());\n            repeat();\n          }, toSleep);\n        }\n      });\n    }\n\n    if (maxRetries && deadline) {\n      callback(new Error('Cannot set both totalTimeoutMillis and maxRetries ' + 'in backoffSettings.'));\n    } else {\n      repeat();\n    }\n\n    return {\n      cancel: function cancel() {\n        if (timeoutId) {\n          clearTimeout(timeoutId);\n        }\n\n        if (canceller) {\n          canceller.cancel();\n        } else {\n          callback(new Error('cancelled'));\n        }\n      }\n    };\n  };\n}\n/**\n * Creates an API caller for normal methods.\n *\n * @private\n * @constructor\n */\n\n\nvar NormalApiCaller =\n/*#__PURE__*/\nfunction () {\n  function NormalApiCaller() {\n    _classCallCheck(this, NormalApiCaller);\n  }\n\n  _createClass(NormalApiCaller, [{\n    key: \"init\",\n    value: function init(settings, callback) {\n      if (callback) {\n        return new Canceller(callback);\n      }\n\n      return new PromiseCanceller(settings.promise);\n    }\n  }, {\n    key: \"wrap\",\n    value: function wrap(func) {\n      return func;\n    }\n  }, {\n    key: \"call\",\n    value: function call(apiCall, argument, settings, canceller) {\n      canceller.call(apiCall, argument);\n    }\n  }, {\n    key: \"fail\",\n    value: function fail(canceller, err) {\n      canceller.callback(err);\n    }\n  }, {\n    key: \"result\",\n    value: function result(canceller) {\n      if (canceller.promise) {\n        return canceller.promise;\n      }\n\n      return;\n    }\n  }]);\n\n  return NormalApiCaller;\n}();\n\nexports.NormalApiCaller = NormalApiCaller;\n/**\n * Converts an rpc call into an API call governed by the settings.\n *\n * In typical usage, `func` will be a promsie to a callable used to make an rpc\n * request. This will mostly likely be a bound method from a request stub used\n * to make an rpc call. It is not a direct function but a Promise instance,\n * because of its asynchronism (typically, obtaining the auth information).\n *\n * The result is a function which manages the API call with the given settings\n * and the options on the invocation.\n *\n * @param {Promise.<APIFunc>} funcWithAuth - is a promise to be used to make\n *   a bare rpc call. This is a Promise instead of a bare function because\n *   the rpc call will be involeved with asynchronous authentications.\n * @param {CallSettings} settings - provides the settings for this call\n * @param {Object=} optDescriptor - optionally specify the descriptor for\n *   the method call.\n * @return {APICall} func - a bound method on a request stub used\n *   to make an rpc call.\n */\n\nfunction createApiCall(funcWithAuth, settings, // tslint:disable-next-line no-any\noptDescriptor) {\n  var apiCaller = optDescriptor ? optDescriptor.apiCaller(settings) : new NormalApiCaller();\n  return function apiCallInner(request, callOptions, callback) {\n    var thisSettings = settings.merge(callOptions);\n    var status = apiCaller.init(thisSettings, callback);\n    funcWithAuth.then(function (func) {\n      func = apiCaller.wrap(func);\n      var retry = thisSettings.retry;\n\n      if (retry && retry.retryCodes && retry.retryCodes.length > 0) {\n        return retryable(func, thisSettings.retry, thisSettings.otherArgs);\n      }\n\n      return addTimeoutArg(func, thisSettings.timeout, thisSettings.otherArgs);\n    }).then(function (apiCall) {\n      apiCaller.call(apiCall, request, thisSettings, status);\n    }).catch(function (err) {\n      apiCaller.fail(status, err);\n    });\n    return apiCaller.result(status);\n  };\n}\n\nexports.createApiCall = createApiCall;","map":null,"metadata":{},"sourceType":"script"}