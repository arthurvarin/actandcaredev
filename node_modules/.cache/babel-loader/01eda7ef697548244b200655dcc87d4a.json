{"ast":null,"code":"'use strict';\n\nexports.__esModule = true;\n\nvar _regenerator = require('babel-runtime/regenerator');\n\nvar _regenerator2 = _interopRequireDefault(_regenerator);\n\nvar _iterator6 = require('babel-runtime/core-js/symbol/iterator');\n\nvar _iterator7 = _interopRequireDefault(_iterator6);\n\nvar _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');\n\nvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\nvar _createClass2 = require('babel-runtime/helpers/createClass');\n\nvar _createClass3 = _interopRequireDefault(_createClass2);\n\nvar _getIterator2 = require('babel-runtime/core-js/get-iterator');\n\nvar _getIterator3 = _interopRequireDefault(_getIterator2);\n\nvar _set = require('babel-runtime/core-js/set');\n\nvar _set2 = _interopRequireDefault(_set);\n\nvar _unicodeProperties = require('@react-pdf/unicode-properties');\n\nvar _unicodeProperties2 = _interopRequireDefault(_unicodeProperties);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n} // https://www.w3.org/TR/css-text-3/#hanging-punctuation\n\n\nvar HANGING_PUNCTUATION_START_CATEGORIES = new _set2.default(['Ps', 'Pi', 'Pf']);\nvar HANGING_PUNCTUATION_END_CATEGORIES = new _set2.default(['Pe', 'Pi', 'Pf']);\nvar HANGING_PUNCTUATION_END_CODEPOINTS = new _set2.default([0x002c, // COMMA\n0x002e, // FULL STOP\n0x060c, // ARABIC COMMA\n0x06d4, // ARABIC FULL STOP\n0x3001, // IDEOGRAPHIC COMMA\n0x3002, // IDEOGRAPHIC FULL STOP\n0xff0c, // FULLWIDTH COMMA\n0xff0e, // FULLWIDTH FULL STOP\n0xfe50, // SMALL COMMA\n0xfe51, // SMALL IDEOGRAPHIC COMMA\n0xfe52, // SMALL FULL STOP\n0xff61, // HALFWIDTH IDEOGRAPHIC FULL STOP\n0xff64, // HALFWIDTH IDEOGRAPHIC COMMA\n0x002d // HYPHEN\n]);\n\nvar _runIndexAtGlyphIndex = function _runIndexAtGlyphIndex(glyphRuns, index) {\n  var count = 0;\n\n  for (var i = 0; i < glyphRuns.length; i++) {\n    var run = glyphRuns[i];\n\n    if (count <= index && index < count + run.glyphs.length) {\n      return i;\n    }\n\n    count += run.glyphs.length;\n  }\n\n  return glyphRuns.length - 1;\n};\n\nvar sliceRuns = function sliceRuns(glyphRuns, start, end) {\n  if (glyphRuns.length === 0) return [];\n\n  var startRunIndex = _runIndexAtGlyphIndex(glyphRuns, start);\n\n  var endRunIndex = _runIndexAtGlyphIndex(glyphRuns, end);\n\n  var startRun = glyphRuns[startRunIndex];\n  var endRun = glyphRuns[endRunIndex];\n  var runs = [];\n  runs.push(startRun.slice(start - startRun.start, end - startRun.start));\n\n  if (endRunIndex !== startRunIndex) {\n    runs.push.apply(runs, glyphRuns.slice(startRunIndex + 1, endRunIndex));\n\n    if (end - endRun.start !== 0) {\n      runs.push(endRun.slice(0, end - endRun.start));\n    }\n  }\n\n  for (var _iterator = runs, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : (0, _getIterator3.default)(_iterator);;) {\n    var _ref;\n\n    if (_isArray) {\n      if (_i >= _iterator.length) break;\n      _ref = _iterator[_i++];\n    } else {\n      _i = _iterator.next();\n      if (_i.done) break;\n      _ref = _i.value;\n    }\n\n    var run = _ref;\n    run.start -= start;\n    run.end -= start;\n    run.stringIndices = run.stringIndices.map(function (s) {\n      return s - start;\n    });\n  }\n\n  return runs;\n};\n\nvar normalizeStringIndices = function normalizeStringIndices(glyphRuns) {\n  glyphRuns.forEach(function (run) {\n    run.stringIndices = run.stringIndices.map(function (index) {\n      return index - run.stringIndices[0];\n    });\n  });\n  return glyphRuns;\n};\n\nvar GlyphString = function () {\n  function GlyphString(string) {\n    var glyphRuns = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n    (0, _classCallCheck3.default)(this, GlyphString);\n    this.string = string;\n    this.glyphRuns = normalizeStringIndices(glyphRuns);\n  }\n\n  GlyphString.prototype.slice = function slice(start, end) {\n    var stringStart = this.stringIndexForGlyphIndex(start);\n    var stringEnd = this.stringIndexForGlyphIndex(end);\n    var glyphRuns = sliceRuns(this.glyphRuns, start, end);\n    var result = new GlyphString(this.string.slice(stringStart, stringEnd), glyphRuns); // Ligature splitting. If happens to slice in a ligature, we split create\n\n    var previousGlyph = this.glyphAtIndex(start - 1);\n    var lastGlyph = this.glyphAtIndex(end - 1);\n\n    if (lastGlyph && lastGlyph.isLigature) {\n      result.deleteGlyph(result.length - 1);\n      result.insertGlyph(result.length, lastGlyph.codePoints[0]);\n    } // Add the ligature remaining chars to result\n\n\n    if (previousGlyph && previousGlyph.isLigature) {\n      for (var i = 1; i < previousGlyph.codePoints.length; i++) {\n        result.insertGlyph(i - 1, previousGlyph.codePoints[i]);\n      }\n    }\n\n    return result;\n  };\n\n  GlyphString.prototype.runIndexAtGlyphIndex = function runIndexAtGlyphIndex(index) {\n    return _runIndexAtGlyphIndex(this.glyphRuns, index);\n  };\n\n  GlyphString.prototype.runAtGlyphIndex = function runAtGlyphIndex(index) {\n    for (var i = 0; i < this.glyphRuns.length; i++) {\n      var run = this.glyphRuns[i];\n\n      if (run.start <= index && run.end > index) {\n        return run;\n      }\n    }\n\n    return this.glyphRuns[this.glyphRuns.length - 1];\n  };\n\n  GlyphString.prototype.runIndexAtStringIndex = function runIndexAtStringIndex(index) {\n    var offset = 0;\n\n    for (var i = 0; i < this.glyphRuns.length; i++) {\n      var run = this.glyphRuns[i];\n\n      if (offset + run.stringStart <= index && offset + run.stringEnd >= index) {\n        return i;\n      }\n\n      offset += run.stringEnd;\n    }\n\n    return this.glyphRuns.length - 1;\n  };\n\n  GlyphString.prototype.runAtStringIndex = function runAtStringIndex(index) {\n    return this.glyphRuns[this.runIndexAtStringIndex(index)];\n  };\n\n  GlyphString.prototype.glyphAtIndex = function glyphAtIndex(index) {\n    var run = this.runAtGlyphIndex(index);\n    return run.glyphs[this.start + index - run.start];\n  };\n\n  GlyphString.prototype.positionAtIndex = function positionAtIndex(index) {\n    var run = void 0;\n    var count = 0;\n\n    for (var i = 0; i < this.glyphRuns.length; i++) {\n      run = this.glyphRuns[i];\n\n      if (count <= index && index < count + run.positions.length) {\n        return run.positions[index - count];\n      }\n\n      count += run.positions.length;\n    }\n\n    return run.positions[run.positions.length - 1];\n  };\n\n  GlyphString.prototype.getGlyphWidth = function getGlyphWidth(index) {\n    return this.positionAtIndex(index).xAdvance;\n  };\n\n  GlyphString.prototype.glyphIndexAtOffset = function glyphIndexAtOffset(width) {\n    var offset = 0;\n    var index = 0;\n\n    for (var _iterator2 = this.glyphRuns, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : (0, _getIterator3.default)(_iterator2);;) {\n      var _ref2;\n\n      if (_isArray2) {\n        if (_i2 >= _iterator2.length) break;\n        _ref2 = _iterator2[_i2++];\n      } else {\n        _i2 = _iterator2.next();\n        if (_i2.done) break;\n        _ref2 = _i2.value;\n      }\n\n      var run = _ref2;\n\n      if (offset + run.advanceWidth > width) {\n        for (var _iterator3 = run.positions, _isArray3 = Array.isArray(_iterator3), _i3 = 0, _iterator3 = _isArray3 ? _iterator3 : (0, _getIterator3.default)(_iterator3);;) {\n          var _ref3;\n\n          if (_isArray3) {\n            if (_i3 >= _iterator3.length) break;\n            _ref3 = _iterator3[_i3++];\n          } else {\n            _i3 = _iterator3.next();\n            if (_i3.done) break;\n            _ref3 = _i3.value;\n          }\n\n          var position = _ref3;\n          var w = position.xAdvance;\n\n          if (offset + w > width) {\n            return index;\n          }\n\n          offset += w;\n          index++;\n        }\n      } else {\n        offset += run.advanceWidth;\n        index += run.glyphs.length;\n      }\n    }\n\n    return index;\n  };\n\n  GlyphString.prototype.stringIndexForGlyphIndex = function stringIndexForGlyphIndex(index) {\n    var count = 0;\n    var offset = 0;\n\n    for (var i = 0; i < this.glyphRuns.length; i++) {\n      var run = this.glyphRuns[i];\n\n      if (offset <= index && offset + run.length > index) {\n        return count + run.stringIndices[index - run.start];\n      }\n\n      offset += run.length;\n      count += run.glyphIndices.length;\n    }\n\n    return count;\n  };\n\n  GlyphString.prototype.glyphIndexForStringIndex = function glyphIndexForStringIndex(index) {\n    var run = void 0;\n    var count = 0;\n    var offset = 0;\n\n    for (var i = 0; i < this.glyphRuns.length; i++) {\n      run = this.glyphRuns[i];\n\n      if (offset <= index && index < offset + run.stringEnd + 1) {\n        return count + run.glyphIndices[index - offset];\n      }\n\n      count += run.glyphs.length;\n      offset += run.stringEnd + 1;\n    }\n\n    return offset;\n  };\n\n  GlyphString.prototype.codePointAtGlyphIndex = function codePointAtGlyphIndex(glyphIndex) {\n    return this.string.codePointAt(this.stringIndexForGlyphIndex(glyphIndex));\n  };\n\n  GlyphString.prototype.charAtGlyphIndex = function charAtGlyphIndex(glyphIndex) {\n    return this.string.charAt(this.stringIndexForGlyphIndex(glyphIndex));\n  };\n\n  GlyphString.prototype.offsetAtGlyphIndex = function offsetAtGlyphIndex(glyphIndex) {\n    var offset = 0;\n    var count = glyphIndex;\n\n    for (var _iterator4 = this.glyphRuns, _isArray4 = Array.isArray(_iterator4), _i4 = 0, _iterator4 = _isArray4 ? _iterator4 : (0, _getIterator3.default)(_iterator4);;) {\n      var _ref4;\n\n      if (_isArray4) {\n        if (_i4 >= _iterator4.length) break;\n        _ref4 = _iterator4[_i4++];\n      } else {\n        _i4 = _iterator4.next();\n        if (_i4.done) break;\n        _ref4 = _i4.value;\n      }\n\n      var run = _ref4;\n\n      for (var i = 0; i < run.glyphs.length; i++) {\n        if (count === 0) {\n          return offset;\n        }\n\n        offset += run.positions[i].xAdvance;\n        count -= 1;\n      }\n    }\n\n    return offset;\n  };\n\n  GlyphString.prototype.indexOf = function indexOf(string) {\n    var index = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    var stringIndex = this.stringIndexForGlyphIndex(index);\n    var nextIndex = this.string.indexOf(string, stringIndex);\n    if (nextIndex === -1) return -1;\n    return this.glyphIndexForStringIndex(nextIndex);\n  };\n\n  GlyphString.prototype.getUnicodeCategory = function getUnicodeCategory(index) {\n    var codePoint = this.codePointAtGlyphIndex(index);\n    return codePoint ? _unicodeProperties2.default.getCategory(codePoint) : null;\n  };\n\n  GlyphString.prototype.isWhiteSpace = function isWhiteSpace(index) {\n    var codePoint = this.codePointAtGlyphIndex(index);\n    return codePoint ? _unicodeProperties2.default.isWhiteSpace(codePoint) : false;\n  };\n\n  GlyphString.prototype.isHangingPunctuationStart = function isHangingPunctuationStart(index) {\n    return HANGING_PUNCTUATION_START_CATEGORIES.has(this.getUnicodeCategory(index));\n  };\n\n  GlyphString.prototype.isHangingPunctuationEnd = function isHangingPunctuationEnd(index) {\n    return HANGING_PUNCTUATION_END_CATEGORIES.has(this.getUnicodeCategory(index)) || HANGING_PUNCTUATION_END_CODEPOINTS.has(this.codePointAtGlyphIndex(index));\n  };\n\n  GlyphString.prototype.insertGlyph = function insertGlyph(index, codePoint) {\n    var runIndex = this.runIndexAtGlyphIndex(index);\n    var run = this.glyphRuns[runIndex];\n    var _run$attributes = run.attributes,\n        font = _run$attributes.font,\n        fontSize = _run$attributes.fontSize;\n    var glyph = run.attributes.font.glyphForCodePoint(codePoint);\n    var scale = fontSize / font.unitsPerEm;\n    var glyphIndex = this.start + index - run.start;\n    if (this._end) this._end += 1;\n    run.glyphs.splice(glyphIndex, 0, glyph);\n    run.stringIndices.splice(glyphIndex, 0, run.stringIndices[glyphIndex]);\n\n    for (var i = 0; i < run.glyphIndices.length; i++) {\n      if (run.glyphIndices[i] >= glyphIndex) {\n        run.glyphIndices[i] += 1;\n      }\n    }\n\n    run.positions.splice(glyphIndex, 0, {\n      xAdvance: glyph.advanceWidth * scale,\n      yAdvance: 0,\n      xOffset: 0,\n      yOffset: run.attributes.yOffset * font.unitsPerEm\n    });\n    run.end += 1;\n\n    for (var _i5 = runIndex + 1; _i5 < this.glyphRuns.length; _i5++) {\n      this.glyphRuns[_i5].start += 1;\n      this.glyphRuns[_i5].end += 1;\n    }\n\n    this.glyphRunsCache = null;\n  };\n\n  GlyphString.prototype.deleteGlyph = function deleteGlyph(index) {\n    if (index < 0 || index >= this.length) return;\n    var runIndex = this.runIndexAtGlyphIndex(index);\n    var run = this.glyphRuns[runIndex];\n    var glyphIndex = this.start + index - run.start;\n    if (this._end) this._end -= 1;\n    run.glyphs.splice(glyphIndex, 1);\n    run.positions.splice(glyphIndex, 1);\n    run.stringIndices.splice(glyphIndex, 1);\n\n    for (var i = 0; i < run.glyphIndices.length; i++) {\n      if (run.glyphIndices[i] >= glyphIndex) {\n        run.glyphIndices[i] -= 1;\n      }\n    }\n\n    run.end--;\n\n    for (var _i6 = runIndex + 1; _i6 < this.glyphRuns.length; _i6++) {\n      this.glyphRuns[_i6].start--;\n      this.glyphRuns[_i6].end--;\n    }\n\n    this.glyphRunsCache = null;\n  };\n\n  GlyphString.prototype[_iterator7.default] =\n  /*#__PURE__*/\n  _regenerator2.default.mark(function _callee() {\n    var x, _iterator5, _isArray5, _i7, _ref5, run, i;\n\n    return _regenerator2.default.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            x = 0;\n            _iterator5 = this.glyphRuns, _isArray5 = Array.isArray(_iterator5), _i7 = 0, _iterator5 = _isArray5 ? _iterator5 : (0, _getIterator3.default)(_iterator5);\n\n          case 2:\n            if (!_isArray5) {\n              _context.next = 8;\n              break;\n            }\n\n            if (!(_i7 >= _iterator5.length)) {\n              _context.next = 5;\n              break;\n            }\n\n            return _context.abrupt('break', 23);\n\n          case 5:\n            _ref5 = _iterator5[_i7++];\n            _context.next = 12;\n            break;\n\n          case 8:\n            _i7 = _iterator5.next();\n\n            if (!_i7.done) {\n              _context.next = 11;\n              break;\n            }\n\n            return _context.abrupt('break', 23);\n\n          case 11:\n            _ref5 = _i7.value;\n\n          case 12:\n            run = _ref5;\n            i = 0;\n\n          case 14:\n            if (!(i < run.glyphs.length)) {\n              _context.next = 21;\n              break;\n            }\n\n            _context.next = 17;\n            return {\n              glyph: run.glyphs[i],\n              position: run.positions[i],\n              run: run,\n              x: x,\n              index: run.start + i\n            };\n\n          case 17:\n            x += run.positions[i].xAdvance;\n\n          case 18:\n            i++;\n            _context.next = 14;\n            break;\n\n          case 21:\n            _context.next = 2;\n            break;\n\n          case 23:\n          case 'end':\n            return _context.stop();\n        }\n      }\n    }, _callee, this);\n  });\n  (0, _createClass3.default)(GlyphString, [{\n    key: 'start',\n    get: function get() {\n      if (this.glyphRuns.length === 0) return 0;\n      return this.glyphRuns[0].start;\n    }\n  }, {\n    key: 'end',\n    get: function get() {\n      if (this.glyphRuns.length === 0) return 0;\n      return this.glyphRuns[this.glyphRuns.length - 1].end;\n    }\n  }, {\n    key: 'length',\n    get: function get() {\n      return this.end - this.start;\n    }\n  }, {\n    key: 'advanceWidth',\n    get: function get() {\n      return this.glyphRuns.reduce(function (acc, run) {\n        return acc + run.advanceWidth;\n      }, 0);\n    }\n  }, {\n    key: 'height',\n    get: function get() {\n      return this.glyphRuns.reduce(function (acc, run) {\n        return Math.max(acc, run.height);\n      }, 0);\n    }\n  }, {\n    key: 'ascent',\n    get: function get() {\n      return this.glyphRuns.reduce(function (acc, run) {\n        return Math.max(acc, run.ascent);\n      }, 0);\n    }\n  }, {\n    key: 'descent',\n    get: function get() {\n      return this.glyphRuns.reduce(function (acc, run) {\n        return Math.min(acc, run.descent);\n      }, 0);\n    }\n  }]);\n  return GlyphString;\n}();\n\nexports.default = GlyphString;","map":null,"metadata":{},"sourceType":"script"}