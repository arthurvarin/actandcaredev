{"ast":null,"code":"var EventEmitter = require('events').EventEmitter,\n    _fs = require('fs'),\n    _path = require('path'),\n    sep = _path.sep || '/'; // 0.6.x\n\n\nmodule.exports = walkdir;\nwalkdir.find = walkdir.walk = walkdir;\n\nwalkdir.sync = function (path, options, cb) {\n  if (typeof options == 'function') cb = options;\n  options = options || {};\n  options.sync = true;\n  return walkdir(path, options, cb);\n};\n\nfunction walkdir(path, options, cb) {\n  if (typeof options == 'function') cb = options;\n  options = options || {};\n  var fs = options.fs || _fs;\n\n  var emitter = new EventEmitter(),\n      dontTraverse = [],\n      allPaths = options.return_object ? {} : [],\n      resolved = false,\n      inos = {},\n      stop = 0,\n      pause = null,\n      ended = 0,\n      jobs = 0,\n      job = function job(value) {\n    jobs += value;\n\n    if (value < 1 && !tick) {\n      tick = 1;\n      process.nextTick(function () {\n        tick = 0;\n\n        if (jobs <= 0 && !ended) {\n          ended = 1;\n          emitter.emit('end');\n        }\n      });\n    }\n  },\n      tick = 0;\n\n  emitter.ignore = function (path) {\n    if (Array.isArray(path)) dontTraverse.push.apply(dontTraverse, path);else dontTraverse.push(path);\n    return this;\n  }; //mapping is stat functions to event names.\t\n\n\n  var statIs = [['isFile', 'file'], ['isDirectory', 'directory'], ['isSymbolicLink', 'link'], ['isSocket', 'socket'], ['isFIFO', 'fifo'], ['isBlockDevice', 'blockdevice'], ['isCharacterDevice', 'characterdevice']];\n\n  var statter = function statter(path, first, depth) {\n    job(1);\n\n    var statAction = function fn(err, stat, data) {\n      job(-1);\n      if (stop) return; // in sync mode i found that node will sometimes return a null stat and no error =(\n      // this is reproduceable in file descriptors that no longer exist from this process\n      // after a readdir on /proc/3321/task/3321/ for example. Where 3321 is this pid\n      // node @ v0.6.10 \n\n      if (err || !stat) {\n        emitter.emit('fail', path, err);\n        return;\n      } //if i have evented this inode already dont again.\n\n\n      var fileName = _path.basename(path);\n\n      var fileKey = stat.dev + '-' + stat.ino + '-' + fileName;\n\n      if (options.track_inodes !== false) {\n        if (inos[fileKey] && stat.ino) return;\n        inos[fileKey] = 1;\n      }\n\n      if (first && stat.isDirectory()) {\n        emitter.emit('targetdirectory', path, stat, depth);\n        return;\n      }\n\n      emitter.emit('path', path, stat, depth);\n      var i, name;\n\n      for (var j = 0, k = statIs.length; j < k; j++) {\n        if (stat[statIs[j][0]]()) {\n          emitter.emit(statIs[j][1], path, stat, depth);\n          break;\n        }\n      }\n    };\n\n    if (options.sync) {\n      var stat, ex;\n\n      try {\n        stat = fs.lstatSync(path);\n      } catch (e) {\n        ex = e;\n      }\n\n      statAction(ex, stat);\n    } else {\n      fs.lstat(path, statAction);\n    }\n  },\n      readdir = function readdir(path, stat, depth) {\n    if (!resolved) {\n      path = _path.resolve(path);\n      resolved = 1;\n    }\n\n    if (options.max_depth && depth >= options.max_depth) {\n      emitter.emit('maxdepth', path, stat, depth);\n      return;\n    }\n\n    if (dontTraverse.length) {\n      for (var i = 0; i < dontTraverse.length; ++i) {\n        if (dontTraverse[i] == path) {\n          dontTraverse.splice(i, 1);\n          return;\n        }\n      }\n    }\n\n    job(1);\n\n    var readdirAction = function readdirAction(err, files) {\n      job(-1);\n\n      if (err || !files) {\n        //permissions error or invalid files\n        emitter.emit('fail', path, err);\n        return;\n      }\n\n      if (!files.length) {\n        // empty directory event.\n        emitter.emit('empty', path, stat, depth);\n        return;\n      }\n\n      if (path == sep) path = '';\n\n      for (var i = 0, j = files.length; i < j; i++) {\n        statter(path + sep + files[i], false, (depth || 0) + 1);\n      }\n    }; //use same pattern for sync as async api\n\n\n    if (options.sync) {\n      var e, files;\n\n      try {\n        files = fs.readdirSync(path);\n      } catch (e) {}\n\n      readdirAction(e, files);\n    } else {\n      fs.readdir(path, readdirAction);\n    }\n  };\n\n  if (options.follow_symlinks) {\n    var linkAction = function linkAction(err, path, depth) {\n      job(-1); //TODO should fail event here on error?\n\n      statter(path, false, depth);\n    };\n\n    emitter.on('link', function (path, stat, depth) {\n      job(1);\n\n      if (options.sync) {\n        var lpath, ex;\n\n        try {\n          lpath = fs.readlinkSync(path);\n        } catch (e) {\n          ex = e;\n        }\n\n        linkAction(ex, _path.resolve(_path.dirname(path), lpath), depth);\n      } else {\n        fs.readlink(path, function (err, lpath) {\n          linkAction(err, _path.resolve(_path.dirname(path), lpath), depth);\n        });\n      }\n    });\n  }\n\n  if (cb) {\n    emitter.on('path', cb);\n  }\n\n  if (options.sync) {\n    if (!options.no_return) {\n      emitter.on('path', function (path, stat) {\n        if (options.return_object) allPaths[path] = stat;else allPaths.push(path);\n      });\n    }\n  }\n\n  if (!options.no_recurse) {\n    emitter.on('directory', readdir);\n  } //directory that was specified by argument.\n\n\n  emitter.once('targetdirectory', readdir); //only a fail on the path specified by argument is fatal \n\n  emitter.once('fail', function (_path, err) {\n    //if the first dir fails its a real error\n    if (path == _path) {\n      emitter.emit('error', path, err);\n    }\n  });\n  statter(path, 1);\n\n  if (options.sync) {\n    return allPaths;\n  } else {\n    //support stopping everything.\n    emitter.end = emitter.stop = function () {\n      stop = 1;\n    }; //support pausing everything\n\n\n    var emitQ = [];\n\n    emitter.pause = function () {\n      job(1);\n      pause = true;\n\n      emitter.emit = function () {\n        emitQ.push(arguments);\n      };\n    }; // support getting the show going again\n\n\n    emitter.resume = function () {\n      if (!pause) return;\n      pause = false; // not pending\n\n      job(-1); //replace emit\n\n      emitter.emit = EventEmitter.prototype.emit; // local ref\n\n      var q = emitQ; // clear ref to prevent infinite loops\n\n      emitQ = [];\n\n      while (q.length) {\n        emitter.emit.apply(emitter, q.shift());\n      }\n    };\n\n    return emitter;\n  }\n}","map":null,"metadata":{},"sourceType":"script"}