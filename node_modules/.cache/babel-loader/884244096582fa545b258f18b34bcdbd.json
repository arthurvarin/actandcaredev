{"ast":null,"code":"\"use strict\";\n/*!\n * Copyright 2017 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nvar _classCallCheck = require(\"/Users/cvoisin/Repos/actandcaredev/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/cvoisin/Repos/actandcaredev/node_modules/@babel/runtime/helpers/createClass\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar projectify_1 = require(\"@google-cloud/projectify\");\n\nvar assert = require(\"assert\");\n\nvar bun = require(\"bun\");\n\nvar extend = require(\"extend\");\n\nvar is = require(\"is\");\n\nvar through2 = require(\"through2\");\n\nvar convert = require(\"./convert\");\n\nvar document_1 = require(\"./document\");\n\nvar field_value_1 = require(\"./field-value\");\n\nvar geo_point_1 = require(\"./geo-point\");\n\nvar logger_1 = require(\"./logger\");\n\nvar path_1 = require(\"./path\");\n\nvar path_2 = require(\"./path\");\n\nvar pool_1 = require(\"./pool\");\n\nvar reference_1 = require(\"./reference\");\n\nvar reference_2 = require(\"./reference\");\n\nvar serializer_1 = require(\"./serializer\");\n\nvar timestamp_1 = require(\"./timestamp\");\n\nvar transaction_1 = require(\"./transaction\");\n\nvar util_1 = require(\"./util\");\n\nvar validate_1 = require(\"./validate\");\n\nvar write_batch_1 = require(\"./write-batch\");\n\nvar write_batch_2 = require(\"./write-batch\");\n\nvar reference_3 = require(\"./reference\");\n\nexports.CollectionReference = reference_3.CollectionReference;\nexports.DocumentReference = reference_3.DocumentReference;\nexports.QuerySnapshot = reference_3.QuerySnapshot;\nexports.Query = reference_3.Query;\n\nvar document_2 = require(\"./document\");\n\nexports.DocumentSnapshot = document_2.DocumentSnapshot;\nexports.QueryDocumentSnapshot = document_2.QueryDocumentSnapshot;\n\nvar field_value_2 = require(\"./field-value\");\n\nexports.FieldValue = field_value_2.FieldValue;\n\nvar write_batch_3 = require(\"./write-batch\");\n\nexports.WriteBatch = write_batch_3.WriteBatch;\nexports.WriteResult = write_batch_3.WriteResult;\n\nvar transaction_2 = require(\"./transaction\");\n\nexports.Transaction = transaction_2.Transaction;\n\nvar timestamp_2 = require(\"./timestamp\");\n\nexports.Timestamp = timestamp_2.Timestamp;\n\nvar document_change_1 = require(\"./document-change\");\n\nexports.DocumentChange = document_change_1.DocumentChange;\n\nvar path_3 = require(\"./path\");\n\nexports.FieldPath = path_3.FieldPath;\n\nvar geo_point_2 = require(\"./geo-point\");\n\nexports.GeoPoint = geo_point_2.GeoPoint;\n\nvar logger_2 = require(\"./logger\");\n\nexports.setLogFunction = logger_2.setLogFunction;\n\nvar libVersion = require('../../package.json').version;\n\nlogger_1.setLibVersion(libVersion);\n/*!\n * DO NOT REMOVE THE FOLLOWING NAMESPACE DEFINITIONS\n */\n\n/**\n * @namespace google.protobuf\n */\n\n/**\n * @namespace google.rpc\n */\n\n/**\n * @namespace google.firestore.v1beta1\n */\n\n/*!\n * @see v1beta1\n */\n\nvar v1beta1; // Lazy-loaded in `_runRequest()`\n\n/*!\n * HTTP header for the resource prefix to improve routing and project isolation\n * by the backend.\n */\n\nvar CLOUD_RESOURCE_HEADER = 'google-cloud-resource-prefix';\n/*!\n * The maximum number of times to retry idempotent requests.\n */\n\nvar MAX_REQUEST_RETRIES = 5;\n/*!\n * The maximum number of concurrent requests supported by a single GRPC channel,\n * as enforced by Google's Frontend. If the SDK issues more than 100 concurrent\n * operations, we need to use more than one GAPIC client since these clients\n * multiplex all requests over a single channel.\n */\n\nvar MAX_CONCURRENT_REQUESTS_PER_CLIENT = 100;\n/*!\n * GRPC Error code for 'UNAVAILABLE'.\n */\n\nvar GRPC_UNAVAILABLE = 14;\n/*!\n * The maximum depth of a Firestore object.\n */\n\nvar MAX_DEPTH = 20;\n/**\n * Document data (e.g. for use with\n * [set()]{@link DocumentReference#set}) consisting of fields mapped\n * to values.\n *\n * @typedef {Object.<string, *>} DocumentData\n */\n\n/**\n * Update data (for use with [update]{@link DocumentReference#update})\n * that contains paths (e.g. 'foo' or 'foo.baz') mapped to values. Fields that\n * contain dots reference nested fields within the document.\n *\n * @typedef {Object.<string, *>} UpdateData\n */\n\n/**\n * An options object that configures conditional behavior of\n * [update()]{@link DocumentReference#update} and\n * [delete()]{@link DocumentReference#delete} calls in\n * [DocumentReference]{@link DocumentReference},\n * [WriteBatch]{@link WriteBatch}, and\n * [Transaction]{@link Transaction}. Using Preconditions, these calls\n * can be restricted to only apply to documents that match the specified\n * conditions.\n *\n * @property {string} lastUpdateTime The update time to enforce (specified as\n * an ISO 8601 string).\n * @typedef {Object} Precondition\n */\n\n/**\n * An options object that configures the behavior of\n * [set()]{@link DocumentReference#set} calls in\n * [DocumentReference]{@link DocumentReference},\n * [WriteBatch]{@link WriteBatch}, and\n * [Transaction]{@link Transaction}. These calls can be\n * configured to perform granular merges instead of overwriting the target\n * documents in their entirety by providing a SetOptions object with\n * { merge : true }.\n *\n * @property {boolean} merge Changes the behavior of a set() call to only\n * replace the values specified in its data argument. Fields omitted from the\n * set() call remain untouched.\n * @property {Array<(string|FieldPath)>} mergeFields Changes the behavior of\n * set() calls to only replace the specified field paths. Any field path that is\n * not specified is ignored and remains untouched.\n * It is an error to pass a SetOptions object to a set() call that is missing a\n * value for any of the fields specified here.\n * @typedef {Object} SetOptions\n */\n\n/**\n * An options object that can be used to configure the behavior of\n * [getAll()]{@link Firestore#getAll} calls. By providing a `fieldMask`, these\n * calls can be configured to only return a subset of fields.\n *\n * @property {Array<(string|FieldPath)>} fieldMask Specifies the set of fields\n * to return and reduces the amount of data transmitted by the backend.\n * Adding a field mask does not filter results. Documents do not need to\n * contain values for all the fields in the mask to be part of the result set.\n * @typedef {Object} ReadOptions\n */\n\n/**\n * The Firestore client represents a Firestore Database and is the entry point\n * for all Firestore operations.\n *\n * @see [Firestore Documentation]{@link https://firebase.google.com/docs/firestore/}\n *\n * @class\n *\n * @example <caption>Install the client library with <a\n * href=\"https://www.npmjs.com/\">npm</a>:</caption> npm install --save\n * @google-cloud/firestore\n *\n * @example <caption>Import the client library</caption>\n * var Firestore = require('@google-cloud/firestore');\n *\n * @example <caption>Create a client that uses <a\n * href=\"https://cloud.google.com/docs/authentication/production#providing_credentials_to_your_application\">Application\n * Default Credentials (ADC)</a>:</caption> var firestore = new Firestore();\n *\n * @example <caption>Create a client with <a\n * href=\"https://cloud.google.com/docs/authentication/production#obtaining_and_providing_service_account_credentials_manually\">explicit\n * credentials</a>:</caption> var firestore = new Firestore({ projectId:\n * 'your-project-id', keyFilename: '/path/to/keyfile.json'\n * });\n *\n * @example <caption>include:samples/quickstart.js</caption>\n * region_tag:firestore_quickstart\n * Full quickstart example:\n */\n\nvar Firestore =\n/*#__PURE__*/\nfunction () {\n  /**\n   * @param {Object=} settings [Configuration object](#/docs).\n   * @param {string=} settings.projectId The project ID from the Google\n   * Developer's Console, e.g. 'grape-spaceship-123'. We will also check the\n   * environment variable GCLOUD_PROJECT for your project ID.  Can be omitted in\n   * environments that support\n   * {@link https://cloud.google.com/docs/authentication Application Default\n   * Credentials}\n   * @param {string=} settings.keyFilename Local file containing the Service\n   * Account credentials as downloaded from the Google Developers Console. Can\n   * be omitted in environments that support\n   * {@link https://cloud.google.com/docs/authentication Application Default\n   * Credentials}. To configure Firestore with custom credentials, use\n   * `settings.credentials` and provide the `client_email` and `private_key` of\n   * your service account.\n   * @param {{client_email:string=, private_key:string=}=} settings.credentials\n   * The `client_email` and `private_key` properties of the service account\n   * to use with your Firestore project. Can be omitted in environments that\n   * support {@link https://cloud.google.com/docs/authentication Application\n   * Default Credentials}. If your credentials are stored in a JSON file, you\n   * can specify a `keyFilename` instead.\n   * @param {boolean=} settings.timestampsInSnapshots Enables the use of\n   * `Timestamp`s for timestamp fields in `DocumentSnapshots`.<br/>\n   * Currently, Firestore returns timestamp fields as `Date` but `Date` only\n   * supports millisecond precision, which leads to truncation and causes\n   * unexpected behavior when using a timestamp from a snapshot as a part\n   * of a subsequent query.\n   * <br/>Setting `timestampsInSnapshots` to true will cause Firestore to return\n   * `Timestamp` values instead of `Date` avoiding this kind of problem. To\n   * make this work you must also change any code that uses `Date` to use\n   * `Timestamp` instead.\n   * <br/>NOTE: in the future `timestampsInSnapshots: true` will become the\n   * default and this option will be removed so you should change your code to\n   * use `Timestamp` now and opt-in to this new behavior as soon as you can.\n   */\n  function Firestore(settings) {\n    _classCallCheck(this, Firestore);\n\n    /**\n     * A client pool to distribute requests over multiple GAPIC clients in order\n     * to work around a connection limit of 100 concurrent requests per client.\n     * @private\n     */\n    this._clientPool = null;\n    /**\n     * The configuration options for the GAPIC client.\n     * @private\n     */\n\n    this._settings = {};\n    /**\n     * Whether the initialization settings can still be changed by invoking\n     * `settings()`.\n     * @private\n     */\n\n    this._settingsFrozen = false;\n    /**\n     * A Promise that resolves when client initialization completes. Can be\n     * 'null' if initialization hasn't started yet.\n     * @private\n     */\n\n    this._clientInitialized = null;\n    /**\n     * The serializer to use for the Protobuf transformation.\n     * @private\n     */\n\n    this._serializer = null;\n    this._referencePath = null;\n    /** @private */\n\n    this._lastSuccessfulRequest = 0;\n    this._validator = new validate_1.Validator({\n      ArrayElement: function ArrayElement(name, value) {\n        return validateFieldValue(name, value,\n        /*path=*/\n        undefined,\n        /*level=*/\n        0,\n        /*inArray=*/\n        true);\n      },\n      DeletePrecondition: function DeletePrecondition(precondition) {\n        return document_1.validatePrecondition(precondition,\n        /* allowExists= */\n        true);\n      },\n      Document: validateDocumentData,\n      DocumentReference: reference_1.validateDocumentReference,\n      FieldPath: path_1.FieldPath.validateFieldPath,\n      FieldValue: validateFieldValue,\n      FieldOrder: reference_1.validateFieldOrder,\n      QueryComparison: reference_1.validateComparisonOperator,\n      QueryValue: validateFieldValue,\n      ResourcePath: path_2.ResourcePath.validateResourcePath,\n      SetOptions: document_1.validateSetOptions,\n      ReadOptions: validateReadOptions,\n      UpdateMap: write_batch_2.validateUpdateMap,\n      UpdatePrecondition: function UpdatePrecondition(precondition) {\n        return document_1.validatePrecondition(precondition,\n        /* allowExists= */\n        false);\n      }\n    });\n    var libraryHeader = {\n      libName: 'gccl',\n      libVersion: libVersion\n    };\n\n    if (settings && settings.firebaseVersion) {\n      libraryHeader.libVersion += ' fire/' + settings.firebaseVersion;\n    }\n\n    this.validateAndApplySettings(Object.assign({}, settings, libraryHeader)); // GCF currently tears down idle connections after two minutes. Requests\n    // that are issued after this period may fail. On GCF, we therefore issue\n    // these requests as part of a transaction so that we can safely retry until\n    // the network link is reestablished.\n    //\n    // The environment variable FUNCTION_TRIGGER_TYPE is used to detect the GCF\n    // environment.\n\n    this._preferTransactions = is.defined(process.env.FUNCTION_TRIGGER_TYPE);\n    this._lastSuccessfulRequest = 0;\n\n    if (this._preferTransactions) {\n      logger_1.logger('Firestore', null, 'Detected GCF environment');\n    }\n\n    logger_1.logger('Firestore', null, 'Initialized Firestore');\n  }\n  /**\n   * Specifies custom settings to be used to configure the `Firestore`\n   * instance. Can only be invoked once and before any other Firestore method.\n   *\n   * If settings are provided via both `settings()` and the `Firestore`\n   * constructor, both settings objects are merged and any settings provided via\n   * `settings()` take precedence.\n   *\n   * @param {object} settings The settings to use for all Firestore operations.\n   */\n\n\n  _createClass(Firestore, [{\n    key: \"settings\",\n    value: function settings(_settings) {\n      this._validator.isObject('settings', _settings);\n\n      this._validator.isOptionalString('settings.projectId', _settings.projectId);\n\n      this._validator.isOptionalBoolean('settings.timestampsInSnapshots', _settings.timestampsInSnapshots);\n\n      if (this._clientInitialized) {\n        throw new Error('Firestore has already been started and its settings can no longer ' + 'be changed. You can only call settings() before calling any other ' + 'methods on a Firestore object.');\n      }\n\n      if (this._settingsFrozen) {\n        throw new Error('Firestore.settings() has already be called. You can only call ' + 'settings() once, and only before calling any other methods on a ' + 'Firestore object.');\n      }\n\n      var mergedSettings = Object.assign({}, this._settings, _settings);\n      this.validateAndApplySettings(mergedSettings);\n      this._settingsFrozen = true;\n    }\n  }, {\n    key: \"validateAndApplySettings\",\n    value: function validateAndApplySettings(settings) {\n      this._validator.isOptionalBoolean('settings.timestampsInSnapshots', settings.timestampsInSnapshots);\n\n      if (settings && settings.projectId) {\n        this._validator.isString('settings.projectId', settings.projectId);\n\n        this._referencePath = new path_2.ResourcePath(settings.projectId, '(default)');\n      } else {\n        // Initialize a temporary reference path that will be overwritten during\n        // project ID detection.\n        this._referencePath = new path_2.ResourcePath('{{projectId}}', '(default)');\n      }\n\n      this._settings = settings;\n      this._serializer = new serializer_1.Serializer(this);\n    }\n    /**\n     * The root path to the database.\n     *\n     * @private\n     */\n\n  }, {\n    key: \"doc\",\n\n    /**\n     * Gets a [DocumentReference]{@link DocumentReference} instance that\n     * refers to the document at the specified path.\n     *\n     * @param {string} documentPath A slash-separated path to a document.\n     * @returns {DocumentReference} The\n     * [DocumentReference]{@link DocumentReference} instance.\n     *\n     * @example\n     * let documentRef = firestore.doc('collection/document');\n     * console.log(`Path of document is ${documentRef.path}`);\n     */\n    value: function doc(documentPath) {\n      this._validator.isResourcePath('documentPath', documentPath);\n\n      var path = this._referencePath.append(documentPath);\n\n      if (!path.isDocument) {\n        throw new Error(\"Argument \\\"documentPath\\\" must point to a document, but was \\\"\".concat(documentPath, \"\\\". Your path does not contain an even number of components.\"));\n      }\n\n      return new reference_2.DocumentReference(this, path);\n    }\n    /**\n     * Gets a [CollectionReference]{@link CollectionReference} instance\n     * that refers to the collection at the specified path.\n     *\n     * @param {string} collectionPath A slash-separated path to a collection.\n     * @returns {CollectionReference} The\n     * [CollectionReference]{@link CollectionReference} instance.\n     *\n     * @example\n     * let collectionRef = firestore.collection('collection');\n     *\n     * // Add a document with an auto-generated ID.\n     * collectionRef.add({foo: 'bar'}).then((documentRef) => {\n     *   console.log(`Added document at ${documentRef.path})`);\n     * });\n     */\n\n  }, {\n    key: \"collection\",\n    value: function collection(collectionPath) {\n      this._validator.isResourcePath('collectionPath', collectionPath);\n\n      var path = this._referencePath.append(collectionPath);\n\n      if (!path.isCollection) {\n        throw new Error(\"Argument \\\"collectionPath\\\" must point to a collection, but was \\\"\".concat(collectionPath, \"\\\". Your path does not contain an odd number of components.\"));\n      }\n\n      return new reference_1.CollectionReference(this, path);\n    }\n    /**\n     * Creates a [WriteBatch]{@link WriteBatch}, used for performing\n     * multiple writes as a single atomic operation.\n     *\n     * @returns {WriteBatch} A WriteBatch that operates on this Firestore\n     * client.\n     *\n     * @example\n     * let writeBatch = firestore.batch();\n     *\n     * // Add two documents in an atomic batch.\n     * let data = { foo: 'bar' };\n     * writeBatch.set(firestore.doc('col/doc1'), data);\n     * writeBatch.set(firestore.doc('col/doc2'), data);\n     *\n     * writeBatch.commit().then(res => {\n     *   console.log(`Added document at ${res.writeResults[0].updateTime}`);\n     * });\n     */\n\n  }, {\n    key: \"batch\",\n    value: function batch() {\n      return new write_batch_1.WriteBatch(this);\n    }\n    /**\n     * Creates a [DocumentSnapshot]{@link DocumentSnapshot} or a\n     * [QueryDocumentSnapshot]{@link QueryDocumentSnapshot} from a\n     * `firestore.v1beta1.Document` proto (or from a resource name for missing\n     * documents).\n     *\n     * This API is used by Google Cloud Functions and can be called with both\n     * 'Proto3 JSON' and 'Protobuf JS' encoded data.\n     *\n     * @private\n     * @param documentOrName The Firestore 'Document' proto or the resource name\n     * of a missing document.\n     * @param readTime A 'Timestamp' proto indicating the time this document was\n     * read.\n     * @param encoding One of 'json' or 'protobufJS'. Applies to both the\n     * 'document' Proto and 'readTime'. Defaults to 'protobufJS'.\n     * @returns A QueryDocumentSnapshot for existing documents, otherwise a\n     * DocumentSnapshot.\n     */\n\n  }, {\n    key: \"snapshot_\",\n    value: function snapshot_(documentOrName, readTime, encoding) {\n      // TODO: Assert that Firestore Project ID is valid.\n      var convertTimestamp;\n      var convertDocument;\n\n      if (!is.defined(encoding) || encoding === 'protobufJS') {\n        convertTimestamp = function convertTimestamp(data) {\n          return data;\n        };\n\n        convertDocument = function convertDocument(data) {\n          return data;\n        };\n      } else if (encoding === 'json') {\n        // Google Cloud Functions calls us with Proto3 JSON format data, which we\n        // must convert to Protobuf JS.\n        convertTimestamp = convert.timestampFromJson;\n        convertDocument = convert.documentFromJson;\n      } else {\n        throw new Error(\"Unsupported encoding format. Expected \\\"json\\\" or \\\"protobufJS\\\", \" + \"but was \\\"\".concat(encoding, \"\\\".\"));\n      }\n\n      var document = new document_1.DocumentSnapshotBuilder();\n\n      if (typeof documentOrName === 'string') {\n        document.ref = new reference_2.DocumentReference(this, path_2.ResourcePath.fromSlashSeparatedString(documentOrName));\n      } else {\n        document.ref = new reference_2.DocumentReference(this, path_2.ResourcePath.fromSlashSeparatedString(documentOrName.name));\n        document.fieldsProto = documentOrName.fields ? convertDocument(documentOrName.fields) : {};\n        document.createTime = timestamp_1.Timestamp.fromProto(convertTimestamp(documentOrName.createTime, 'documentOrName.createTime'));\n        document.updateTime = timestamp_1.Timestamp.fromProto(convertTimestamp(documentOrName.updateTime, 'documentOrName.updateTime'));\n      }\n\n      if (readTime) {\n        document.readTime = timestamp_1.Timestamp.fromProto(convertTimestamp(readTime, 'readTime'));\n      }\n\n      return document.build();\n    }\n    /**\n     * Executes the given updateFunction and commits the changes applied within\n     * the transaction.\n     *\n     * You can use the transaction object passed to 'updateFunction' to read and\n     * modify Firestore documents under lock. Transactions are committed once\n     * 'updateFunction' resolves and attempted up to five times on failure.\n     *\n     * @param {function(Transaction)} updateFunction The function to execute\n     * within the transaction context.\n     * @param {object=} transactionOptions Transaction options.\n     * @param {number=} transactionOptions.maxAttempts - The maximum number of\n     * attempts for this transaction.\n     * @returns {Promise} If the transaction completed successfully or was\n     * explicitly aborted (by the updateFunction returning a failed Promise), the\n     * Promise returned by the updateFunction will be returned here. Else if the\n     * transaction failed, a rejected Promise with the corresponding failure\n     * error will be returned.\n     *\n     * @example\n     * let counterTransaction = firestore.runTransaction(transaction => {\n     *   let documentRef = firestore.doc('col/doc');\n     *   return transaction.get(documentRef).then(doc => {\n     *     if (doc.exists) {\n     *       let count =  doc.get('count') || 0;\n     *       if (count > 10) {\n     *         return Promise.reject('Reached maximum count');\n     *       }\n     *       transaction.update(documentRef, { count: ++count });\n     *       return Promise.resolve(count);\n     *     }\n     *\n     *     transaction.create(documentRef, { count: 1 });\n     *     return Promise.resolve(1);\n     *   });\n     * });\n     *\n     * counterTransaction.then(res => {\n     *   console.log(`Count updated to ${res}`);\n     * });\n     */\n\n  }, {\n    key: \"runTransaction\",\n    value: function runTransaction(updateFunction, transactionOptions) {\n      this._validator.isFunction('updateFunction', updateFunction);\n\n      if (transactionOptions) {\n        this._validator.isObject('transactionOptions', transactionOptions);\n\n        this._validator.isOptionalInteger('transactionOptions.maxAttempts', transactionOptions.maxAttempts, 1);\n      }\n\n      return this._runTransaction(updateFunction, transactionOptions);\n    }\n  }, {\n    key: \"_runTransaction\",\n    value: function _runTransaction(updateFunction, transactionOptions) {\n      var _this = this;\n\n      var defaultAttempts = 5;\n      var attemptsRemaining = defaultAttempts;\n      var previousTransaction;\n\n      if (transactionOptions) {\n        attemptsRemaining = transactionOptions.maxAttempts || attemptsRemaining;\n        previousTransaction = transactionOptions.previousTransaction;\n      }\n\n      var transaction = new transaction_1.Transaction(this, previousTransaction);\n      var requestTag = transaction.requestTag;\n      var result;\n      --attemptsRemaining;\n      return transaction.begin().then(function () {\n        var promise = updateFunction(transaction);\n        result = promise instanceof Promise ? promise : Promise.reject(new Error('You must return a Promise in your transaction()-callback.'));\n        return result.catch(function (err) {\n          logger_1.logger('Firestore.runTransaction', requestTag, 'Rolling back transaction after callback error:', err); // Rollback the transaction and return the failed result.\n\n          return transaction.rollback().then(function () {\n            return result;\n          });\n        });\n      }).then(function () {\n        return transaction.commit().then(function () {\n          return result;\n        }).catch(function (err) {\n          if (attemptsRemaining > 0) {\n            logger_1.logger('Firestore.runTransaction', requestTag, \"Retrying transaction after error: \".concat(JSON.stringify(err), \".\"));\n            return _this._runTransaction(updateFunction, {\n              previousTransaction: transaction,\n              maxAttempts: attemptsRemaining\n            });\n          }\n\n          logger_1.logger('Firestore.runTransaction', requestTag, 'Exhausted transaction retries, returning error: %s', err);\n          return Promise.reject(err);\n        });\n      });\n    }\n    /**\n     * Fetches the root collections that are associated with this Firestore\n     * database.\n     *\n     * @returns {Promise.<Array.<CollectionReference>>} A Promise that resolves\n     * with an array of CollectionReferences.\n     *\n     * @example\n     * firestore.listCollections().then(collections => {\n     *   for (let collection of collections) {\n     *     console.log(`Found collection with id: ${collection.id}`);\n     *   }\n     * });\n     */\n\n  }, {\n    key: \"listCollections\",\n    value: function listCollections() {\n      var rootDocument = new reference_2.DocumentReference(this, this._referencePath);\n      return rootDocument.listCollections();\n    }\n    /**\n     * Fetches the root collections that are associated with this Firestore\n     * database.\n     *\n     * @deprecated Use `.listCollections()`.\n     *\n     * @returns {Promise.<Array.<CollectionReference>>} A Promise that resolves\n     * with an array of CollectionReferences.\n     */\n\n  }, {\n    key: \"getCollections\",\n    value: function getCollections() {\n      return this.listCollections();\n    }\n    /**\n     * Retrieves multiple documents from Firestore.\n     *\n     * @param {DocumentReference} documentRef A `DocumentReference` to receive.\n     * @param {Array.<DocumentReference|ReadOptions>} moreDocumentRefsOrReadOptions\n     * Additional `DocumentReferences` to receive, followed by an optional field\n     * mask.\n     * @returns {Promise<Array.<DocumentSnapshot>>} A Promise that\n     * contains an array with the resulting document snapshots.\n     *\n     * @example\n     * let docRef1 = firestore.doc('col/doc1');\n     * let docRef2 = firestore.doc('col/doc2');\n     *\n     * firestore.getAll(docRef1, docRef2, { fieldMask: ['user'] }).then(docs => {\n     *   console.log(`First document: ${JSON.stringify(docs[0])}`);\n     *   console.log(`Second document: ${JSON.stringify(docs[1])}`);\n     * });\n     */\n\n  }, {\n    key: \"getAll\",\n    value: function getAll(documentRef) {\n      for (var _len = arguments.length, moreDocumentRefsOrReadOptions = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        moreDocumentRefsOrReadOptions[_key - 1] = arguments[_key];\n      }\n\n      this._validator.minNumberOfArguments('Firestore.getAll', arguments, 1);\n\n      var _util_1$parseGetAllAr = util_1.parseGetAllArguments(this._validator, [documentRef].concat(moreDocumentRefsOrReadOptions)),\n          documents = _util_1$parseGetAllAr.documents,\n          fieldMask = _util_1$parseGetAllAr.fieldMask;\n\n      return this.getAll_(documents, fieldMask, util_1.requestTag());\n    }\n    /**\n     * Internal method to retrieve multiple documents from Firestore, optionally\n     * as part of a transaction.\n     *\n     * @private\n     * @param docRefs The documents to receive.\n     * @param fieldMask An optional field mask to apply to this read.\n     * @param requestTag A unique client-assigned identifier for this request.\n     * @param transactionId The transaction ID to use for this read.\n     * @returns A Promise that contains an array with the resulting documents.\n     */\n\n  }, {\n    key: \"getAll_\",\n    value: function getAll_(docRefs, fieldMask, requestTag, transactionId) {\n      var requestedDocuments = new Set();\n      var retrievedDocuments = new Map();\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = docRefs[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var docRef = _step.value;\n          requestedDocuments.add(docRef.formattedName);\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return != null) {\n            _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n\n      var request = {\n        database: this.formattedName,\n        transaction: transactionId,\n        documents: Array.from(requestedDocuments)\n      };\n\n      if (fieldMask) {\n        var fieldPaths = fieldMask.map(function (fieldPath) {\n          return fieldPath.formattedName;\n        });\n        request.mask = {\n          fieldPaths: fieldPaths\n        };\n      }\n\n      var self = this;\n      return self.readStream('batchGetDocuments', request, requestTag, true).then(function (stream) {\n        return new Promise(function (resolve, reject) {\n          stream.on('error', function (err) {\n            logger_1.logger('Firestore.getAll_', requestTag, 'GetAll failed with error:', err);\n            reject(err);\n          }).on('data', function (response) {\n            try {\n              var document;\n\n              if (response.found) {\n                logger_1.logger('Firestore.getAll_', requestTag, 'Received document: %s', response.found.name);\n                document = self.snapshot_(response.found, response.readTime);\n              } else {\n                logger_1.logger('Firestore.getAll_', requestTag, 'Document missing: %s', response.missing);\n                document = self.snapshot_(response.missing, response.readTime);\n              }\n\n              var path = document.ref.path;\n              retrievedDocuments.set(path, document);\n            } catch (err) {\n              logger_1.logger('Firestore.getAll_', requestTag, 'GetAll failed with exception:', err);\n              reject(err);\n            }\n          }).on('end', function () {\n            logger_1.logger('Firestore.getAll_', requestTag, 'Received %d results', retrievedDocuments.size); // BatchGetDocuments doesn't preserve document order. We use\n            // the request order to sort the resulting documents.\n\n            var orderedDocuments = [];\n            var _iteratorNormalCompletion2 = true;\n            var _didIteratorError2 = false;\n            var _iteratorError2 = undefined;\n\n            try {\n              for (var _iterator2 = docRefs[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n                var docRef = _step2.value;\n                var document = retrievedDocuments.get(docRef.path);\n\n                if (!is.defined(document)) {\n                  reject(new Error(\"Did not receive document for \\\"\".concat(docRef.path, \"\\\".\")));\n                }\n\n                orderedDocuments.push(document);\n              }\n            } catch (err) {\n              _didIteratorError2 = true;\n              _iteratorError2 = err;\n            } finally {\n              try {\n                if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n                  _iterator2.return();\n                }\n              } finally {\n                if (_didIteratorError2) {\n                  throw _iteratorError2;\n                }\n              }\n            }\n\n            resolve(orderedDocuments);\n          });\n          stream.resume();\n        });\n      });\n    }\n    /**\n     * Executes a new request using the first available GAPIC client.\n     *\n     * @private\n     */\n\n  }, {\n    key: \"_runRequest\",\n    value: function _runRequest(op) {\n      var _this2 = this;\n\n      // Initialize the client pool if this is the first request.\n      if (!this._clientInitialized) {\n        if (!this._settings.timestampsInSnapshots) {\n          console.error(\"\\nThe behavior for Date objects stored in Firestore is going to change\\nAND YOUR APP MAY BREAK.\\nTo hide this warning and ensure your app does not break, you need to add the\\nfollowing code to your app before calling any other Cloud Firestore methods:\\n\\n  const firestore = new Firestore();\\n  const settings = {/* your settings... */ timestampsInSnapshots: true};\\n  firestore.settings(settings);\\n\\nWith this change, timestamps stored in Cloud Firestore will be read back as\\nFirebase Timestamp objects instead of as system Date objects. So you will also\\nneed to update code expecting a Date to instead expect a Timestamp. For example:\\n\\n  // Old:\\n  const date = snapshot.get('created_at');\\n  // New:\\n  const timestamp = snapshot.get('created_at');\\n  const date = timestamp.toDate();\\n\\nPlease audit all existing usages of Date when you enable the new behavior. In a\\nfuture release, the behavior will change to the new behavior, so if you do not\\nfollow these steps, YOUR APP MAY BREAK.\");\n        }\n\n        this._clientInitialized = this._initClientPool().then(function (clientPool) {\n          _this2._clientPool = clientPool;\n        });\n      }\n\n      return this._clientInitialized.then(function () {\n        return _this2._clientPool.run(op);\n      });\n    }\n    /**\n     * Initializes the client pool and invokes Project ID detection. Returns a\n     * Promise on completion.\n     *\n     * @private\n     */\n\n  }, {\n    key: \"_initClientPool\",\n    value: function _initClientPool() {\n      var _this3 = this;\n\n      assert(!this._clientInitialized, 'Client pool already initialized');\n      var clientPool = new pool_1.ClientPool(MAX_CONCURRENT_REQUESTS_PER_CLIENT, function () {\n        var client = new module.exports.v1beta1(_this3._settings);\n        logger_1.logger('Firestore', null, 'Initialized Firestore GAPIC Client');\n        return client;\n      });\n      var projectIdProvided = this._referencePath.projectId !== '{{projectId}}';\n\n      if (projectIdProvided) {\n        return Promise.resolve(clientPool);\n      } else {\n        return clientPool.run(function (client) {\n          return _this3._detectProjectId(client);\n        }).then(function (projectId) {\n          _this3._referencePath = new path_2.ResourcePath(projectId, _this3._referencePath.databaseId);\n          return clientPool;\n        });\n      }\n    }\n    /**\n     * Auto-detects the Firestore Project ID.\n     *\n     * @private\n     * @param gapicClient The Firestore GAPIC client.\n     * @return A Promise that resolves with the Project ID.\n     */\n\n  }, {\n    key: \"_detectProjectId\",\n    value: function _detectProjectId(gapicClient) {\n      return new Promise(function (resolve, reject) {\n        gapicClient.getProjectId(function (err, projectId) {\n          if (err) {\n            logger_1.logger('Firestore._detectProjectId', null, 'Failed to detect project ID: %s', err);\n            reject(err);\n          } else {\n            logger_1.logger('Firestore._detectProjectId', null, 'Detected project ID: %s', projectId);\n            resolve(projectId);\n          }\n        });\n      });\n    }\n    /**\n     * Decorate the request options of an API request. This is used to replace\n     * any `{{projectId}}` placeholders with the value detected from the user's\n     * environment, if one wasn't provided manually.\n     *\n     * @private\n     */\n\n  }, {\n    key: \"_decorateRequest\",\n    value: function _decorateRequest(request) {\n      var decoratedRequest = extend(true, {}, request);\n      decoratedRequest = projectify_1.replaceProjectIdToken(decoratedRequest, this._referencePath.projectId);\n      var decoratedGax = {\n        otherArgs: {\n          headers: {}\n        }\n      };\n      decoratedGax.otherArgs.headers[CLOUD_RESOURCE_HEADER] = this.formattedName;\n      return {\n        request: decoratedRequest,\n        gax: decoratedGax\n      };\n    }\n    /**\n     * A function returning a Promise that can be retried.\n     *\n     * @private\n     * @callback retryFunction\n     * @returns {Promise} A Promise indicating the function's success.\n     */\n\n    /**\n     * Helper method that retries failed Promises.\n     *\n     * If 'delayMs' is specified, waits 'delayMs' between invocations. Otherwise,\n     * schedules the first attempt immediately, and then waits 100 milliseconds\n     * for further attempts.\n     *\n     * @private\n     * @param attemptsRemaining The number of available attempts.\n     * @param requestTag A unique client-assigned identifier for this request.\n     * @param func Method returning a Promise than can be retried.\n     * @param delayMs How long to wait before issuing a this retry. Defaults to\n     * zero.\n     * @returns  - A Promise with the function's result if successful within\n     * `attemptsRemaining`. Otherwise, returns the last rejected Promise.\n     */\n\n  }, {\n    key: \"_retry\",\n    value: function _retry(attemptsRemaining, requestTag, func) {\n      var delayMs = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n      var self = this;\n      var currentDelay = delayMs;\n      var nextDelay = delayMs || 100;\n      --attemptsRemaining;\n      return new Promise(function (resolve) {\n        setTimeout(resolve, currentDelay);\n      }).then(func).then(function (result) {\n        self._lastSuccessfulRequest = new Date().getTime();\n        return result;\n      }).catch(function (err) {\n        if (is.defined(err.code) && err.code !== GRPC_UNAVAILABLE) {\n          logger_1.logger('Firestore._retry', requestTag, 'Request failed with unrecoverable error:', err);\n          return Promise.reject(err);\n        }\n\n        if (attemptsRemaining === 0) {\n          logger_1.logger('Firestore._retry', requestTag, 'Request failed with error:', err);\n          return Promise.reject(err);\n        }\n\n        logger_1.logger('Firestore._retry', requestTag, 'Retrying request that failed with error:', err);\n        return self._retry(attemptsRemaining, requestTag, func, nextDelay);\n      });\n    }\n  }, {\n    key: \"_initializeStream\",\n    value: function _initializeStream(resultStream, requestTag, request) {\n      /** The last error we received and have not forwarded yet. */\n      var errorReceived = null;\n      /**\n       * Whether we have resolved the Promise and returned the stream to the\n       * caller.\n       */\n\n      var streamReleased = false;\n      /**\n       * Whether the stream end has been reached. This has to be forwarded to the\n       * caller..\n       */\n\n      var endCalled = false;\n      return new Promise(function (resolve, reject) {\n        var releaseStream = function releaseStream() {\n          if (errorReceived) {\n            logger_1.logger('Firestore._initializeStream', requestTag, 'Emit error:', errorReceived);\n            resultStream.emit('error', errorReceived);\n            errorReceived = null;\n          } else if (!streamReleased) {\n            logger_1.logger('Firestore._initializeStream', requestTag, 'Releasing stream');\n            streamReleased = true;\n            resultStream.pause(); // Calling 'stream.pause()' only holds up 'data' events and not the\n            // 'end' event we intend to forward here. We therefore need to wait\n            // until the API consumer registers their listeners (in the .then()\n            // call) before emitting any further events.\n\n            resolve(resultStream); // We execute the forwarding of the 'end' event via setTimeout() as\n            // V8 guarantees that the above the Promise chain is resolved before\n            // any calls invoked via setTimeout().\n\n            setTimeout(function () {\n              if (endCalled) {\n                logger_1.logger('Firestore._initializeStream', requestTag, 'Forwarding stream close');\n                resultStream.emit('end');\n              }\n            }, 0);\n          }\n        }; // We capture any errors received and buffer them until the caller has\n        // registered a listener. We register our event handler as early as\n        // possible to avoid the default stream behavior (which is just to log and\n        // continue).\n\n\n        resultStream.on('readable', function () {\n          releaseStream();\n        });\n        resultStream.on('end', function () {\n          logger_1.logger('Firestore._initializeStream', requestTag, 'Received stream end');\n          endCalled = true;\n          releaseStream();\n        });\n        resultStream.on('error', function (err) {\n          logger_1.logger('Firestore._initializeStream', requestTag, 'Received stream error:', err); // If we receive an error before we were able to receive any data,\n          // reject this stream.\n\n          if (!streamReleased) {\n            logger_1.logger('Firestore._initializeStream', requestTag, 'Received initial error:', err);\n            streamReleased = true;\n            reject(err);\n          } else {\n            errorReceived = err;\n          }\n        });\n\n        if (request) {\n          logger_1.logger('Firestore._initializeStream', requestTag, 'Sending request: %j', request);\n          resultStream.write(request, 'utf-8', function () {\n            logger_1.logger('Firestore._initializeStream', requestTag, 'Marking stream as healthy');\n            releaseStream();\n          });\n        }\n      });\n    }\n    /**\n     * A funnel for all non-streaming API requests, assigning a project ID where\n     *  necessary within the request options.\n     *\n     * @private\n     * @param methodName Name of the veneer API endpoint that takes a request\n     * and GAX options.\n     * @param request The Protobuf request to send.\n     * @param requestTag A unique client-assigned identifier for this request.\n     * @param allowRetries Whether this is an idempotent request that can be\n     * retried.\n     * @returns A Promise with the request result.\n     */\n\n  }, {\n    key: \"request\",\n    value: function request(methodName, _request, requestTag, allowRetries) {\n      var _this4 = this;\n\n      var attempts = allowRetries ? MAX_REQUEST_RETRIES : 1;\n      return this._runRequest(function (gapicClient) {\n        var decorated = _this4._decorateRequest(_request);\n\n        return _this4._retry(attempts, requestTag, function () {\n          return new Promise(function (resolve, reject) {\n            logger_1.logger('Firestore.request', requestTag, 'Sending request: %j', decorated.request);\n            gapicClient[methodName](decorated.request, decorated.gax, function (err, result) {\n              if (err) {\n                logger_1.logger('Firestore.request', requestTag, 'Received error:', err);\n                reject(err);\n              } else {\n                logger_1.logger('Firestore.request', requestTag, 'Received response: %j', result);\n                resolve(result);\n              }\n            });\n          });\n        });\n      });\n    }\n    /**\n     * A funnel for read-only streaming API requests, assigning a project ID where\n     * necessary within the request options.\n     *\n     * The stream is returned in paused state and needs to be resumed once all\n     * listeners are attached.\n     *\n     * @private\n     * @param methodName Name of the streaming Veneer API endpoint that\n     * takes a request and GAX options.\n     * @param request The Protobuf request to send.\n     * @param requestTag A unique client-assigned identifier for this request.\n     * @param {boolean} allowRetries Whether this is an idempotent request that\n     * can be retried.\n     * @returns A Promise with the resulting read-only stream.\n     */\n\n  }, {\n    key: \"readStream\",\n    value: function readStream(methodName, request, requestTag, allowRetries) {\n      var _this5 = this;\n\n      var attempts = allowRetries ? MAX_REQUEST_RETRIES : 1;\n      return this._runRequest(function (gapicClient) {\n        var decorated = _this5._decorateRequest(request);\n\n        return _this5._retry(attempts, requestTag, function () {\n          return new Promise(function (resolve, reject) {\n            try {\n              logger_1.logger('Firestore.readStream', requestTag, 'Sending request: %j', decorated.request);\n              var stream = gapicClient[methodName](decorated.request, decorated.gax);\n              var logStream = through2.obj(function (chunk, enc, callback) {\n                logger_1.logger('Firestore.readStream', requestTag, 'Received response: %j', chunk);\n                this.push(chunk);\n                callback();\n              });\n              resolve(bun([stream, logStream]));\n            } catch (err) {\n              logger_1.logger('Firestore.readStream', requestTag, 'Received error:', err);\n              reject(err);\n            }\n          }).then(function (stream) {\n            return _this5._initializeStream(stream, requestTag);\n          });\n        });\n      });\n    }\n    /**\n     * A funnel for read-write streaming API requests, assigning a project ID\n     * where necessary for all writes.\n     *\n     * The stream is returned in paused state and needs to be resumed once all\n     * listeners are attached.\n     *\n     * @private\n     * @param methodName Name of the streaming Veneer API endpoint that takes\n     * GAX options.\n     * @param request The Protobuf request to send as the first stream message.\n     * @param requestTag A unique client-assigned identifier for this request.\n     * @param allowRetries Whether this is an idempotent request that can be\n     * retried.\n     * @returns A Promise with the resulting read/write stream.\n     */\n\n  }, {\n    key: \"readWriteStream\",\n    value: function readWriteStream(methodName, request, requestTag, allowRetries) {\n      var _this6 = this;\n\n      var self = this;\n      var attempts = allowRetries ? MAX_REQUEST_RETRIES : 1;\n      return this._runRequest(function (gapicClient) {\n        var decorated = _this6._decorateRequest(request);\n\n        return _this6._retry(attempts, requestTag, function () {\n          return Promise.resolve().then(function () {\n            logger_1.logger('Firestore.readWriteStream', requestTag, 'Opening stream');\n            var requestStream = gapicClient[methodName](decorated.gax); // The transform stream to assign the project ID.\n\n            var transform = through2.obj(function (chunk, encoding, callback) {\n              var decoratedChunk = extend(true, {}, chunk);\n              projectify_1.replaceProjectIdToken(decoratedChunk, self._referencePath.projectId);\n              logger_1.logger('Firestore.readWriteStream', requestTag, 'Streaming request: %j', decoratedChunk);\n              requestStream.write(decoratedChunk, encoding, callback);\n            });\n            var logStream = through2.obj(function (chunk, enc, callback) {\n              logger_1.logger('Firestore.readWriteStream', requestTag, 'Received response: %j', chunk);\n              this.push(chunk);\n              callback();\n            });\n            var resultStream = bun([transform, requestStream, logStream]);\n            return _this6._initializeStream(resultStream, requestTag, request);\n          });\n        });\n      });\n    }\n  }, {\n    key: \"formattedName\",\n    get: function get() {\n      return this._referencePath.formattedName;\n    }\n  }]);\n\n  return Firestore;\n}();\n\nexports.Firestore = Firestore;\n/**\n * Validates a JavaScript value for usage as a Firestore value.\n *\n * @private\n * @param val JavaScript value to validate.\n * @param path The field path to validate.\n * @param options Validation options\n * @param level The current depth of the traversal. This is used to decide\n * whether deletes are allowed in conjunction with `allowDeletes: root`.\n * @param inArray Whether we are inside an array.\n * @returns 'true' when the object is valid.\n * @throws when the object is invalid.\n */\n\nfunction validateFieldValue(val, options, path, level, inArray) {\n  if (path && path.size > MAX_DEPTH) {\n    throw new Error(\"Input object is deeper than \".concat(MAX_DEPTH, \" levels or contains a cycle.\"));\n  }\n\n  level = level || 0;\n  inArray = inArray || false;\n  var fieldPathMessage = path ? \" (found in field \".concat(path.toString(), \")\") : '';\n\n  if (Array.isArray(val)) {\n    var arr = val;\n\n    for (var i = 0; i < arr.length; ++i) {\n      validateFieldValue(arr[i], options, path ? path.append(String(i)) : new path_1.FieldPath(String(i)), level + 1,\n      /* inArray= */\n      true);\n    }\n  } else if (serializer_1.isPlainObject(val)) {\n    var obj = val;\n\n    for (var prop in obj) {\n      if (obj.hasOwnProperty(prop)) {\n        validateFieldValue(obj[prop], options, path ? path.append(new path_1.FieldPath(prop)) : new path_1.FieldPath(prop), level + 1, inArray);\n      }\n    }\n  } else if (val === undefined) {\n    throw new Error(\"Cannot use \\\"undefined\\\" as a Firestore value\".concat(fieldPathMessage, \".\"));\n  } else if (val instanceof field_value_1.DeleteTransform) {\n    if (inArray) {\n      throw new Error(\"\".concat(val.methodName, \"() cannot be used inside of an array\").concat(fieldPathMessage, \".\"));\n    } else if (options.allowDeletes === 'root' && level !== 0 || options.allowDeletes === 'none') {\n      throw new Error(\"\".concat(val.methodName, \"() must appear at the top-level and can only be used in update() or set() with {merge:true}\").concat(fieldPathMessage, \".\"));\n    }\n  } else if (val instanceof field_value_1.FieldTransform) {\n    if (inArray) {\n      throw new Error(\"\".concat(val.methodName, \"() cannot be used inside of an array\").concat(fieldPathMessage, \".\"));\n    } else if (!options.allowTransforms) {\n      throw new Error(\"\".concat(val.methodName, \"() can only be used in set(), create() or update()\").concat(fieldPathMessage, \".\"));\n    }\n  } else if (val instanceof reference_2.DocumentReference) {\n    return true;\n  } else if (val instanceof geo_point_1.GeoPoint) {\n    return true;\n  } else if (val instanceof timestamp_1.Timestamp) {\n    return true;\n  } else if (val instanceof path_1.FieldPath) {\n    throw new Error(\"Cannot use object of type \\\"FieldPath\\\" as a Firestore value\".concat(fieldPathMessage, \".\"));\n  } else if (is.object(val)) {\n    throw validate_1.customObjectError(val, path);\n  }\n\n  return true;\n}\n/**\n * Validates a JavaScript object for usage as a Firestore document.\n *\n * @private\n * @param obj JavaScript object to validate.\n * @param options Validation options\n * @returns 'true' when the object is valid.\n * @throws when the object is invalid.\n */\n\n\nfunction validateDocumentData(obj, options) {\n  if (!serializer_1.isPlainObject(obj)) {\n    throw validate_1.customObjectError(obj);\n  }\n\n  options = options || {};\n  var isEmpty = true;\n\n  for (var prop in obj) {\n    if (obj.hasOwnProperty(prop)) {\n      isEmpty = false;\n      validateFieldValue(obj[prop], options, new path_1.FieldPath(prop));\n    }\n  }\n\n  if (options.allowEmpty === false && isEmpty) {\n    throw new Error('At least one field must be updated.');\n  }\n\n  return true;\n}\n/**\n * Validates the use of 'options' as ReadOptions and enforces that 'fieldMask'\n * is an array of strings or field paths.\n *\n * @private\n * @param options.fieldMask - The subset of fields to return from a read\n * operation.\n */\n\n\nfunction validateReadOptions(options) {\n  if (!is.object(options)) {\n    throw new Error('Input is not an object.');\n  }\n\n  if (options.fieldMask === undefined) {\n    return true;\n  }\n\n  if (!Array.isArray(options.fieldMask)) {\n    throw new Error('\"fieldMask\" is not an array.');\n  }\n\n  for (var i = 0; i < options.fieldMask.length; ++i) {\n    try {\n      path_1.FieldPath.validateFieldPath(options.fieldMask[i]);\n    } catch (err) {\n      throw new Error(\"Element at index \".concat(i, \" is not a valid FieldPath. \").concat(err.message));\n    }\n  }\n\n  return true;\n}\n\nexports.validateReadOptions = validateReadOptions;\n/**\n * A logging function that takes a single string.\n *\n * @callback Firestore~logFunction\n * @param {string} Log message\n */\n// tslint:disable-next-line:no-default-export\n\n/**\n * The default export of the `@google-cloud/firestore` package is the\n * {@link Firestore} class.\n *\n * See {@link Firestore} and {@link ClientConfig} for client methods and\n * configuration options.\n *\n * @module {Firestore} @google-cloud/firestore\n * @alias nodejs-firestore\n *\n * @example <caption>Install the client library with <a\n * href=\"https://www.npmjs.com/\">npm</a>:</caption> npm install --save\n * @google-cloud/firestore\n *\n * @example <caption>Import the client library</caption>\n * var Firestore = require('@google-cloud/firestore');\n *\n * @example <caption>Create a client that uses <a\n * href=\"https://cloud.google.com/docs/authentication/production#providing_credentials_to_your_application\">Application\n * Default Credentials (ADC)</a>:</caption> var firestore = new Firestore();\n *\n * @example <caption>Create a client with <a\n * href=\"https://cloud.google.com/docs/authentication/production#obtaining_and_providing_service_account_credentials_manually\">explicit\n * credentials</a>:</caption> var firestore = new Firestore({ projectId:\n * 'your-project-id', keyFilename: '/path/to/keyfile.json'\n * });\n *\n * @example <caption>include:samples/quickstart.js</caption>\n * region_tag:firestore_quickstart\n * Full quickstart example:\n */\n// tslint:disable-next-line:no-default-export\n\nexports.default = Firestore; // Horrible hack to ensure backwards compatibility with <= 17.0, which allows\n// users to call the default constructor via\n// `const Fs = require(`@google-cloud/firestore`); new Fs()`;\n\nvar existingExports = module.exports;\nmodule.exports = Firestore;\nmodule.exports = Object.assign(module.exports, existingExports);\n/**\n * {@link v1beta1} factory function.\n *\n * @private\n * @name Firestore.v1beta1\n * @see v1beta1\n * @type {function}\n */\n\nObject.defineProperty(module.exports, 'v1beta1', {\n  // The v1beta1 module is very large. To avoid pulling it in from static\n  // scope, we lazy-load and cache the module.\n  get: function get() {\n    if (!v1beta1) {\n      v1beta1 = require('./v1beta1');\n    }\n\n    return v1beta1;\n  }\n});","map":null,"metadata":{},"sourceType":"script"}