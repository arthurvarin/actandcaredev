{"ast":null,"code":"\"use strict\";\n/**\n * Copyright 2012 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nvar __extends = this && this.__extends || function () {\n  var extendStatics = Object.setPrototypeOf || {\n    __proto__: []\n  } instanceof Array && function (d, b) {\n    d.__proto__ = b;\n  } || function (d, b) {\n    for (var p in b) {\n      if (b.hasOwnProperty(p)) d[p] = b[p];\n    }\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : new P(function (resolve) {\n        resolve(result.value);\n      }).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nvar __generator = this && this.__generator || function (thisArg, body) {\n  var _ = {\n    label: 0,\n    sent: function sent() {\n      if (t[0] & 1) throw t[1];\n      return t[1];\n    },\n    trys: [],\n    ops: []\n  },\n      f,\n      y,\n      t,\n      g;\n  return g = {\n    next: verb(0),\n    \"throw\": verb(1),\n    \"return\": verb(2)\n  }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function () {\n    return this;\n  }), g;\n\n  function verb(n) {\n    return function (v) {\n      return step([n, v]);\n    };\n  }\n\n  function step(op) {\n    if (f) throw new TypeError(\"Generator is already executing.\");\n\n    while (_) {\n      try {\n        if (f = 1, y && (t = y[op[0] & 2 ? \"return\" : op[0] ? \"throw\" : \"next\"]) && !(t = t.call(y, op[1])).done) return t;\n        if (y = 0, t) op = [0, t.value];\n\n        switch (op[0]) {\n          case 0:\n          case 1:\n            t = op;\n            break;\n\n          case 4:\n            _.label++;\n            return {\n              value: op[1],\n              done: false\n            };\n\n          case 5:\n            _.label++;\n            y = op[1];\n            op = [0];\n            continue;\n\n          case 7:\n            op = _.ops.pop();\n\n            _.trys.pop();\n\n            continue;\n\n          default:\n            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n              _ = 0;\n              continue;\n            }\n\n            if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n              _.label = op[1];\n              break;\n            }\n\n            if (op[0] === 6 && _.label < t[1]) {\n              _.label = t[1];\n              t = op;\n              break;\n            }\n\n            if (t && _.label < t[2]) {\n              _.label = t[2];\n\n              _.ops.push(op);\n\n              break;\n            }\n\n            if (t[2]) _.ops.pop();\n\n            _.trys.pop();\n\n            continue;\n        }\n\n        op = body.call(thisArg, _);\n      } catch (e) {\n        op = [6, e];\n        y = 0;\n      } finally {\n        f = t = 0;\n      }\n    }\n\n    if (op[0] & 5) throw op[1];\n    return {\n      value: op[0] ? op[1] : void 0,\n      done: true\n    };\n  }\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) {\n    if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\n  }\n  result[\"default\"] = mod;\n  return result;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar crypto_1 = __importDefault(require(\"crypto\"));\n\nvar querystring_1 = __importDefault(require(\"querystring\"));\n\nvar stream = __importStar(require(\"stream\"));\n\nvar pemverifier_1 = require(\"./../pemverifier\");\n\nvar authclient_1 = require(\"./authclient\");\n\nvar loginticket_1 = require(\"./loginticket\");\n\nvar CodeChallengeMethod;\n\n(function (CodeChallengeMethod) {\n  CodeChallengeMethod[\"Plain\"] = \"plain\";\n  CodeChallengeMethod[\"S256\"] = \"S256\";\n})(CodeChallengeMethod = exports.CodeChallengeMethod || (exports.CodeChallengeMethod = {}));\n\nvar OAuth2Client =\n/** @class */\nfunction (_super) {\n  __extends(OAuth2Client, _super);\n\n  function OAuth2Client(optionsOrClientId, clientSecret, redirectUri, authClientOpts) {\n    if (authClientOpts === void 0) {\n      authClientOpts = {};\n    }\n\n    var _this = _super.call(this) || this;\n\n    _this.certificateCache = null;\n    _this.certificateExpiry = null;\n    _this.refreshTokenPromises = new Map();\n    var opts = optionsOrClientId && typeof optionsOrClientId === 'object' ? optionsOrClientId : {\n      clientId: optionsOrClientId,\n      clientSecret: clientSecret,\n      redirectUri: redirectUri,\n      tokenUrl: authClientOpts.tokenUrl,\n      authBaseUrl: authClientOpts.authBaseUrl\n    };\n    _this._clientId = opts.clientId;\n    _this._clientSecret = opts.clientSecret;\n    _this.redirectUri = opts.redirectUri;\n    _this.authBaseUrl = opts.authBaseUrl;\n    _this.tokenUrl = opts.tokenUrl;\n    _this.eagerRefreshThresholdMillis = opts.eagerRefreshThresholdMillis || 5 * 60 * 1000;\n    return _this;\n  }\n  /**\n   * Generates URL for consent page landing.\n   * @param opts Options.\n   * @return URL to consent page.\n   */\n\n\n  OAuth2Client.prototype.generateAuthUrl = function (opts) {\n    if (opts === void 0) {\n      opts = {};\n    }\n\n    if (opts.code_challenge_method && !opts.code_challenge) {\n      throw new Error('If a code_challenge_method is provided, code_challenge must be included.');\n    }\n\n    opts.response_type = opts.response_type || 'code';\n    opts.client_id = opts.client_id || this._clientId;\n    opts.redirect_uri = opts.redirect_uri || this.redirectUri; // Allow scopes to be passed either as array or a string\n\n    if (opts.scope instanceof Array) {\n      opts.scope = opts.scope.join(' ');\n    }\n\n    var rootUrl = this.authBaseUrl || OAuth2Client.GOOGLE_OAUTH2_AUTH_BASE_URL_;\n    return rootUrl + '?' + querystring_1.default.stringify(opts);\n  };\n  /**\n   * Convenience method to automatically generate a code_verifier, and it's\n   * resulting SHA256. If used, this must be paired with a S256\n   * code_challenge_method.\n   */\n\n\n  OAuth2Client.prototype.generateCodeVerifier = function () {\n    // base64 encoding uses 6 bits per character, and we want to generate128\n    // characters. 6*128/8 = 96.\n    var randomString = crypto_1.default.randomBytes(96).toString('base64'); // The valid characters in the code_verifier are [A-Z]/[a-z]/[0-9]/\n    // \"-\"/\".\"/\"_\"/\"~\". Base64 encoded strings are pretty close, so we're just\n    // swapping out a few chars.\n\n    var codeVerifier = randomString.replace(/\\+/g, '~').replace(/=/g, '_').replace(/\\//g, '-'); // Generate the base64 encoded SHA256\n\n    var unencodedCodeChallenge = crypto_1.default.createHash('sha256').update(codeVerifier).digest('base64'); // We need to use base64UrlEncoding instead of standard base64\n\n    var codeChallenge = unencodedCodeChallenge.split('=')[0].replace(/\\+/g, '-').replace(/\\//g, '_');\n    return {\n      codeVerifier: codeVerifier,\n      codeChallenge: codeChallenge\n    };\n  };\n\n  OAuth2Client.prototype.getToken = function (codeOrOptions, callback) {\n    var options = typeof codeOrOptions === 'string' ? {\n      code: codeOrOptions\n    } : codeOrOptions;\n\n    if (callback) {\n      this.getTokenAsync(options).then(function (r) {\n        return callback(null, r.tokens, r.res);\n      }).catch(function (e) {\n        return callback(e, null, e.response);\n      });\n    } else {\n      return this.getTokenAsync(options);\n    }\n  };\n\n  OAuth2Client.prototype.getTokenAsync = function (options) {\n    return __awaiter(this, void 0, void 0, function () {\n      var url, values, res, tokens;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            url = this.tokenUrl || OAuth2Client.GOOGLE_OAUTH2_TOKEN_URL_;\n            values = {\n              code: options.code,\n              client_id: options.client_id || this._clientId,\n              client_secret: this._clientSecret,\n              redirect_uri: options.redirect_uri || this.redirectUri,\n              grant_type: 'authorization_code',\n              code_verifier: options.codeVerifier\n            };\n            return [4\n            /*yield*/\n            , this.transporter.request({\n              method: 'POST',\n              url: url,\n              data: querystring_1.default.stringify(values),\n              headers: {\n                'Content-Type': 'application/x-www-form-urlencoded'\n              }\n            })];\n\n          case 1:\n            res = _a.sent();\n            tokens = res.data;\n\n            if (res.data && res.data.expires_in) {\n              tokens.expiry_date = new Date().getTime() + res.data.expires_in * 1000;\n              delete tokens.expires_in;\n            }\n\n            this.emit('tokens', tokens);\n            return [2\n            /*return*/\n            , {\n              tokens: tokens,\n              res: res\n            }];\n        }\n      });\n    });\n  };\n  /**\n   * Refreshes the access token.\n   * @param refresh_token Existing refresh token.\n   * @private\n   */\n\n\n  OAuth2Client.prototype.refreshToken = function (refreshToken) {\n    return __awaiter(this, void 0, void 0, function () {\n      var p;\n\n      var _this = this;\n\n      return __generator(this, function (_a) {\n        if (!refreshToken) {\n          return [2\n          /*return*/\n          , this.refreshTokenNoCache(refreshToken)];\n        } // If a request to refresh using the same token has started,\n        // return the same promise.\n\n\n        if (this.refreshTokenPromises.has(refreshToken)) {\n          return [2\n          /*return*/\n          , this.refreshTokenPromises.get(refreshToken)];\n        }\n\n        p = this.refreshTokenNoCache(refreshToken).then(function (r) {\n          _this.refreshTokenPromises.delete(refreshToken);\n\n          return r;\n        }).catch(function (e) {\n          _this.refreshTokenPromises.delete(refreshToken);\n\n          throw e;\n        });\n        this.refreshTokenPromises.set(refreshToken, p);\n        return [2\n        /*return*/\n        , p];\n      });\n    });\n  };\n\n  OAuth2Client.prototype.refreshTokenNoCache = function (refreshToken) {\n    return __awaiter(this, void 0, void 0, function () {\n      var url, data, res, tokens;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            url = this.tokenUrl || OAuth2Client.GOOGLE_OAUTH2_TOKEN_URL_;\n            data = {\n              refresh_token: refreshToken,\n              client_id: this._clientId,\n              client_secret: this._clientSecret,\n              grant_type: 'refresh_token'\n            };\n            return [4\n            /*yield*/\n            , this.transporter.request({\n              method: 'POST',\n              url: url,\n              data: querystring_1.default.stringify(data),\n              headers: {\n                'Content-Type': 'application/x-www-form-urlencoded'\n              }\n            })];\n\n          case 1:\n            res = _a.sent();\n            tokens = res.data; // TODO: de-duplicate this code from a few spots\n\n            if (res.data && res.data.expires_in) {\n              tokens.expiry_date = new Date().getTime() + res.data.expires_in * 1000;\n              delete tokens.expires_in;\n            }\n\n            this.emit('tokens', tokens);\n            return [2\n            /*return*/\n            , {\n              tokens: tokens,\n              res: res\n            }];\n        }\n      });\n    });\n  };\n\n  OAuth2Client.prototype.refreshAccessToken = function (callback) {\n    if (callback) {\n      this.refreshAccessTokenAsync().then(function (r) {\n        return callback(null, r.credentials, r.res);\n      }).catch(callback);\n    } else {\n      return this.refreshAccessTokenAsync();\n    }\n  };\n\n  OAuth2Client.prototype.refreshAccessTokenAsync = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var r, tokens;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            if (!this.credentials.refresh_token) {\n              throw new Error('No refresh token is set.');\n            }\n\n            return [4\n            /*yield*/\n            , this.refreshToken(this.credentials.refresh_token)];\n\n          case 1:\n            r = _a.sent();\n            tokens = r.tokens;\n            tokens.refresh_token = this.credentials.refresh_token;\n            this.credentials = tokens;\n            return [2\n            /*return*/\n            , {\n              credentials: this.credentials,\n              res: r.res\n            }];\n        }\n      });\n    });\n  };\n\n  OAuth2Client.prototype.getAccessToken = function (callback) {\n    if (callback) {\n      this.getAccessTokenAsync().then(function (r) {\n        return callback(null, r.token, r.res);\n      }).catch(callback);\n    } else {\n      return this.getAccessTokenAsync();\n    }\n  };\n\n  OAuth2Client.prototype.getAccessTokenAsync = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var shouldRefresh, r;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            shouldRefresh = !this.credentials.access_token || this.isTokenExpiring();\n            if (!(shouldRefresh && this.credentials.refresh_token)) return [3\n            /*break*/\n            , 2];\n\n            if (!this.credentials.refresh_token) {\n              throw new Error('No refresh token is set.');\n            }\n\n            return [4\n            /*yield*/\n            , this.refreshAccessToken()];\n\n          case 1:\n            r = _a.sent();\n\n            if (!r.credentials || r.credentials && !r.credentials.access_token) {\n              throw new Error('Could not refresh access token.');\n            }\n\n            return [2\n            /*return*/\n            , {\n              token: r.credentials.access_token,\n              res: r.res\n            }];\n\n          case 2:\n            return [2\n            /*return*/\n            , {\n              token: this.credentials.access_token\n            }];\n        }\n      });\n    });\n  };\n\n  OAuth2Client.prototype.getRequestMetadata = function (url, callback) {\n    if (callback) {\n      this.getRequestMetadataAsync(url).then(function (r) {\n        return callback(null, r.headers, r.res);\n      }).catch(callback);\n    } else {\n      return this.getRequestMetadataAsync(url);\n    }\n  };\n\n  OAuth2Client.prototype.getRequestMetadataAsync = function (url) {\n    return __awaiter(this, void 0, void 0, function () {\n      var thisCreds, headers_1, r, tokens, err_1, e, credentials, headers;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            thisCreds = this.credentials;\n\n            if (!thisCreds.access_token && !thisCreds.refresh_token && !this.apiKey) {\n              throw new Error('No access, refresh token or API key is set.');\n            }\n\n            if (thisCreds.access_token && !this.isTokenExpiring()) {\n              thisCreds.token_type = thisCreds.token_type || 'Bearer';\n              headers_1 = {\n                Authorization: thisCreds.token_type + ' ' + thisCreds.access_token\n              };\n              return [2\n              /*return*/\n              , {\n                headers: headers_1\n              }];\n            }\n\n            if (this.apiKey) {\n              return [2\n              /*return*/\n              , {\n                headers: {}\n              }];\n            }\n\n            r = null;\n            tokens = null;\n            _a.label = 1;\n\n          case 1:\n            _a.trys.push([1, 3,, 4]);\n\n            return [4\n            /*yield*/\n            , this.refreshToken(thisCreds.refresh_token)];\n\n          case 2:\n            r = _a.sent();\n            tokens = r.tokens;\n            return [3\n            /*break*/\n            , 4];\n\n          case 3:\n            err_1 = _a.sent();\n            e = err_1;\n\n            if (e.response && (e.response.status === 403 || e.response.status === 404)) {\n              e.message = 'Could not refresh access token.';\n            }\n\n            throw e;\n\n          case 4:\n            credentials = this.credentials;\n            credentials.token_type = credentials.token_type || 'Bearer';\n            tokens.refresh_token = credentials.refresh_token;\n            this.credentials = tokens;\n            headers = {\n              Authorization: credentials.token_type + ' ' + tokens.access_token\n            };\n            return [2\n            /*return*/\n            , {\n              headers: headers,\n              res: r.res\n            }];\n        }\n      });\n    });\n  };\n\n  OAuth2Client.prototype.revokeToken = function (token, callback) {\n    var opts = {\n      url: OAuth2Client.GOOGLE_OAUTH2_REVOKE_URL_ + '?' + querystring_1.default.stringify({\n        token: token\n      })\n    };\n\n    if (callback) {\n      this.transporter.request(opts).then(function (res) {\n        callback(null, res);\n      }).catch(callback);\n    } else {\n      return this.transporter.request(opts);\n    }\n  };\n\n  OAuth2Client.prototype.revokeCredentials = function (callback) {\n    if (callback) {\n      this.revokeCredentialsAsync().then(function (res) {\n        return callback(null, res);\n      }).catch(callback);\n    } else {\n      return this.revokeCredentialsAsync();\n    }\n  };\n\n  OAuth2Client.prototype.revokeCredentialsAsync = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var token;\n      return __generator(this, function (_a) {\n        token = this.credentials.access_token;\n        this.credentials = {};\n\n        if (token) {\n          return [2\n          /*return*/\n          , this.revokeToken(token)];\n        } else {\n          throw new Error('No access token to revoke.');\n        }\n\n        return [2\n        /*return*/\n        ];\n      });\n    });\n  };\n\n  OAuth2Client.prototype.request = function (opts, callback) {\n    if (callback) {\n      this.requestAsync(opts).then(function (r) {\n        return callback(null, r);\n      }).catch(function (e) {\n        var err = e;\n        var body = err.response ? err.response.data : null;\n        return callback(e, err.response);\n      });\n    } else {\n      return this.requestAsync(opts);\n    }\n  };\n\n  OAuth2Client.prototype.requestAsync = function (opts, retry) {\n    if (retry === void 0) {\n      retry = false;\n    }\n\n    return __awaiter(this, void 0, void 0, function () {\n      var r2, r, e_1, res, statusCode, mayRequireRefresh, isReadableStream, isAuthErr;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            _a.trys.push([0, 3,, 6]);\n\n            return [4\n            /*yield*/\n            , this.getRequestMetadataAsync(opts.url)];\n\n          case 1:\n            r = _a.sent();\n\n            if (r.headers && r.headers.Authorization) {\n              opts.headers = opts.headers || {};\n              opts.headers.Authorization = r.headers.Authorization;\n            }\n\n            if (this.apiKey) {\n              opts.params = Object.assign(opts.params || {}, {\n                key: this.apiKey\n              });\n            }\n\n            return [4\n            /*yield*/\n            , this.transporter.request(opts)];\n\n          case 2:\n            r2 = _a.sent();\n            return [3\n            /*break*/\n            , 6];\n\n          case 3:\n            e_1 = _a.sent();\n            res = e_1.response;\n            if (!res) return [3\n            /*break*/\n            , 5];\n            statusCode = res.status;\n            mayRequireRefresh = this.credentials && this.credentials.access_token && this.credentials.refresh_token && !this.credentials.expiry_date;\n            isReadableStream = res.config.data instanceof stream.Readable;\n            isAuthErr = statusCode === 401 || statusCode === 403;\n            if (!(!retry && isAuthErr && !isReadableStream && mayRequireRefresh)) return [3\n            /*break*/\n            , 5];\n            return [4\n            /*yield*/\n            , this.refreshAccessTokenAsync()];\n\n          case 4:\n            _a.sent();\n\n            return [2\n            /*return*/\n            , this.requestAsync(opts, true)];\n\n          case 5:\n            throw e_1;\n\n          case 6:\n            return [2\n            /*return*/\n            , r2];\n        }\n      });\n    });\n  };\n\n  OAuth2Client.prototype.verifyIdToken = function (options, callback) {\n    // This function used to accept two arguments instead of an options object.\n    // Check the types to help users upgrade with less pain.\n    // This check can be removed after a 2.0 release.\n    if (callback && typeof callback !== 'function') {\n      throw new Error('This method accepts an options object as the first parameter, which includes the idToken, audience, and maxExpiry.');\n    }\n\n    if (callback) {\n      this.verifyIdTokenAsync(options).then(function (r) {\n        return callback(null, r);\n      }).catch(callback);\n    } else {\n      return this.verifyIdTokenAsync(options);\n    }\n  };\n\n  OAuth2Client.prototype.verifyIdTokenAsync = function (options) {\n    return __awaiter(this, void 0, void 0, function () {\n      var response, login;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            if (!options.idToken) {\n              throw new Error('The verifyIdToken method requires an ID Token');\n            }\n\n            return [4\n            /*yield*/\n            , this.getFederatedSignonCertsAsync()];\n\n          case 1:\n            response = _a.sent();\n            login = this.verifySignedJwtWithCerts(options.idToken, response.certs, options.audience, OAuth2Client.ISSUERS_, options.maxExpiry);\n            return [2\n            /*return*/\n            , login];\n        }\n      });\n    });\n  };\n  /**\n   * Obtains information about the provisioned access token.  Especially useful\n   * if you want to check the scopes that were provisioned to a given token.\n   *\n   * @param accessToken Required.  The Access Token for which you want to get\n   * user info.\n   */\n\n\n  OAuth2Client.prototype.getTokenInfo = function (accessToken) {\n    return __awaiter(this, void 0, void 0, function () {\n      var data, info;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , this.transporter.request({\n              method: 'GET',\n              url: OAuth2Client.GOOGLE_TOKEN_INFO_URL,\n              params: {\n                access_token: accessToken\n              }\n            })];\n\n          case 1:\n            data = _a.sent().data;\n            info = Object.assign({\n              expiry_date: new Date().getTime() + data.expires_in * 1000,\n              scopes: data.scope.split(' ')\n            }, data);\n            delete info.expires_in;\n            delete info.scope;\n            return [2\n            /*return*/\n            , info];\n        }\n      });\n    });\n  };\n\n  OAuth2Client.prototype.getFederatedSignonCerts = function (callback) {\n    if (callback) {\n      this.getFederatedSignonCertsAsync().then(function (r) {\n        return callback(null, r.certs, r.res);\n      }).catch(callback);\n    } else {\n      return this.getFederatedSignonCertsAsync();\n    }\n  };\n\n  OAuth2Client.prototype.getFederatedSignonCertsAsync = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var nowTime, res, e_2, cacheControl, cacheAge, pattern, regexResult, now;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            nowTime = new Date().getTime();\n\n            if (this.certificateExpiry && nowTime < this.certificateExpiry.getTime()) {\n              return [2\n              /*return*/\n              , {\n                certs: this.certificateCache\n              }];\n            }\n\n            _a.label = 1;\n\n          case 1:\n            _a.trys.push([1, 3,, 4]);\n\n            return [4\n            /*yield*/\n            , this.transporter.request({\n              url: OAuth2Client.GOOGLE_OAUTH2_FEDERATED_SIGNON_CERTS_URL_\n            })];\n\n          case 2:\n            res = _a.sent();\n            return [3\n            /*break*/\n            , 4];\n\n          case 3:\n            e_2 = _a.sent();\n            throw new Error('Failed to retrieve verification certificates: ' + e_2);\n\n          case 4:\n            cacheControl = res ? res.headers['cache-control'] : undefined;\n            cacheAge = -1;\n\n            if (cacheControl) {\n              pattern = new RegExp('max-age=([0-9]*)');\n              regexResult = pattern.exec(cacheControl);\n\n              if (regexResult && regexResult.length === 2) {\n                // Cache results with max-age (in seconds)\n                cacheAge = Number(regexResult[1]) * 1000; // milliseconds\n              }\n            }\n\n            now = new Date();\n            this.certificateExpiry = cacheAge === -1 ? null : new Date(now.getTime() + cacheAge);\n            this.certificateCache = res.data;\n            return [2\n            /*return*/\n            , {\n              certs: res.data,\n              res: res\n            }];\n        }\n      });\n    });\n  };\n  /**\n   * Verify the id token is signed with the correct certificate\n   * and is from the correct audience.\n   * @param jwt The jwt to verify (The ID Token in this case).\n   * @param certs The array of certs to test the jwt against.\n   * @param requiredAudience The audience to test the jwt against.\n   * @param issuers The allowed issuers of the jwt (Optional).\n   * @param maxExpiry The max expiry the certificate can be (Optional).\n   * @return Returns a LoginTicket on verification.\n   */\n\n\n  OAuth2Client.prototype.verifySignedJwtWithCerts = function (jwt, certs, requiredAudience, issuers, maxExpiry) {\n    if (!maxExpiry) {\n      maxExpiry = OAuth2Client.MAX_TOKEN_LIFETIME_SECS_;\n    }\n\n    var segments = jwt.split('.');\n\n    if (segments.length !== 3) {\n      throw new Error('Wrong number of segments in token: ' + jwt);\n    }\n\n    var signed = segments[0] + '.' + segments[1];\n    var signature = segments[2];\n    var envelope;\n    var payload;\n\n    try {\n      envelope = JSON.parse(this.decodeBase64(segments[0]));\n    } catch (err) {\n      throw new Error('Can\\'t parse token envelope: ' + segments[0]);\n    }\n\n    if (!envelope) {\n      throw new Error('Can\\'t parse token envelope: ' + segments[0]);\n    }\n\n    try {\n      payload = JSON.parse(this.decodeBase64(segments[1]));\n    } catch (err) {\n      throw new Error('Can\\'t parse token payload: ' + segments[0]);\n    }\n\n    if (!payload) {\n      throw new Error('Can\\'t parse token payload: ' + segments[1]);\n    }\n\n    if (!certs.hasOwnProperty(envelope.kid)) {\n      // If this is not present, then there's no reason to attempt verification\n      throw new Error('No pem found for envelope: ' + JSON.stringify(envelope));\n    } // certs is a legit dynamic object\n    // tslint:disable-next-line no-any\n\n\n    var pem = certs[envelope.kid];\n    var pemVerifier = new pemverifier_1.PemVerifier();\n    var verified = pemVerifier.verify(pem, signed, signature, 'base64');\n\n    if (!verified) {\n      throw new Error('Invalid token signature: ' + jwt);\n    }\n\n    if (!payload.iat) {\n      throw new Error('No issue time in token: ' + JSON.stringify(payload));\n    }\n\n    if (!payload.exp) {\n      throw new Error('No expiration time in token: ' + JSON.stringify(payload));\n    }\n\n    var iat = Number(payload.iat);\n    if (isNaN(iat)) throw new Error('iat field using invalid format');\n    var exp = Number(payload.exp);\n    if (isNaN(exp)) throw new Error('exp field using invalid format');\n    var now = new Date().getTime() / 1000;\n\n    if (exp >= now + maxExpiry) {\n      throw new Error('Expiration time too far in future: ' + JSON.stringify(payload));\n    }\n\n    var earliest = iat - OAuth2Client.CLOCK_SKEW_SECS_;\n    var latest = exp + OAuth2Client.CLOCK_SKEW_SECS_;\n\n    if (now < earliest) {\n      throw new Error('Token used too early, ' + now + ' < ' + earliest + ': ' + JSON.stringify(payload));\n    }\n\n    if (now > latest) {\n      throw new Error('Token used too late, ' + now + ' > ' + latest + ': ' + JSON.stringify(payload));\n    }\n\n    if (issuers && issuers.indexOf(payload.iss) < 0) {\n      throw new Error('Invalid issuer, expected one of [' + issuers + '], but got ' + payload.iss);\n    } // Check the audience matches if we have one\n\n\n    if (typeof requiredAudience !== 'undefined' && requiredAudience !== null) {\n      var aud = payload.aud;\n      var audVerified = false; // If the requiredAudience is an array, check if it contains token\n      // audience\n\n      if (requiredAudience.constructor === Array) {\n        audVerified = requiredAudience.indexOf(aud) > -1;\n      } else {\n        audVerified = aud === requiredAudience;\n      }\n\n      if (!audVerified) {\n        throw new Error('Wrong recipient, payload audience != requiredAudience');\n      }\n    }\n\n    return new loginticket_1.LoginTicket(envelope, payload);\n  };\n  /**\n   * This is a utils method to decode a base64 string\n   * @param b64String The string to base64 decode\n   * @return The decoded string\n   */\n\n\n  OAuth2Client.prototype.decodeBase64 = function (b64String) {\n    var buffer = new Buffer(b64String, 'base64');\n    return buffer.toString('utf8');\n  };\n  /**\n   * Returns true if a token is expired or will expire within\n   * eagerRefreshThresholdMillismilliseconds.\n   * If there is no expiry time, assumes the token is not expired or expiring.\n   */\n\n\n  OAuth2Client.prototype.isTokenExpiring = function () {\n    var expiryDate = this.credentials.expiry_date;\n    return expiryDate ? expiryDate <= new Date().getTime() + this.eagerRefreshThresholdMillis : false;\n  };\n\n  OAuth2Client.GOOGLE_TOKEN_INFO_URL = 'https://www.googleapis.com/oauth2/v3/tokeninfo';\n  /**\n   * The base URL for auth endpoints.\n   */\n\n  OAuth2Client.GOOGLE_OAUTH2_AUTH_BASE_URL_ = 'https://accounts.google.com/o/oauth2/v2/auth';\n  /**\n   * The base endpoint for token retrieval.\n   */\n\n  OAuth2Client.GOOGLE_OAUTH2_TOKEN_URL_ = 'https://www.googleapis.com/oauth2/v4/token';\n  /**\n   * The base endpoint to revoke tokens.\n   */\n\n  OAuth2Client.GOOGLE_OAUTH2_REVOKE_URL_ = 'https://accounts.google.com/o/oauth2/revoke';\n  /**\n   * Google Sign on certificates.\n   */\n\n  OAuth2Client.GOOGLE_OAUTH2_FEDERATED_SIGNON_CERTS_URL_ = 'https://www.googleapis.com/oauth2/v1/certs';\n  /**\n   * Clock skew - five minutes in seconds\n   */\n\n  OAuth2Client.CLOCK_SKEW_SECS_ = 300;\n  /**\n   * Max Token Lifetime is one day in seconds\n   */\n\n  OAuth2Client.MAX_TOKEN_LIFETIME_SECS_ = 86400;\n  /**\n   * The allowed oauth token issuers.\n   */\n\n  OAuth2Client.ISSUERS_ = ['accounts.google.com', 'https://accounts.google.com'];\n  return OAuth2Client;\n}(authclient_1.AuthClient);\n\nexports.OAuth2Client = OAuth2Client;","map":null,"metadata":{},"sourceType":"script"}