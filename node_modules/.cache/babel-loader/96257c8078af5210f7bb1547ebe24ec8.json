{"ast":null,"code":"\"use strict\";\n\nvar _classCallCheck = require(\"/Users/cvoisin/Repos/actandcaredev/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/cvoisin/Repos/actandcaredev/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _possibleConstructorReturn = require(\"/Users/cvoisin/Repos/actandcaredev/node_modules/@babel/runtime/helpers/possibleConstructorReturn\");\n\nvar _getPrototypeOf = require(\"/Users/cvoisin/Repos/actandcaredev/node_modules/@babel/runtime/helpers/getPrototypeOf\");\n\nvar _inherits = require(\"/Users/cvoisin/Repos/actandcaredev/node_modules/@babel/runtime/helpers/inherits\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar events_1 = require(\"events\");\n\nvar http2 = require(\"http2\");\n\nvar _http2$constants = http2.constants,\n    HTTP2_HEADER_AUTHORITY = _http2$constants.HTTP2_HEADER_AUTHORITY,\n    HTTP2_HEADER_CONTENT_TYPE = _http2$constants.HTTP2_HEADER_CONTENT_TYPE,\n    HTTP2_HEADER_METHOD = _http2$constants.HTTP2_HEADER_METHOD,\n    HTTP2_HEADER_PATH = _http2$constants.HTTP2_HEADER_PATH,\n    HTTP2_HEADER_TE = _http2$constants.HTTP2_HEADER_TE,\n    HTTP2_HEADER_USER_AGENT = _http2$constants.HTTP2_HEADER_USER_AGENT;\n/* setInterval and setTimeout only accept signed 32 bit integers. JS doesn't\n * have a constant for the max signed 32 bit integer, so this is a simple way\n * to calculate it */\n\nvar KEEPALIVE_TIME_MS = ~(1 << 31);\nvar KEEPALIVE_TIMEOUT_MS = 20000;\n\nvar Http2SubChannel =\n/*#__PURE__*/\nfunction (_events_1$EventEmitte) {\n  _inherits(Http2SubChannel, _events_1$EventEmitte);\n\n  function Http2SubChannel(target, connectionOptions, userAgent, channelArgs) {\n    var _this;\n\n    _classCallCheck(this, Http2SubChannel);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(Http2SubChannel).call(this));\n    _this.refCount = 0;\n    _this.keepaliveTimeMs = KEEPALIVE_TIME_MS;\n    _this.keepaliveTimeoutMs = KEEPALIVE_TIMEOUT_MS;\n    _this.session = http2.connect(target, connectionOptions);\n\n    _this.session.on('connect', function () {\n      _this.emit('connect');\n    });\n\n    _this.session.on('close', function () {\n      _this.stopKeepalivePings();\n\n      _this.emit('close');\n    });\n\n    _this.session.on('error', function () {\n      _this.stopKeepalivePings();\n\n      _this.emit('close');\n    });\n\n    _this.userAgent = userAgent;\n\n    if (channelArgs['grpc.keepalive_time_ms']) {\n      _this.keepaliveTimeMs = channelArgs['grpc.keepalive_time_ms'];\n    }\n\n    if (channelArgs['grpc.keepalive_timeout_ms']) {\n      _this.keepaliveTimeoutMs = channelArgs['grpc.keepalive_timeout_ms'];\n    }\n\n    _this.keepaliveIntervalId = setTimeout(function () {}, 0);\n    clearTimeout(_this.keepaliveIntervalId);\n    _this.keepaliveTimeoutId = setTimeout(function () {}, 0);\n    clearTimeout(_this.keepaliveTimeoutId);\n    return _this;\n  }\n\n  _createClass(Http2SubChannel, [{\n    key: \"ref\",\n    value: function ref() {\n      if (this.refCount === 0) {\n        this.session.ref();\n        this.startKeepalivePings();\n      }\n\n      this.refCount += 1;\n    }\n  }, {\n    key: \"unref\",\n    value: function unref() {\n      this.refCount -= 1;\n\n      if (this.refCount === 0) {\n        this.session.unref();\n        this.stopKeepalivePings();\n      }\n    }\n  }, {\n    key: \"sendPing\",\n    value: function sendPing() {\n      var _this2 = this;\n\n      this.keepaliveTimeoutId = setTimeout(function () {\n        _this2.emit('close');\n      }, this.keepaliveTimeoutMs);\n      this.session.ping(function (err, duration, payload) {\n        clearTimeout(_this2.keepaliveTimeoutId);\n      });\n    }\n    /* TODO(murgatroid99): refactor subchannels so that keepalives can be handled\n     * per subchannel */\n\n  }, {\n    key: \"startKeepalivePings\",\n    value: function startKeepalivePings() {\n      var _this3 = this;\n\n      this.keepaliveIntervalId = setInterval(function () {\n        _this3.sendPing();\n      }, this.keepaliveTimeMs);\n      this.sendPing();\n    }\n  }, {\n    key: \"stopKeepalivePings\",\n    value: function stopKeepalivePings() {\n      clearInterval(this.keepaliveIntervalId);\n      clearTimeout(this.keepaliveTimeoutId);\n    } // Prerequisite: this subchannel is connected\n\n  }, {\n    key: \"startCallStream\",\n    value: function startCallStream(metadata, callStream) {\n      var _this4 = this;\n\n      var headers = metadata.toHttp2Headers();\n      headers[HTTP2_HEADER_AUTHORITY] = callStream.getHost();\n      headers[HTTP2_HEADER_USER_AGENT] = this.userAgent;\n      headers[HTTP2_HEADER_CONTENT_TYPE] = 'application/grpc';\n      headers[HTTP2_HEADER_METHOD] = 'POST';\n      headers[HTTP2_HEADER_PATH] = callStream.getMethod();\n      headers[HTTP2_HEADER_TE] = 'trailers';\n      var http2Stream = this.session.request(headers);\n      this.ref();\n      http2Stream.on('close', function () {\n        _this4.unref();\n      });\n      callStream.attachHttp2Stream(http2Stream);\n    }\n  }, {\n    key: \"close\",\n    value: function close() {\n      this.session.close();\n    }\n  }]);\n\n  return Http2SubChannel;\n}(events_1.EventEmitter);\n\nexports.Http2SubChannel = Http2SubChannel;","map":null,"metadata":{},"sourceType":"script"}