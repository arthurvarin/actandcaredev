{"ast":null,"code":"\"use strict\";\n/*\n * Copyright 2016, Google Inc.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are\n * met:\n *\n *     * Redistributions of source code must retain the above copyright\n * notice, this list of conditions and the following disclaimer.\n *     * Redistributions in binary form must reproduce the above\n * copyright notice, this list of conditions and the following disclaimer\n * in the documentation and/or other materials provided with the\n * distribution.\n *     * Neither the name of Google Inc. nor the names of its\n * contributors may be used to endorse or promote products derived from\n * this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\n */\n\nvar _regeneratorRuntime = require(\"/Users/cvoisin/Repos/actandcaredev/node_modules/@babel/runtime/regenerator\");\n\nvar _createClass = require(\"/Users/cvoisin/Repos/actandcaredev/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _classCallCheck = require(\"/Users/cvoisin/Repos/actandcaredev/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _possibleConstructorReturn = require(\"/Users/cvoisin/Repos/actandcaredev/node_modules/@babel/runtime/helpers/possibleConstructorReturn\");\n\nvar _getPrototypeOf = require(\"/Users/cvoisin/Repos/actandcaredev/node_modules/@babel/runtime/helpers/getPrototypeOf\");\n\nvar _inherits = require(\"/Users/cvoisin/Repos/actandcaredev/node_modules/@babel/runtime/helpers/inherits\");\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : new P(function (resolve) {\n        resolve(result.value);\n      }).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar grpcProtoLoaderTypes = require(\"@grpc/proto-loader\"); // for types only\n\n\nvar fs = require(\"fs\");\n\nvar google_auth_library_1 = require(\"google-auth-library\");\n\nvar google_proto_files_1 = require(\"google-proto-files\");\n\nvar grpcTypes = require(\"grpc\"); // for types only\n\n\nvar path = require(\"path\");\n\nvar protobuf = require(\"protobufjs\");\n\nvar semver = require(\"semver\");\n\nvar walk = require(\"walkdir\");\n\nvar gax = require(\"./gax\");\n\nvar googleProtoFilesDir = path.normalize(google_proto_files_1.getProtoPath('..')); // INCLUDE_DIRS is passed to @grpc/proto-loader\n\nvar INCLUDE_DIRS = [];\nINCLUDE_DIRS.push(googleProtoFilesDir); // COMMON_PROTO_FILES logic is here for protobufjs loads (see\n// GoogleProtoFilesRoot below)\n\nvar COMMON_PROTO_DIRS = [// This list of directories is defined here:\n// https://github.com/googleapis/googleapis/blob/master/gapic/packaging/common_protos.yaml\n'api', path.join('iam', 'v1'), path.join('logging', 'type'), 'longrunning', 'protobuf', 'rpc', 'type'].map(function (dir) {\n  return path.join(googleProtoFilesDir, 'google', dir);\n});\nvar COMMON_PROTO_FILES = COMMON_PROTO_DIRS.map(function (dir) {\n  return walk.sync(dir).filter(function (f) {\n    return path.extname(f) === '.proto';\n  }).map(function (f) {\n    return path.normalize(f).substring(googleProtoFilesDir.length + 1);\n  });\n}).reduce(function (a, c) {\n  return a.concat(c);\n}, []);\n\nvar ClientStub =\n/*#__PURE__*/\nfunction (_grpcTypes$Client) {\n  _inherits(ClientStub, _grpcTypes$Client);\n\n  function ClientStub() {\n    _classCallCheck(this, ClientStub);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(ClientStub).apply(this, arguments));\n  }\n\n  return ClientStub;\n}(grpcTypes.Client);\n\nexports.ClientStub = ClientStub;\n\nvar GrpcClient =\n/*#__PURE__*/\nfunction () {\n  /**\n   * A class which keeps the context of gRPC and auth for the gRPC.\n   *\n   * @param {Object=} options - The optional parameters. It will be directly\n   *   passed to google-auth-library library, so parameters like keyFile or\n   *   credentials will be valid.\n   * @param {Object=} options.auth - An instance of google-auth-library.\n   *   When specified, this auth instance will be used instead of creating\n   *   a new one.\n   * @param {Object=} options.grpc - When specified, this will be used\n   *   for the 'grpc' module in this context. By default, it will load the grpc\n   *   module in the standard way.\n   * @param {Function=} options.promise - A constructor for a promise that\n   * implements the ES6 specification of promise. If not provided, native\n   * promises will be used.\n   * @constructor\n   */\n  function GrpcClient() {\n    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _classCallCheck(this, GrpcClient);\n\n    this.auth = options.auth || new google_auth_library_1.GoogleAuth(options);\n    this.promise = options.promise || Promise;\n\n    if ('grpc' in options) {\n      this.grpc = options.grpc;\n      this.grpcVersion = '';\n    } else {\n      // EXPERIMENTAL: If GOOGLE_CLOUD_USE_GRPC_JS is set, use the JS-based\n      // implementation of the gRPC client instead. Requires http2 (Node 8+).\n      if (semver.satisfies(process.version, '8.x') && process.env.GOOGLE_CLOUD_USE_GRPC_JS) {\n        this.grpc = require('@grpc/grpc-js');\n        this.grpcVersion = require('@grpc/grpc-js/package.json').version;\n      } else {\n        this.grpc = require('grpc');\n        this.grpcVersion = require('grpc/package.json').version;\n      }\n    }\n\n    this.grpcProtoLoader = require('@grpc/proto-loader');\n  }\n  /**\n   * Creates a gRPC credentials. It asks the auth data if necessary.\n   * @private\n   * @param {Object} opts - options values for configuring credentials.\n   * @param {Object=} opts.sslCreds - when specified, this is used instead\n   *   of default channel credentials.\n   * @return {Promise} The promise which will be resolved to the gRPC credential.\n   */\n\n\n  _createClass(GrpcClient, [{\n    key: \"_getCredentials\",\n    value: function _getCredentials(opts) {\n      return __awaiter(this, void 0, void 0,\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee() {\n        var grpc, sslCreds, client, credentials;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                if (!opts.sslCreds) {\n                  _context.next = 2;\n                  break;\n                }\n\n                return _context.abrupt(\"return\", opts.sslCreds);\n\n              case 2:\n                grpc = this.grpc;\n                sslCreds = grpc.credentials.createSsl();\n                _context.next = 6;\n                return this.auth.getClient();\n\n              case 6:\n                client = _context.sent;\n                credentials = grpc.credentials.combineChannelCredentials(sslCreds, grpc.credentials.createFromGoogleCredential(client));\n                return _context.abrupt(\"return\", credentials);\n\n              case 9:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n    }\n    /**\n     * Loads the gRPC service from the proto file at the given path and with the\n     * given options.\n     * @param filename The path to the proto file.\n     * @param options Options for loading the proto file.\n     */\n\n  }, {\n    key: \"loadFromProto\",\n    value: function loadFromProto(filename, options) {\n      var packageDef = grpcProtoLoaderTypes.loadSync(filename, options);\n      return this.grpc.loadPackageDefinition(packageDef);\n    }\n    /**\n     * Load grpc proto service from a filename hooking in googleapis common protos\n     * when necessary.\n     * @param {String} protoPath - The directory to search for the protofile.\n     * @param {String} filename - The filename of the proto to be loaded.\n     * @return {Object<string, *>} The gRPC loaded result (the toplevel namespace\n     *   object).\n     */\n\n  }, {\n    key: \"loadProto\",\n    value: function loadProto(protoPath, filename) {\n      var resolvedPath = GrpcClient._resolveFile(protoPath, filename);\n\n      var retval = this.grpc.loadObject(protobuf.loadSync(resolvedPath, new GoogleProtoFilesRoot()));\n      return retval;\n    }\n  }, {\n    key: \"metadataBuilder\",\n    value: function metadataBuilder(headers) {\n      var Metadata = this.grpc.Metadata;\n      var baseMetadata = new Metadata(); // tslint:disable-next-line forin\n\n      var _loop = function _loop(key) {\n        var value = headers[key];\n\n        if (Array.isArray(value)) {\n          value.forEach(function (v) {\n            return baseMetadata.add(key, v);\n          });\n        } else {\n          baseMetadata.set(key, \"\".concat(value));\n        }\n      };\n\n      for (var key in headers) {\n        _loop(key);\n      }\n\n      return function buildMetadata(abTests, moreHeaders) {\n        // TODO: bring the A/B testing info into the metadata.\n        var copied = false;\n        var metadata = baseMetadata;\n\n        if (moreHeaders) {\n          var _loop2 = function _loop2(key) {\n            if (key.toLowerCase() !== 'x-goog-api-client' && moreHeaders.hasOwnProperty(key)) {\n              if (!copied) {\n                copied = true;\n                metadata = metadata.clone();\n              }\n\n              var value = moreHeaders[key];\n\n              if (Array.isArray(value)) {\n                value.forEach(function (v) {\n                  return metadata.add(key, v);\n                });\n              } else {\n                metadata.set(key, \"\".concat(value));\n              }\n            }\n          };\n\n          for (var key in moreHeaders) {\n            _loop2(key);\n          }\n        }\n\n        return metadata;\n      };\n    }\n    /**\n     * A wrapper of {@link constructSettings} function under the gRPC context.\n     *\n     * Most of parameters are common among constructSettings, please take a look.\n     * @param {string} serviceName - The fullly-qualified name of the service.\n     * @param {Object} clientConfig - A dictionary of the client config.\n     * @param {Object} configOverrides - A dictionary of overriding configs.\n     * @param {Object} headers - A dictionary of additional HTTP header name to\n     *   its value.\n     * @return {Object} A mapping of method names to CallSettings.\n     */\n\n  }, {\n    key: \"constructSettings\",\n    value: function constructSettings(serviceName, clientConfig, configOverrides, headers) {\n      return gax.constructSettings(serviceName, clientConfig, configOverrides, this.grpc.status, {\n        metadataBuilder: this.metadataBuilder(headers)\n      }, this.promise);\n    }\n    /**\n     * Creates a gRPC stub with current gRPC and auth.\n     * @param {function} CreateStub - The constructor function of the stub.\n     * @param {Object} options - The optional arguments to customize\n     *   gRPC connection. This options will be passed to the constructor of\n     *   gRPC client too.\n     * @param {string} options.servicePath - The name of the server of the service.\n     * @param {number} options.port - The port of the service.\n     * @param {grpcTypes.ClientCredentials=} options.sslCreds - The credentials to be used\n     *   to set up gRPC connection.\n     * @return {Promise} A promse which resolves to a gRPC stub instance.\n     */\n    // tslint:disable-next-line variable-name\n\n  }, {\n    key: \"createStub\",\n    value: function createStub(CreateStub, options) {\n      var serviceAddress = options.servicePath + ':' + options.port;\n      return this._getCredentials(options).then(function (credentials) {\n        var grpcOptions = {};\n        Object.keys(options).forEach(function (key) {\n          if (key.indexOf('grpc.') === 0) {\n            grpcOptions[key] = options[key];\n          } else if (key.indexOf('grpc_gcp.') === 0) {\n            // This prefix is used to pass additional arguments that aren't\n            // options for grpc. Strip the prefix before passing.\n            var prefixLength = 'grpc_gcp.'.length;\n            grpcOptions[key.substr(prefixLength)] = options[key];\n          }\n        });\n        return new CreateStub(serviceAddress, credentials, grpcOptions);\n      });\n    }\n    /**\n     * Creates a 'bytelength' function for a given proto message class.\n     *\n     * See {@link BundleDescriptor} about the meaning of the return value.\n     *\n     * @param {function} message - a constructor function that is generated by\n     *   protobuf.js. Assumes 'encoder' field in the message.\n     * @return {function(Object):number} - a function to compute the byte length\n     *   for an object.\n     */\n\n  }], [{\n    key: \"_resolveFile\",\n    value: function _resolveFile(protoPath, filename) {\n      if (fs.existsSync(path.join(protoPath, filename))) {\n        return path.join(protoPath, filename);\n      } else if (COMMON_PROTO_FILES.indexOf(filename) > -1) {\n        return path.join(googleProtoFilesDir, filename);\n      }\n\n      throw new Error(filename + ' could not be found in ' + protoPath);\n    }\n  }, {\n    key: \"createByteLengthFunction\",\n    value: function createByteLengthFunction(message) {\n      return function getByteLength(obj) {\n        return message.encode(obj).finish().length;\n      };\n    }\n  }]);\n\n  return GrpcClient;\n}();\n\nexports.GrpcClient = GrpcClient;\n\nvar GoogleProtoFilesRoot =\n/*#__PURE__*/\nfunction (_protobuf$Root) {\n  _inherits(GoogleProtoFilesRoot, _protobuf$Root);\n\n  function GoogleProtoFilesRoot() {\n    var _getPrototypeOf2;\n\n    _classCallCheck(this, GoogleProtoFilesRoot);\n\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(GoogleProtoFilesRoot)).call.apply(_getPrototypeOf2, [this].concat(args)));\n  } // Causes the loading of an included proto to check if it is a common\n  // proto. If it is a common proto, use the google-proto-files proto.\n\n\n  _createClass(GoogleProtoFilesRoot, [{\n    key: \"resolvePath\",\n    value: function resolvePath(originPath, includePath) {\n      originPath = path.normalize(originPath);\n      includePath = path.normalize(includePath); // Fully qualified paths don't need to be resolved.\n\n      if (path.isAbsolute(includePath)) {\n        if (!fs.existsSync(includePath)) {\n          throw new Error('The include `' + includePath + '` was not found.');\n        }\n\n        return includePath;\n      }\n\n      if (COMMON_PROTO_FILES.indexOf(includePath) > -1) {\n        return path.join(googleProtoFilesDir, includePath);\n      }\n\n      return GoogleProtoFilesRoot._findIncludePath(originPath, includePath);\n    }\n  }], [{\n    key: \"_findIncludePath\",\n    value: function _findIncludePath(originPath, includePath) {\n      originPath = path.normalize(originPath);\n      includePath = path.normalize(includePath);\n      var current = originPath;\n      var found = fs.existsSync(path.join(current, includePath));\n\n      while (!found && current.length > 0) {\n        current = current.substring(0, current.lastIndexOf(path.sep));\n        found = fs.existsSync(path.join(current, includePath));\n      }\n\n      if (!found) {\n        throw new Error('The include `' + includePath + '` was not found.');\n      }\n\n      return path.join(current, includePath);\n    }\n  }]);\n\n  return GoogleProtoFilesRoot;\n}(protobuf.Root);\n\nexports.GoogleProtoFilesRoot = GoogleProtoFilesRoot;","map":null,"metadata":{},"sourceType":"script"}