{"ast":null,"code":"/*! firebase-admin v6.5.0 */\n\"use strict\";\n/*!\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar index_1 = require(\"../utils/index\");\n\nvar deep_copy_1 = require(\"../utils/deep-copy\");\n\nvar messaging_api_request_1 = require(\"./messaging-api-request\");\n\nvar error_1 = require(\"../utils/error\");\n\nvar utils = require(\"../utils\");\n\nvar validator = require(\"../utils/validator\"); // FCM endpoints\n\n\nvar FCM_SEND_HOST = 'fcm.googleapis.com';\nvar FCM_SEND_PATH = '/fcm/send';\nvar FCM_TOPIC_MANAGEMENT_HOST = 'iid.googleapis.com';\nvar FCM_TOPIC_MANAGEMENT_ADD_PATH = '/iid/v1:batchAdd';\nvar FCM_TOPIC_MANAGEMENT_REMOVE_PATH = '/iid/v1:batchRemove'; // Key renames for the messaging notification payload object.\n\nvar CAMELCASED_NOTIFICATION_PAYLOAD_KEYS_MAP = {\n  bodyLocArgs: 'body_loc_args',\n  bodyLocKey: 'body_loc_key',\n  clickAction: 'click_action',\n  titleLocArgs: 'title_loc_args',\n  titleLocKey: 'title_loc_key'\n}; // Key renames for the messaging options object.\n\nvar CAMELCASE_OPTIONS_KEYS_MAP = {\n  dryRun: 'dry_run',\n  timeToLive: 'time_to_live',\n  collapseKey: 'collapse_key',\n  mutableContent: 'mutable_content',\n  contentAvailable: 'content_available',\n  restrictedPackageName: 'restricted_package_name'\n}; // Key renames for the MessagingDeviceResult object.\n\nvar MESSAGING_DEVICE_RESULT_KEYS_MAP = {\n  message_id: 'messageId',\n  registration_id: 'canonicalRegistrationToken'\n}; // Key renames for the MessagingDevicesResponse object.\n\nvar MESSAGING_DEVICES_RESPONSE_KEYS_MAP = {\n  canonical_ids: 'canonicalRegistrationTokenCount',\n  failure: 'failureCount',\n  success: 'successCount',\n  multicast_id: 'multicastId'\n}; // Key renames for the MessagingDeviceGroupResponse object.\n\nvar MESSAGING_DEVICE_GROUP_RESPONSE_KEYS_MAP = {\n  success: 'successCount',\n  failure: 'failureCount',\n  failed_registration_ids: 'failedRegistrationTokens'\n}; // Key renames for the MessagingTopicResponse object.\n\nvar MESSAGING_TOPIC_RESPONSE_KEYS_MAP = {\n  message_id: 'messageId'\n}; // Key renames for the MessagingConditionResponse object.\n\nvar MESSAGING_CONDITION_RESPONSE_KEYS_MAP = {\n  message_id: 'messageId'\n}; // Keys which are not allowed in the messaging data payload object.\n\nexports.BLACKLISTED_DATA_PAYLOAD_KEYS = ['from']; // Keys which are not allowed in the messaging options object.\n\nexports.BLACKLISTED_OPTIONS_KEYS = ['condition', 'data', 'notification', 'registrationIds', 'registration_ids', 'to'];\n/**\n * Checks if the given object only contains strings as child values.\n *\n * @param {object} map An object to be validated.\n * @param {string} label A label to be included in the errors thrown.\n */\n\nfunction validateStringMap(map, label) {\n  if (typeof map === 'undefined') {\n    return;\n  } else if (!validator.isNonNullObject(map)) {\n    throw new error_1.FirebaseMessagingError(error_1.MessagingClientErrorCode.INVALID_PAYLOAD, label + \" must be a non-null object\");\n  }\n\n  Object.keys(map).forEach(function (key) {\n    if (!validator.isString(map[key])) {\n      throw new error_1.FirebaseMessagingError(error_1.MessagingClientErrorCode.INVALID_PAYLOAD, label + \" must only contain string values\");\n    }\n  });\n}\n/**\n * Checks if the given WebpushConfig object is valid. The object must have valid headers and data.\n *\n * @param {WebpushConfig} config An object to be validated.\n */\n\n\nfunction validateWebpushConfig(config) {\n  if (typeof config === 'undefined') {\n    return;\n  } else if (!validator.isNonNullObject(config)) {\n    throw new error_1.FirebaseMessagingError(error_1.MessagingClientErrorCode.INVALID_PAYLOAD, 'webpush must be a non-null object');\n  }\n\n  validateStringMap(config.headers, 'webpush.headers');\n  validateStringMap(config.data, 'webpush.data');\n}\n/**\n * Checks if the given ApnsConfig object is valid. The object must have valid headers and a\n * payload.\n *\n * @param {ApnsConfig} config An object to be validated.\n */\n\n\nfunction validateApnsConfig(config) {\n  if (typeof config === 'undefined') {\n    return;\n  } else if (!validator.isNonNullObject(config)) {\n    throw new error_1.FirebaseMessagingError(error_1.MessagingClientErrorCode.INVALID_PAYLOAD, 'apns must be a non-null object');\n  }\n\n  validateStringMap(config.headers, 'apns.headers');\n  validateApnsPayload(config.payload);\n}\n/**\n * Checks if the given ApnsPayload object is valid. The object must have a valid aps value.\n *\n * @param {ApnsPayload} payload An object to be validated.\n */\n\n\nfunction validateApnsPayload(payload) {\n  if (typeof payload === 'undefined') {\n    return;\n  } else if (!validator.isNonNullObject(payload)) {\n    throw new error_1.FirebaseMessagingError(error_1.MessagingClientErrorCode.INVALID_PAYLOAD, 'apns.payload must be a non-null object');\n  }\n\n  validateAps(payload.aps);\n}\n/**\n * Checks if the given Aps object is valid. The object must have a valid alert. If the validation\n * is successful, transforms the input object by renaming the keys to valid APNS payload keys.\n *\n * @param {Aps} aps An object to be validated.\n */\n\n\nfunction validateAps(aps) {\n  if (typeof aps === 'undefined') {\n    return;\n  } else if (!validator.isNonNullObject(aps)) {\n    throw new error_1.FirebaseMessagingError(error_1.MessagingClientErrorCode.INVALID_PAYLOAD, 'apns.payload.aps must be a non-null object');\n  }\n\n  validateApsAlert(aps.alert);\n  validateApsSound(aps.sound);\n  var propertyMappings = {\n    contentAvailable: 'content-available',\n    mutableContent: 'mutable-content',\n    threadId: 'thread-id'\n  };\n  Object.keys(propertyMappings).forEach(function (key) {\n    if (key in aps && propertyMappings[key] in aps) {\n      throw new error_1.FirebaseMessagingError(error_1.MessagingClientErrorCode.INVALID_PAYLOAD, \"Multiple specifications for \" + key + \" in Aps\");\n    }\n  });\n  index_1.renameProperties(aps, propertyMappings);\n  var contentAvailable = aps['content-available'];\n\n  if (typeof contentAvailable !== 'undefined' && contentAvailable !== 1) {\n    if (contentAvailable === true) {\n      aps['content-available'] = 1;\n    } else {\n      delete aps['content-available'];\n    }\n  }\n\n  var mutableContent = aps['mutable-content'];\n\n  if (typeof mutableContent !== 'undefined' && mutableContent !== 1) {\n    if (mutableContent === true) {\n      aps['mutable-content'] = 1;\n    } else {\n      delete aps['mutable-content'];\n    }\n  }\n}\n\nfunction validateApsSound(sound) {\n  if (typeof sound === 'undefined' || validator.isNonEmptyString(sound)) {\n    return;\n  } else if (!validator.isNonNullObject(sound)) {\n    throw new error_1.FirebaseMessagingError(error_1.MessagingClientErrorCode.INVALID_PAYLOAD, 'apns.payload.aps.sound must be a non-empty string or a non-null object');\n  }\n\n  if (!validator.isNonEmptyString(sound.name)) {\n    throw new error_1.FirebaseMessagingError(error_1.MessagingClientErrorCode.INVALID_PAYLOAD, 'apns.payload.aps.sound.name must be a non-empty string');\n  }\n\n  var volume = sound.volume;\n\n  if (typeof volume !== 'undefined') {\n    if (!validator.isNumber(volume)) {\n      throw new error_1.FirebaseMessagingError(error_1.MessagingClientErrorCode.INVALID_PAYLOAD, 'apns.payload.aps.sound.volume must be a number');\n    }\n\n    if (volume < 0 || volume > 1) {\n      throw new error_1.FirebaseMessagingError(error_1.MessagingClientErrorCode.INVALID_PAYLOAD, 'apns.payload.aps.sound.volume must be in the interval [0, 1]');\n    }\n  }\n\n  var soundObject = sound;\n  var key = 'critical';\n  var critical = soundObject[key];\n\n  if (typeof critical !== 'undefined' && critical !== 1) {\n    if (critical === true) {\n      soundObject[key] = 1;\n    } else {\n      delete soundObject[key];\n    }\n  }\n}\n/**\n * Checks if the given alert object is valid. Alert could be a string or a complex object.\n * If specified as an object, it must have valid localization parameters. If successful, transforms\n * the input object by renaming the keys to valid APNS payload keys.\n *\n * @param {string | ApsAlert} alert An alert string or an object to be validated.\n */\n\n\nfunction validateApsAlert(alert) {\n  if (typeof alert === 'undefined' || validator.isString(alert)) {\n    return;\n  } else if (!validator.isNonNullObject(alert)) {\n    throw new error_1.FirebaseMessagingError(error_1.MessagingClientErrorCode.INVALID_PAYLOAD, 'apns.payload.aps.alert must be a string or a non-null object');\n  }\n\n  var apsAlert = alert;\n\n  if (validator.isNonEmptyArray(apsAlert.locArgs) && !validator.isNonEmptyString(apsAlert.locKey)) {\n    throw new error_1.FirebaseMessagingError(error_1.MessagingClientErrorCode.INVALID_PAYLOAD, 'apns.payload.aps.alert.locKey is required when specifying locArgs');\n  }\n\n  if (validator.isNonEmptyArray(apsAlert.titleLocArgs) && !validator.isNonEmptyString(apsAlert.titleLocKey)) {\n    throw new error_1.FirebaseMessagingError(error_1.MessagingClientErrorCode.INVALID_PAYLOAD, 'apns.payload.aps.alert.titleLocKey is required when specifying titleLocArgs');\n  }\n\n  if (validator.isNonEmptyArray(apsAlert.subtitleLocArgs) && !validator.isNonEmptyString(apsAlert.subtitleLocKey)) {\n    throw new error_1.FirebaseMessagingError(error_1.MessagingClientErrorCode.INVALID_PAYLOAD, 'apns.payload.aps.alert.subtitleLocKey is required when specifying subtitleLocArgs');\n  }\n\n  var propertyMappings = {\n    locKey: 'loc-key',\n    locArgs: 'loc-args',\n    titleLocKey: 'title-loc-key',\n    titleLocArgs: 'title-loc-args',\n    subtitleLocKey: 'subtitle-loc-key',\n    subtitleLocArgs: 'subtitle-loc-args',\n    actionLocKey: 'action-loc-key',\n    launchImage: 'launch-image'\n  };\n  index_1.renameProperties(apsAlert, propertyMappings);\n}\n/**\n * Checks if the given AndroidConfig object is valid. The object must have valid ttl, data,\n * and notification fields. If successful, transforms the input object by renaming keys to valid\n * Android keys. Also transforms the ttl value to the format expected by FCM service.\n *\n * @param {AndroidConfig} config An object to be validated.\n */\n\n\nfunction validateAndroidConfig(config) {\n  if (typeof config === 'undefined') {\n    return;\n  } else if (!validator.isNonNullObject(config)) {\n    throw new error_1.FirebaseMessagingError(error_1.MessagingClientErrorCode.INVALID_PAYLOAD, 'android must be a non-null object');\n  }\n\n  if (typeof config.ttl !== 'undefined') {\n    if (!validator.isNumber(config.ttl) || config.ttl < 0) {\n      throw new error_1.FirebaseMessagingError(error_1.MessagingClientErrorCode.INVALID_PAYLOAD, 'TTL must be a non-negative duration in milliseconds');\n    }\n\n    var seconds = Math.floor(config.ttl / 1000);\n    var nanos = (config.ttl - seconds * 1000) * 1000000;\n    var duration = void 0;\n\n    if (nanos > 0) {\n      var nanoString = nanos.toString();\n\n      while (nanoString.length < 9) {\n        nanoString = '0' + nanoString;\n      }\n\n      duration = seconds + \".\" + nanoString + \"s\";\n    } else {\n      duration = seconds + \"s\";\n    }\n\n    config.ttl = duration;\n  }\n\n  validateStringMap(config.data, 'android.data');\n  validateAndroidNotification(config.notification);\n  var propertyMappings = {\n    collapseKey: 'collapse_key',\n    restrictedPackageName: 'restricted_package_name'\n  };\n  index_1.renameProperties(config, propertyMappings);\n}\n/**\n * Checks if the given AndroidNotification object is valid. The object must have valid color and\n * localization parameters. If successful, transforms the input object by renaming keys to valid\n * Android keys.\n *\n * @param {AndroidNotification} notification An object to be validated.\n */\n\n\nfunction validateAndroidNotification(notification) {\n  if (typeof notification === 'undefined') {\n    return;\n  } else if (!validator.isNonNullObject(notification)) {\n    throw new error_1.FirebaseMessagingError(error_1.MessagingClientErrorCode.INVALID_PAYLOAD, 'android.notification must be a non-null object');\n  }\n\n  if (typeof notification.color !== 'undefined' && !/^#[0-9a-fA-F]{6}$/.test(notification.color)) {\n    throw new error_1.FirebaseMessagingError(error_1.MessagingClientErrorCode.INVALID_PAYLOAD, 'android.notification.color must be in the form #RRGGBB');\n  }\n\n  if (validator.isNonEmptyArray(notification.bodyLocArgs) && !validator.isNonEmptyString(notification.bodyLocKey)) {\n    throw new error_1.FirebaseMessagingError(error_1.MessagingClientErrorCode.INVALID_PAYLOAD, 'android.notification.bodyLocKey is required when specifying bodyLocArgs');\n  }\n\n  if (validator.isNonEmptyArray(notification.titleLocArgs) && !validator.isNonEmptyString(notification.titleLocKey)) {\n    throw new error_1.FirebaseMessagingError(error_1.MessagingClientErrorCode.INVALID_PAYLOAD, 'android.notification.titleLocKey is required when specifying titleLocArgs');\n  }\n\n  var propertyMappings = {\n    clickAction: 'click_action',\n    bodyLocKey: 'body_loc_key',\n    bodyLocArgs: 'body_loc_args',\n    titleLocKey: 'title_loc_key',\n    titleLocArgs: 'title_loc_args',\n    channelId: 'channel_id'\n  };\n  index_1.renameProperties(notification, propertyMappings);\n}\n/**\n * Checks if the given Message object is valid. Recursively validates all the child objects\n * included in the message (android, apns, data etc.). If successful, transforms the message\n * in place by renaming the keys to what's expected by the remote FCM service.\n *\n * @param {Message} Message An object to be validated.\n */\n\n\nfunction validateMessage(message) {\n  if (!validator.isNonNullObject(message)) {\n    throw new error_1.FirebaseMessagingError(error_1.MessagingClientErrorCode.INVALID_PAYLOAD, 'Message must be a non-null object');\n  }\n\n  var anyMessage = message;\n\n  if (anyMessage.topic) {\n    // If the topic name is prefixed, remove it.\n    if (anyMessage.topic.startsWith('/topics/')) {\n      anyMessage.topic = anyMessage.topic.replace(/^\\/topics\\//, '');\n    } // Checks for illegal characters and empty string.\n\n\n    if (!/^[a-zA-Z0-9-_.~%]+$/.test(anyMessage.topic)) {\n      throw new error_1.FirebaseMessagingError(error_1.MessagingClientErrorCode.INVALID_PAYLOAD, 'Malformed topic name');\n    }\n  }\n\n  var targets = [anyMessage.token, anyMessage.topic, anyMessage.condition];\n\n  if (targets.filter(function (v) {\n    return validator.isNonEmptyString(v);\n  }).length !== 1) {\n    throw new error_1.FirebaseMessagingError(error_1.MessagingClientErrorCode.INVALID_PAYLOAD, 'Exactly one of topic, token or condition is required');\n  }\n\n  validateStringMap(message.data, 'data');\n  validateAndroidConfig(message.android);\n  validateWebpushConfig(message.webpush);\n  validateApnsConfig(message.apns);\n}\n/**\n * Maps a raw FCM server response to a MessagingDevicesResponse object.\n *\n * @param {object} response The raw FCM server response to map.\n *\n * @return {MessagingDeviceGroupResponse} The mapped MessagingDevicesResponse object.\n */\n\n\nfunction mapRawResponseToDevicesResponse(response) {\n  // Rename properties on the server response\n  utils.renameProperties(response, MESSAGING_DEVICES_RESPONSE_KEYS_MAP);\n\n  if ('results' in response) {\n    response.results.forEach(function (messagingDeviceResult) {\n      utils.renameProperties(messagingDeviceResult, MESSAGING_DEVICE_RESULT_KEYS_MAP); // Map the FCM server's error strings to actual error objects.\n\n      if ('error' in messagingDeviceResult) {\n        var newError = error_1.FirebaseMessagingError.fromServerError(messagingDeviceResult.error,\n        /* message */\n        undefined, messagingDeviceResult.error);\n        messagingDeviceResult.error = newError;\n      }\n    });\n  }\n\n  return response;\n}\n/**\n * Maps a raw FCM server response to a MessagingDeviceGroupResponse object.\n *\n * @param {object} response The raw FCM server response to map.\n *\n * @return {MessagingDeviceGroupResponse} The mapped MessagingDeviceGroupResponse object.\n */\n\n\nfunction mapRawResponseToDeviceGroupResponse(response) {\n  // Rename properties on the server response\n  utils.renameProperties(response, MESSAGING_DEVICE_GROUP_RESPONSE_KEYS_MAP); // Add the 'failedRegistrationTokens' property if it does not exist on the response, which\n  // it won't when the 'failureCount' property has a value of 0)\n\n  response.failedRegistrationTokens = response.failedRegistrationTokens || [];\n  return response;\n}\n/**\n * Maps a raw FCM server response to a MessagingTopicManagementResponse object.\n *\n * @param {object} response The raw FCM server response to map.\n *\n * @return {MessagingTopicManagementResponse} The mapped MessagingTopicManagementResponse object.\n */\n\n\nfunction mapRawResponseToTopicManagementResponse(response) {\n  // Add the success and failure counts.\n  var result = {\n    successCount: 0,\n    failureCount: 0,\n    errors: []\n  };\n  var errors = [];\n\n  if ('results' in response) {\n    response.results.forEach(function (tokenManagementResult, index) {\n      // Map the FCM server's error strings to actual error objects.\n      if ('error' in tokenManagementResult) {\n        result.failureCount += 1;\n        var newError = error_1.FirebaseMessagingError.fromTopicManagementServerError(tokenManagementResult.error,\n        /* message */\n        undefined, tokenManagementResult.error);\n        result.errors.push({\n          index: index,\n          error: newError\n        });\n      } else {\n        result.successCount += 1;\n      }\n    });\n  }\n\n  return result;\n}\n/**\n * Internals of a Messaging instance.\n */\n\n\nvar MessagingInternals =\n/** @class */\nfunction () {\n  function MessagingInternals() {}\n  /**\n   * Deletes the service and its associated resources.\n   *\n   * @return {Promise<()>} An empty Promise that will be fulfilled when the service is deleted.\n   */\n\n\n  MessagingInternals.prototype.delete = function () {\n    // There are no resources to clean up.\n    return Promise.resolve(undefined);\n  };\n\n  return MessagingInternals;\n}();\n/**\n * Messaging service bound to the provided app.\n */\n\n\nvar Messaging =\n/** @class */\nfunction () {\n  /**\n   * @param {FirebaseApp} app The app for this Messaging service.\n   * @constructor\n   */\n  function Messaging(app) {\n    this.INTERNAL = new MessagingInternals();\n\n    if (!validator.isNonNullObject(app) || !('options' in app)) {\n      throw new error_1.FirebaseMessagingError(error_1.MessagingClientErrorCode.INVALID_ARGUMENT, 'First argument passed to admin.messaging() must be a valid Firebase app instance.');\n    }\n\n    var projectId = utils.getProjectId(app);\n\n    if (!validator.isNonEmptyString(projectId)) {\n      // Assert for an explicit projct ID (either via AppOptions or the cert itself).\n      throw new error_1.FirebaseMessagingError(error_1.MessagingClientErrorCode.INVALID_ARGUMENT, 'Failed to determine project ID for Messaging. Initialize the ' + 'SDK with service account credentials or set project ID as an app option. ' + 'Alternatively set the GOOGLE_CLOUD_PROJECT environment variable.');\n    }\n\n    this.urlPath = \"/v1/projects/\" + projectId + \"/messages:send\";\n    this.appInternal = app;\n    this.messagingRequestHandler = new messaging_api_request_1.FirebaseMessagingRequestHandler(app);\n  }\n\n  Object.defineProperty(Messaging.prototype, \"app\", {\n    /**\n     * Returns the app associated with this Messaging instance.\n     *\n     * @return {FirebaseApp} The app associated with this Messaging instance.\n     */\n    get: function get() {\n      return this.appInternal;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\n   * Sends a message via Firebase Cloud Messaging (FCM).\n   *\n   * @param {Message} message The message to be sent.\n   * @param {boolean=} dryRun Whether to send the message in the dry-run (validation only) mode.\n   *\n   * @return {Promise<string>} A Promise fulfilled with a message ID string.\n   */\n\n  Messaging.prototype.send = function (message, dryRun) {\n    var _this = this;\n\n    var copy = deep_copy_1.deepCopy(message);\n    validateMessage(copy);\n\n    if (typeof dryRun !== 'undefined' && !validator.isBoolean(dryRun)) {\n      throw new error_1.FirebaseMessagingError(error_1.MessagingClientErrorCode.INVALID_ARGUMENT, 'dryRun must be a boolean');\n    }\n\n    return Promise.resolve().then(function () {\n      var request = {\n        message: copy\n      };\n\n      if (dryRun) {\n        request.validate_only = true;\n      }\n\n      return _this.messagingRequestHandler.invokeRequestHandler(FCM_SEND_HOST, _this.urlPath, request);\n    }).then(function (response) {\n      return response.name;\n    });\n  };\n  /**\n   * Sends an FCM message to a single device or an array of devices.\n   *\n   * @param {string|string[]} registrationTokenOrTokens The registration token or an array of\n   *     registration tokens for the device(s) to which to send the message.\n   * @param {MessagingPayload} payload The message payload.\n   * @param {MessagingOptions} [options = {}] Optional options to alter the message.\n   *\n   * @return {Promise<MessagingDevicesResponse|MessagingDeviceGroupResponse>} A Promise fulfilled\n   *     with the server's response after the message has been sent.\n   */\n\n\n  Messaging.prototype.sendToDevice = function (registrationTokenOrTokens, payload, options) {\n    var _this = this;\n\n    if (options === void 0) {\n      options = {};\n    } // Validate the input argument types. Since these are common developer errors when getting\n    // started, throw an error instead of returning a rejected promise.\n\n\n    this.validateRegistrationTokensType(registrationTokenOrTokens, 'sendToDevice', error_1.MessagingClientErrorCode.INVALID_RECIPIENT);\n    this.validateMessagingPayloadAndOptionsTypes(payload, options);\n    return Promise.resolve().then(function () {\n      // Validate the contents of the input arguments. Because we are now in a promise, any thrown\n      // error will cause this method to return a rejected promise.\n      _this.validateRegistrationTokens(registrationTokenOrTokens, 'sendToDevice', error_1.MessagingClientErrorCode.INVALID_RECIPIENT);\n\n      var payloadCopy = _this.validateMessagingPayload(payload);\n\n      var optionsCopy = _this.validateMessagingOptions(options);\n\n      var request = deep_copy_1.deepCopy(payloadCopy);\n      deep_copy_1.deepExtend(request, optionsCopy);\n\n      if (validator.isString(registrationTokenOrTokens)) {\n        request.to = registrationTokenOrTokens;\n      } else {\n        request.registration_ids = registrationTokenOrTokens;\n      }\n\n      return _this.messagingRequestHandler.invokeRequestHandler(FCM_SEND_HOST, FCM_SEND_PATH, request);\n    }).then(function (response) {\n      // The sendToDevice() and sendToDeviceGroup() methods both set the `to` query parameter in\n      // the underlying FCM request. If the provided registration token argument is actually a\n      // valid notification key, the response from the FCM server will be a device group response.\n      // If that is the case, we map the response to a MessagingDeviceGroupResponse.\n      // See b/35394951 for more context.\n      if ('multicast_id' in response) {\n        return mapRawResponseToDevicesResponse(response);\n      } else {\n        return mapRawResponseToDeviceGroupResponse(response);\n      }\n    });\n  };\n  /**\n   * Sends an FCM message to a device group.\n   *\n   * @param {string} notificationKey The notification key representing the device group to which to\n   *     send the message.\n   * @param {MessagingPayload} payload The message payload.\n   * @param {MessagingOptions} [options = {}] Optional options to alter the message.\n   *\n   * @return {Promise<MessagingDeviceGroupResponse|MessagingDevicesResponse>} A Promise fulfilled\n   *     with the server's response after the message has been sent.\n   */\n\n\n  Messaging.prototype.sendToDeviceGroup = function (notificationKey, payload, options) {\n    var _this = this;\n\n    if (options === void 0) {\n      options = {};\n    }\n\n    if (!validator.isNonEmptyString(notificationKey)) {\n      throw new error_1.FirebaseMessagingError(error_1.MessagingClientErrorCode.INVALID_RECIPIENT, 'Notification key provided to sendToDeviceGroup() must be a non-empty string.');\n    } else if (notificationKey.indexOf(':') !== -1) {\n      // It is possible the developer provides a registration token instead of a notification key\n      // to this method. We can detect some of those cases by checking to see if the string contains\n      // a colon. Not all registration tokens will contain a colon (only newer ones will), but no\n      // notification keys will contain a colon, so we can use it as a rough heuristic.\n      // See b/35394951 for more context.\n      return Promise.reject(new error_1.FirebaseMessagingError(error_1.MessagingClientErrorCode.INVALID_RECIPIENT, 'Notification key provided to sendToDeviceGroup() has the format of a registration token. ' + 'You should use sendToDevice() instead.'));\n    } // Validate the types of the payload and options arguments. Since these are common developer\n    // errors, throw an error instead of returning a rejected promise.\n\n\n    this.validateMessagingPayloadAndOptionsTypes(payload, options);\n    return Promise.resolve().then(function () {\n      // Validate the contents of the payload and options objects. Because we are now in a\n      // promise, any thrown error will cause this method to return a rejected promise.\n      var payloadCopy = _this.validateMessagingPayload(payload);\n\n      var optionsCopy = _this.validateMessagingOptions(options);\n\n      var request = deep_copy_1.deepCopy(payloadCopy);\n      deep_copy_1.deepExtend(request, optionsCopy);\n      request.to = notificationKey;\n      return _this.messagingRequestHandler.invokeRequestHandler(FCM_SEND_HOST, FCM_SEND_PATH, request);\n    }).then(function (response) {\n      // The sendToDevice() and sendToDeviceGroup() methods both set the `to` query parameter in\n      // the underlying FCM request. If the provided notification key argument has an invalid\n      // format (that is, it is either a registration token or some random string), the response\n      // from the FCM server will default to a devices response (which we detect by looking for\n      // the `multicast_id` property). If that is the case, we either throw an error saying the\n      // provided notification key is invalid (if the message failed to send) or map the response\n      // to a MessagingDevicesResponse (if the message succeeded).\n      // See b/35394951 for more context.\n      if ('multicast_id' in response) {\n        if (response.success === 0) {\n          throw new error_1.FirebaseMessagingError(error_1.MessagingClientErrorCode.INVALID_RECIPIENT, 'Notification key provided to sendToDeviceGroup() is invalid.');\n        } else {\n          return mapRawResponseToDevicesResponse(response);\n        }\n      }\n\n      return mapRawResponseToDeviceGroupResponse(response);\n    });\n  };\n  /**\n   * Sends an FCM message to a topic.\n   *\n   * @param {string} topic The name of the topic to which to send the message.\n   * @param {MessagingPayload} payload The message payload.\n   * @param {MessagingOptions} [options = {}] Optional options to alter the message.\n   *\n   * @return {Promise<MessagingTopicResponse>} A Promise fulfilled with the server's response after\n   *     the message has been sent.\n   */\n\n\n  Messaging.prototype.sendToTopic = function (topic, payload, options) {\n    var _this = this;\n\n    if (options === void 0) {\n      options = {};\n    } // Validate the input argument types. Since these are common developer errors when getting\n    // started, throw an error instead of returning a rejected promise.\n\n\n    this.validateTopicType(topic, 'sendToTopic', error_1.MessagingClientErrorCode.INVALID_RECIPIENT);\n    this.validateMessagingPayloadAndOptionsTypes(payload, options); // Prepend the topic with /topics/ if necessary.\n\n    topic = this.normalizeTopic(topic);\n    return Promise.resolve().then(function () {\n      // Validate the contents of the payload and options objects. Because we are now in a\n      // promise, any thrown error will cause this method to return a rejected promise.\n      var payloadCopy = _this.validateMessagingPayload(payload);\n\n      var optionsCopy = _this.validateMessagingOptions(options);\n\n      _this.validateTopic(topic, 'sendToTopic', error_1.MessagingClientErrorCode.INVALID_RECIPIENT);\n\n      var request = deep_copy_1.deepCopy(payloadCopy);\n      deep_copy_1.deepExtend(request, optionsCopy);\n      request.to = topic;\n      return _this.messagingRequestHandler.invokeRequestHandler(FCM_SEND_HOST, FCM_SEND_PATH, request);\n    }).then(function (response) {\n      // Rename properties on the server response\n      utils.renameProperties(response, MESSAGING_TOPIC_RESPONSE_KEYS_MAP);\n      return response;\n    });\n  };\n  /**\n   * Sends an FCM message to a condition.\n   *\n   * @param {string} condition The condition to which to send the message.\n   * @param {MessagingPayload} payload The message payload.\n   * @param {MessagingOptions} [options = {}] Optional options to alter the message.\n   *\n   * @return {Promise<MessagingConditionResponse>} A Promise fulfilled with the server's response\n   *     after the message has been sent.\n   */\n\n\n  Messaging.prototype.sendToCondition = function (condition, payload, options) {\n    var _this = this;\n\n    if (options === void 0) {\n      options = {};\n    }\n\n    if (!validator.isNonEmptyString(condition)) {\n      throw new error_1.FirebaseMessagingError(error_1.MessagingClientErrorCode.INVALID_RECIPIENT, 'Condition provided to sendToCondition() must be a non-empty string.');\n    } // Validate the types of the payload and options arguments. Since these are common developer\n    // errors, throw an error instead of returning a rejected promise.\n\n\n    this.validateMessagingPayloadAndOptionsTypes(payload, options); // The FCM server rejects conditions which are surrounded in single quotes. When the condition\n    // is stringified over the wire, double quotes in it get converted to \\\" which the FCM server\n    // does not properly handle. We can get around this by replacing internal double quotes with\n    // single quotes.\n\n    condition = condition.replace(/\"/g, '\\'');\n    return Promise.resolve().then(function () {\n      // Validate the contents of the payload and options objects. Because we are now in a\n      // promise, any thrown error will cause this method to return a rejected promise.\n      var payloadCopy = _this.validateMessagingPayload(payload);\n\n      var optionsCopy = _this.validateMessagingOptions(options);\n\n      var request = deep_copy_1.deepCopy(payloadCopy);\n      deep_copy_1.deepExtend(request, optionsCopy);\n      request.condition = condition;\n      return _this.messagingRequestHandler.invokeRequestHandler(FCM_SEND_HOST, FCM_SEND_PATH, request);\n    }).then(function (response) {\n      // Rename properties on the server response\n      utils.renameProperties(response, MESSAGING_CONDITION_RESPONSE_KEYS_MAP);\n      return response;\n    });\n  };\n  /**\n   * Subscribes a single device or an array of devices to a topic.\n   *\n   * @param {string|string[]} registrationTokenOrTokens The registration token or an array of\n   *     registration tokens to subscribe to the topic.\n   * @param {string} topic The topic to which to subscribe.\n   *\n   * @return {Promise<MessagingTopicManagementResponse>} A Promise fulfilled with the parsed FCM\n   *   server response.\n   */\n\n\n  Messaging.prototype.subscribeToTopic = function (registrationTokenOrTokens, topic) {\n    return this.sendTopicManagementRequest(registrationTokenOrTokens, topic, 'subscribeToTopic', FCM_TOPIC_MANAGEMENT_ADD_PATH);\n  };\n  /**\n   * Unsubscribes a single device or an array of devices from a topic.\n   *\n   * @param {string|string[]} registrationTokenOrTokens The registration token or an array of\n   *     registration tokens to unsubscribe from the topic.\n   * @param {string} topic The topic to which to subscribe.\n   *\n   * @return {Promise<MessagingTopicManagementResponse>} A Promise fulfilled with the parsed FCM\n   *   server response.\n   */\n\n\n  Messaging.prototype.unsubscribeFromTopic = function (registrationTokenOrTokens, topic) {\n    return this.sendTopicManagementRequest(registrationTokenOrTokens, topic, 'unsubscribeFromTopic', FCM_TOPIC_MANAGEMENT_REMOVE_PATH);\n  };\n  /**\n   * Helper method which sends and handles topic subscription management requests.\n   *\n   * @param {string|string[]} registrationTokenOrTokens The registration token or an array of\n   *     registration tokens to unsubscribe from the topic.\n   * @param {string} topic The topic to which to subscribe.\n   * @param {string} methodName The name of the original method called.\n   * @param {string} path The endpoint path to use for the request.\n   *\n   * @return {Promise<MessagingTopicManagementResponse>} A Promise fulfilled with the parsed server\n   *   response.\n   */\n\n\n  Messaging.prototype.sendTopicManagementRequest = function (registrationTokenOrTokens, topic, methodName, path) {\n    var _this = this;\n\n    this.validateRegistrationTokensType(registrationTokenOrTokens, methodName);\n    this.validateTopicType(topic, methodName); // Prepend the topic with /topics/ if necessary.\n\n    topic = this.normalizeTopic(topic);\n    return Promise.resolve().then(function () {\n      // Validate the contents of the input arguments. Because we are now in a promise, any thrown\n      // error will cause this method to return a rejected promise.\n      _this.validateRegistrationTokens(registrationTokenOrTokens, methodName);\n\n      _this.validateTopic(topic, methodName); // Ensure the registration token(s) input argument is an array.\n\n\n      var registrationTokensArray = registrationTokenOrTokens;\n\n      if (validator.isString(registrationTokenOrTokens)) {\n        registrationTokensArray = [registrationTokenOrTokens];\n      }\n\n      var request = {\n        to: topic,\n        registration_tokens: registrationTokensArray\n      };\n      return _this.messagingRequestHandler.invokeRequestHandler(FCM_TOPIC_MANAGEMENT_HOST, path, request);\n    }).then(function (response) {\n      return mapRawResponseToTopicManagementResponse(response);\n    });\n  };\n  /**\n   * Validates the types of the messaging payload and options. If invalid, an error will be thrown.\n   *\n   * @param {MessagingPayload} payload The messaging payload to validate.\n   * @param {MessagingOptions} options The messaging options to validate.\n   */\n\n\n  Messaging.prototype.validateMessagingPayloadAndOptionsTypes = function (payload, options) {\n    // Validate the payload is an object\n    if (!validator.isNonNullObject(payload)) {\n      throw new error_1.FirebaseMessagingError(error_1.MessagingClientErrorCode.INVALID_PAYLOAD, 'Messaging payload must be an object with at least one of the \"data\" or \"notification\" properties.');\n    } // Validate the options argument is an object\n\n\n    if (!validator.isNonNullObject(options)) {\n      throw new error_1.FirebaseMessagingError(error_1.MessagingClientErrorCode.INVALID_OPTIONS, 'Messaging options must be an object.');\n    }\n  };\n  /**\n   * Validates the messaging payload. If invalid, an error will be thrown.\n   *\n   * @param {MessagingPayload} payload The messaging payload to validate.\n   *\n   * @return {MessagingPayload} A copy of the provided payload with whitelisted properties switched\n   *     from camelCase to underscore_case.\n   */\n\n\n  Messaging.prototype.validateMessagingPayload = function (payload) {\n    var payloadCopy = deep_copy_1.deepCopy(payload);\n    var payloadKeys = Object.keys(payloadCopy);\n    var validPayloadKeys = ['data', 'notification'];\n    var containsDataOrNotificationKey = false;\n    payloadKeys.forEach(function (payloadKey) {\n      // Validate the payload does not contain any invalid keys\n      if (validPayloadKeys.indexOf(payloadKey) === -1) {\n        throw new error_1.FirebaseMessagingError(error_1.MessagingClientErrorCode.INVALID_PAYLOAD, \"Messaging payload contains an invalid \\\"\" + payloadKey + \"\\\" property. Valid properties are \" + \"\\\"data\\\" and \\\"notification\\\".\");\n      } else {\n        containsDataOrNotificationKey = true;\n      }\n    }); // Validate the payload contains at least one of the \"data\" and \"notification\" keys\n\n    if (!containsDataOrNotificationKey) {\n      throw new error_1.FirebaseMessagingError(error_1.MessagingClientErrorCode.INVALID_PAYLOAD, 'Messaging payload must contain at least one of the \"data\" or \"notification\" properties.');\n    }\n\n    payloadKeys.forEach(function (payloadKey) {\n      var value = payloadCopy[payloadKey]; // Validate each top-level key in the payload is an object\n\n      if (!validator.isNonNullObject(value)) {\n        throw new error_1.FirebaseMessagingError(error_1.MessagingClientErrorCode.INVALID_PAYLOAD, \"Messaging payload contains an invalid value for the \\\"\" + payloadKey + \"\\\" property. \" + \"Value must be an object.\");\n      }\n\n      Object.keys(value).forEach(function (subKey) {\n        if (!validator.isString(value[subKey])) {\n          // Validate all sub-keys have a string value\n          throw new error_1.FirebaseMessagingError(error_1.MessagingClientErrorCode.INVALID_PAYLOAD, \"Messaging payload contains an invalid value for the \\\"\" + payloadKey + \".\" + subKey + \"\\\" \" + \"property. Values must be strings.\");\n        } else if (payloadKey === 'data' && /^google\\./.test(subKey)) {\n          // Validate the data payload does not contain keys which start with 'google.'.\n          throw new error_1.FirebaseMessagingError(error_1.MessagingClientErrorCode.INVALID_PAYLOAD, \"Messaging payload contains the blacklisted \\\"data.\" + subKey + \"\\\" property.\");\n        }\n      });\n    }); // Validate the data payload object does not contain blacklisted properties\n\n    if ('data' in payloadCopy) {\n      exports.BLACKLISTED_DATA_PAYLOAD_KEYS.forEach(function (blacklistedKey) {\n        if (blacklistedKey in payloadCopy.data) {\n          throw new error_1.FirebaseMessagingError(error_1.MessagingClientErrorCode.INVALID_PAYLOAD, \"Messaging payload contains the blacklisted \\\"data.\" + blacklistedKey + \"\\\" property.\");\n        }\n      });\n    } // Convert whitelisted camelCase keys to underscore_case\n\n\n    if ('notification' in payloadCopy) {\n      utils.renameProperties(payloadCopy.notification, CAMELCASED_NOTIFICATION_PAYLOAD_KEYS_MAP);\n    }\n\n    return payloadCopy;\n  };\n  /**\n   * Validates the messaging options. If invalid, an error will be thrown.\n   *\n   * @param {MessagingOptions} options The messaging options to validate.\n   *\n   * @return {MessagingOptions} A copy of the provided options with whitelisted properties switched\n   *   from camelCase to underscore_case.\n   */\n\n\n  Messaging.prototype.validateMessagingOptions = function (options) {\n    var optionsCopy = deep_copy_1.deepCopy(options); // Validate the options object does not contain blacklisted properties\n\n    exports.BLACKLISTED_OPTIONS_KEYS.forEach(function (blacklistedKey) {\n      if (blacklistedKey in optionsCopy) {\n        throw new error_1.FirebaseMessagingError(error_1.MessagingClientErrorCode.INVALID_OPTIONS, \"Messaging options contains the blacklisted \\\"\" + blacklistedKey + \"\\\" property.\");\n      }\n    }); // Convert whitelisted camelCase keys to underscore_case\n\n    utils.renameProperties(optionsCopy, CAMELCASE_OPTIONS_KEYS_MAP); // Validate the options object contains valid values for whitelisted properties\n\n    if ('collapse_key' in optionsCopy && !validator.isNonEmptyString(optionsCopy.collapse_key)) {\n      var keyName = 'collapseKey' in options ? 'collapseKey' : 'collapse_key';\n      throw new error_1.FirebaseMessagingError(error_1.MessagingClientErrorCode.INVALID_OPTIONS, \"Messaging options contains an invalid value for the \\\"\" + keyName + \"\\\" property. Value must \" + 'be a non-empty string.');\n    } else if ('dry_run' in optionsCopy && !validator.isBoolean(optionsCopy.dry_run)) {\n      var keyName = 'dryRun' in options ? 'dryRun' : 'dry_run';\n      throw new error_1.FirebaseMessagingError(error_1.MessagingClientErrorCode.INVALID_OPTIONS, \"Messaging options contains an invalid value for the \\\"\" + keyName + \"\\\" property. Value must \" + 'be a boolean.');\n    } else if ('priority' in optionsCopy && !validator.isNonEmptyString(optionsCopy.priority)) {\n      throw new error_1.FirebaseMessagingError(error_1.MessagingClientErrorCode.INVALID_OPTIONS, 'Messaging options contains an invalid value for the \"priority\" property. Value must ' + 'be a non-empty string.');\n    } else if ('restricted_package_name' in optionsCopy && !validator.isNonEmptyString(optionsCopy.restricted_package_name)) {\n      var keyName = 'restrictedPackageName' in options ? 'restrictedPackageName' : 'restricted_package_name';\n      throw new error_1.FirebaseMessagingError(error_1.MessagingClientErrorCode.INVALID_OPTIONS, \"Messaging options contains an invalid value for the \\\"\" + keyName + \"\\\" property. Value must \" + 'be a non-empty string.');\n    } else if ('time_to_live' in optionsCopy && !validator.isNumber(optionsCopy.time_to_live)) {\n      var keyName = 'timeToLive' in options ? 'timeToLive' : 'time_to_live';\n      throw new error_1.FirebaseMessagingError(error_1.MessagingClientErrorCode.INVALID_OPTIONS, \"Messaging options contains an invalid value for the \\\"\" + keyName + \"\\\" property. Value must \" + 'be a number.');\n    } else if ('content_available' in optionsCopy && !validator.isBoolean(optionsCopy.content_available)) {\n      var keyName = 'contentAvailable' in options ? 'contentAvailable' : 'content_available';\n      throw new error_1.FirebaseMessagingError(error_1.MessagingClientErrorCode.INVALID_OPTIONS, \"Messaging options contains an invalid value for the \\\"\" + keyName + \"\\\" property. Value must \" + 'be a boolean.');\n    } else if ('mutable_content' in optionsCopy && !validator.isBoolean(optionsCopy.mutable_content)) {\n      var keyName = 'mutableContent' in options ? 'mutableContent' : 'mutable_content';\n      throw new error_1.FirebaseMessagingError(error_1.MessagingClientErrorCode.INVALID_OPTIONS, \"Messaging options contains an invalid value for the \\\"\" + keyName + \"\\\" property. Value must \" + 'be a boolean.');\n    }\n\n    return optionsCopy;\n  };\n  /**\n   * Validates the type of the provided registration token(s). If invalid, an error will be thrown.\n   *\n   * @param {string|string[]} registrationTokenOrTokens The registration token(s) to validate.\n   * @param {string} method The method name to use in error messages.\n   * @param {ErrorInfo?} [errorInfo] The error info to use if the registration tokens are invalid.\n   */\n\n\n  Messaging.prototype.validateRegistrationTokensType = function (registrationTokenOrTokens, methodName, errorInfo) {\n    if (errorInfo === void 0) {\n      errorInfo = error_1.MessagingClientErrorCode.INVALID_ARGUMENT;\n    }\n\n    if (!validator.isNonEmptyArray(registrationTokenOrTokens) && !validator.isNonEmptyString(registrationTokenOrTokens)) {\n      throw new error_1.FirebaseMessagingError(errorInfo, \"Registration token(s) provided to \" + methodName + \"() must be a non-empty string or a \" + 'non-empty array.');\n    }\n  };\n  /**\n   * Validates the provided registration tokens. If invalid, an error will be thrown.\n   *\n   * @param {string|string[]} registrationTokenOrTokens The registration token or an array of\n   *     registration tokens to validate.\n   * @param {string} method The method name to use in error messages.\n   * @param {errorInfo?} [ErrorInfo] The error info to use if the registration tokens are invalid.\n   */\n\n\n  Messaging.prototype.validateRegistrationTokens = function (registrationTokenOrTokens, methodName, errorInfo) {\n    if (errorInfo === void 0) {\n      errorInfo = error_1.MessagingClientErrorCode.INVALID_ARGUMENT;\n    }\n\n    if (validator.isArray(registrationTokenOrTokens)) {\n      // Validate the array contains no more than 1,000 registration tokens.\n      if (registrationTokenOrTokens.length > 1000) {\n        throw new error_1.FirebaseMessagingError(errorInfo, \"Too many registration tokens provided in a single request to \" + methodName + \"(). Batch \" + 'your requests to contain no more than 1,000 registration tokens per request.');\n      } // Validate the array contains registration tokens which are non-empty strings.\n\n\n      registrationTokenOrTokens.forEach(function (registrationToken, index) {\n        if (!validator.isNonEmptyString(registrationToken)) {\n          throw new error_1.FirebaseMessagingError(errorInfo, \"Registration token provided to \" + methodName + \"() at index \" + index + \" must be a \" + 'non-empty string.');\n        }\n      });\n    }\n  };\n  /**\n   * Validates the type of the provided topic. If invalid, an error will be thrown.\n   *\n   * @param {string} topic The topic to validate.\n   * @param {string} method The method name to use in error messages.\n   * @param {ErrorInfo?} [errorInfo] The error info to use if the topic is invalid.\n   */\n\n\n  Messaging.prototype.validateTopicType = function (topic, methodName, errorInfo) {\n    if (errorInfo === void 0) {\n      errorInfo = error_1.MessagingClientErrorCode.INVALID_ARGUMENT;\n    }\n\n    if (!validator.isNonEmptyString(topic)) {\n      throw new error_1.FirebaseMessagingError(errorInfo, \"Topic provided to \" + methodName + \"() must be a string which matches the format \" + '\"/topics/[a-zA-Z0-9-_.~%]+\".');\n    }\n  };\n  /**\n   * Validates the provided topic. If invalid, an error will be thrown.\n   *\n   * @param {string} topic The topic to validate.\n   * @param {string} method The method name to use in error messages.\n   * @param {ErrorInfo?} [errorInfo] The error info to use if the topic is invalid.\n   */\n\n\n  Messaging.prototype.validateTopic = function (topic, methodName, errorInfo) {\n    if (errorInfo === void 0) {\n      errorInfo = error_1.MessagingClientErrorCode.INVALID_ARGUMENT;\n    }\n\n    if (!validator.isTopic(topic)) {\n      throw new error_1.FirebaseMessagingError(errorInfo, \"Topic provided to \" + methodName + \"() must be a string which matches the format \" + '\"/topics/[a-zA-Z0-9-_.~%]+\".');\n    }\n  };\n  /**\n   * Normalizes the provided topic name by prepending it with '/topics/', if necessary.\n   *\n   * @param {string} topic The topic name to normalize.\n   *\n   * @return {string} The normalized topic name.\n   */\n\n\n  Messaging.prototype.normalizeTopic = function (topic) {\n    if (!/^\\/topics\\//.test(topic)) {\n      topic = \"/topics/\" + topic;\n    }\n\n    return topic;\n  };\n\n  return Messaging;\n}();\n\nexports.Messaging = Messaging;","map":null,"metadata":{},"sourceType":"script"}