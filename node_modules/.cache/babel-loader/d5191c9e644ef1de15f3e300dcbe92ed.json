{"ast":null,"code":"module.exports = function () {\n  /*\n   * Generated by PEG.js 0.9.0.\n   *\n   * http://pegjs.org/\n   */\n  function peg$subclass(child, parent) {\n    function ctor() {\n      this.constructor = child;\n    }\n\n    ctor.prototype = parent.prototype;\n    child.prototype = new ctor();\n  }\n\n  function peg$SyntaxError(message, expected, found, location) {\n    this.message = message;\n    this.expected = expected;\n    this.found = found;\n    this.location = location;\n    this.name = 'SyntaxError';\n\n    if (typeof Error.captureStackTrace === 'function') {\n      Error.captureStackTrace(this, peg$SyntaxError);\n    }\n  }\n\n  peg$subclass(peg$SyntaxError, Error);\n\n  function peg$parse(input) {\n    var options = arguments.length > 1 ? arguments[1] : {};\n    var parser = this;\n    var peg$FAILED = {};\n    var peg$startRuleFunctions = {\n      template: peg$parsetemplate\n    };\n    var peg$startRuleFunction = peg$parsetemplate;\n    var peg$c0 = '/';\n    var peg$c1 = {\n      type: 'literal',\n      value: '/',\n      description: '\"/\"'\n    };\n\n    var peg$c2 = function peg$c2(segments) {\n      return segments;\n    };\n\n    var peg$c3 = function peg$c3(s, segments) {\n      return s.concat(segments);\n    };\n\n    var peg$c4 = function peg$c4(s) {\n      return s;\n    };\n\n    var peg$c5 = '{';\n    var peg$c6 = {\n      type: 'literal',\n      value: '{',\n      description: '\"{\"'\n    };\n    var peg$c7 = '=';\n    var peg$c8 = {\n      type: 'literal',\n      value: '=',\n      description: '\"=\"'\n    };\n    var peg$c9 = '}';\n    var peg$c10 = {\n      type: 'literal',\n      value: '}',\n      description: '\"}\"'\n    };\n\n    var peg$c11 = function peg$c11(l, segments) {\n      return [{\n        kind: extras.BINDING,\n        literal: l\n      }, segments, {\n        kind: extras.END_BINDING,\n        literal: ''\n      }].reduce(function (a, b) {\n        return a.concat(b);\n      }, []);\n    };\n\n    var peg$c12 = function peg$c12(l) {\n      return [{\n        kind: extras.BINDING,\n        literal: l\n      }, {\n        kind: extras.TERMINAL,\n        literal: '*'\n      }, {\n        kind: extras.END_BINDING,\n        literal: ''\n      }];\n    };\n\n    var peg$c13 = function peg$c13(t, segments) {\n      return t.concat(segments);\n    };\n\n    var peg$c14 = function peg$c14(t) {\n      if (t[0].literal === '*' || t[0].literal === '**') {\n        return [{\n          kind: extras.BINDING\n        }, t[0], {\n          kind: extras.END_BINDING,\n          literal: ''\n        }];\n      } else {\n        return t;\n      }\n    };\n\n    var peg$c15 = '**';\n    var peg$c16 = {\n      type: 'literal',\n      value: '**',\n      description: '\"**\"'\n    };\n    var peg$c17 = '*';\n    var peg$c18 = {\n      type: 'literal',\n      value: '*',\n      description: '\"*\"'\n    };\n\n    var peg$c19 = function peg$c19(l) {\n      return [{\n        kind: extras.TERMINAL,\n        literal: l\n      }];\n    };\n\n    var peg$c20 = /^[^*=}{\\/]/;\n    var peg$c21 = {\n      type: 'class',\n      value: '[^*=}{/]',\n      description: '[^*=}{/]'\n    };\n\n    var peg$c22 = function peg$c22(cs) {\n      return cs.join('');\n    };\n\n    var peg$currPos = 0;\n    var peg$savedPos = 0;\n    var peg$posDetailsCache = [{\n      line: 1,\n      column: 1,\n      seenCR: false\n    }];\n    var peg$maxFailPos = 0;\n    var peg$maxFailExpected = [];\n    var peg$silentFails = 0;\n    var peg$result;\n\n    if ('startRule' in options) {\n      if (!(options.startRule in peg$startRuleFunctions)) {\n        throw new Error('Can\\'t start parsing from rule \"' + options.startRule + '\".');\n      }\n\n      peg$startRuleFunction = peg$startRuleFunctions[options.startRule];\n    }\n\n    function text() {\n      return input.substring(peg$savedPos, peg$currPos);\n    }\n\n    function location() {\n      return peg$computeLocation(peg$savedPos, peg$currPos);\n    }\n\n    function expected(description) {\n      throw peg$buildException(null, [{\n        type: 'other',\n        description: description\n      }], input.substring(peg$savedPos, peg$currPos), peg$computeLocation(peg$savedPos, peg$currPos));\n    }\n\n    function error(message) {\n      throw peg$buildException(message, null, input.substring(peg$savedPos, peg$currPos), peg$computeLocation(peg$savedPos, peg$currPos));\n    }\n\n    function peg$computePosDetails(pos) {\n      var details = peg$posDetailsCache[pos],\n          p,\n          ch;\n\n      if (details) {\n        return details;\n      } else {\n        p = pos - 1;\n\n        while (!peg$posDetailsCache[p]) {\n          p--;\n        }\n\n        details = peg$posDetailsCache[p];\n        details = {\n          line: details.line,\n          column: details.column,\n          seenCR: details.seenCR\n        };\n\n        while (p < pos) {\n          ch = input.charAt(p);\n\n          if (ch === '\\n') {\n            if (!details.seenCR) {\n              details.line++;\n            }\n\n            details.column = 1;\n            details.seenCR = false;\n          } else if (ch === '\\r' || ch === \"\\u2028\" || ch === \"\\u2029\") {\n            details.line++;\n            details.column = 1;\n            details.seenCR = true;\n          } else {\n            details.column++;\n            details.seenCR = false;\n          }\n\n          p++;\n        }\n\n        peg$posDetailsCache[pos] = details;\n        return details;\n      }\n    }\n\n    function peg$computeLocation(startPos, endPos) {\n      var startPosDetails = peg$computePosDetails(startPos),\n          endPosDetails = peg$computePosDetails(endPos);\n      return {\n        start: {\n          offset: startPos,\n          line: startPosDetails.line,\n          column: startPosDetails.column\n        },\n        end: {\n          offset: endPos,\n          line: endPosDetails.line,\n          column: endPosDetails.column\n        }\n      };\n    }\n\n    function peg$fail(expected) {\n      if (peg$currPos < peg$maxFailPos) {\n        return;\n      }\n\n      if (peg$currPos > peg$maxFailPos) {\n        peg$maxFailPos = peg$currPos;\n        peg$maxFailExpected = [];\n      }\n\n      peg$maxFailExpected.push(expected);\n    }\n\n    function peg$buildException(message, expected, found, location) {\n      function cleanupExpected(expected) {\n        var i = 1;\n        expected.sort(function (a, b) {\n          if (a.description < b.description) {\n            return -1;\n          } else if (a.description > b.description) {\n            return 1;\n          } else {\n            return 0;\n          }\n        });\n\n        while (i < expected.length) {\n          if (expected[i - 1] === expected[i]) {\n            expected.splice(i, 1);\n          } else {\n            i++;\n          }\n        }\n      }\n\n      function buildMessage(expected, found) {\n        function stringEscape(s) {\n          function hex(ch) {\n            return ch.charCodeAt(0).toString(16).toUpperCase();\n          }\n\n          return s.replace(/\\\\/g, '\\\\\\\\').replace(/\"/g, '\\\\\"').replace(/\\x08/g, '\\\\b').replace(/\\t/g, '\\\\t').replace(/\\n/g, '\\\\n').replace(/\\f/g, '\\\\f').replace(/\\r/g, '\\\\r').replace(/[\\x00-\\x07\\x0B\\x0E\\x0F]/g, function (ch) {\n            return '\\\\x0' + hex(ch);\n          }).replace(/[\\x10-\\x1F\\x80-\\xFF]/g, function (ch) {\n            return '\\\\x' + hex(ch);\n          }).replace(/[\\u0100-\\u0FFF]/g, function (ch) {\n            return \"\\\\u0\" + hex(ch);\n          }).replace(/[\\u1000-\\uFFFF]/g, function (ch) {\n            return \"\\\\u\" + hex(ch);\n          });\n        }\n\n        var expectedDescs = new Array(expected.length);\n        var expectedDesc, foundDesc, i;\n\n        for (i = 0; i < expected.length; i++) {\n          expectedDescs[i] = expected[i].description;\n        }\n\n        expectedDesc = expected.length > 1 ? expectedDescs.slice(0, -1).join(', ') + ' or ' + expectedDescs[expected.length - 1] : expectedDescs[0];\n        foundDesc = found ? '\"' + stringEscape(found) + '\"' : 'end of input';\n        return 'Expected ' + expectedDesc + ' but ' + foundDesc + ' found.';\n      }\n\n      if (expected !== null) {\n        cleanupExpected(expected);\n      }\n\n      return new peg$SyntaxError(message !== null ? message : buildMessage(expected, found), expected, found, location);\n    }\n\n    function peg$parsetemplate() {\n      var s0, s1, s2;\n      s0 = peg$currPos;\n\n      if (input.charCodeAt(peg$currPos) === 47) {\n        s1 = peg$c0;\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n\n        if (peg$silentFails === 0) {\n          peg$fail(peg$c1);\n        }\n      }\n\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parsebound_segments();\n\n        if (s2 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c2(s2);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      if (s0 === peg$FAILED) {\n        s0 = peg$currPos;\n        s1 = peg$parsebound_segments();\n\n        if (s1 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c2(s1);\n        }\n\n        s0 = s1;\n      }\n\n      return s0;\n    }\n\n    function peg$parsebound_segments() {\n      var s0, s1, s2, s3;\n      s0 = peg$currPos;\n      s1 = peg$parsebound_segment();\n\n      if (s1 !== peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 47) {\n          s2 = peg$c0;\n          peg$currPos++;\n        } else {\n          s2 = peg$FAILED;\n\n          if (peg$silentFails === 0) {\n            peg$fail(peg$c1);\n          }\n        }\n\n        if (s2 !== peg$FAILED) {\n          s3 = peg$parsebound_segments();\n\n          if (s3 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s1 = peg$c3(s1, s3);\n            s0 = s1;\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      if (s0 === peg$FAILED) {\n        s0 = peg$parsebound_segment();\n      }\n\n      return s0;\n    }\n\n    function peg$parsebound_segment() {\n      var s0, s1;\n      s0 = peg$currPos;\n      s1 = peg$parsebound_terminal();\n\n      if (s1 === peg$FAILED) {\n        s1 = peg$parsevariable();\n      }\n\n      if (s1 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c4(s1);\n      }\n\n      s0 = s1;\n      return s0;\n    }\n\n    function peg$parsevariable() {\n      var s0, s1, s2, s3, s4, s5;\n      s0 = peg$currPos;\n\n      if (input.charCodeAt(peg$currPos) === 123) {\n        s1 = peg$c5;\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n\n        if (peg$silentFails === 0) {\n          peg$fail(peg$c6);\n        }\n      }\n\n      if (s1 !== peg$FAILED) {\n        s2 = peg$parseliteral();\n\n        if (s2 !== peg$FAILED) {\n          if (input.charCodeAt(peg$currPos) === 61) {\n            s3 = peg$c7;\n            peg$currPos++;\n          } else {\n            s3 = peg$FAILED;\n\n            if (peg$silentFails === 0) {\n              peg$fail(peg$c8);\n            }\n          }\n\n          if (s3 !== peg$FAILED) {\n            s4 = peg$parseunbound_segments();\n\n            if (s4 !== peg$FAILED) {\n              if (input.charCodeAt(peg$currPos) === 125) {\n                s5 = peg$c9;\n                peg$currPos++;\n              } else {\n                s5 = peg$FAILED;\n\n                if (peg$silentFails === 0) {\n                  peg$fail(peg$c10);\n                }\n              }\n\n              if (s5 !== peg$FAILED) {\n                peg$savedPos = s0;\n                s1 = peg$c11(s2, s4);\n                s0 = s1;\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      if (s0 === peg$FAILED) {\n        s0 = peg$currPos;\n\n        if (input.charCodeAt(peg$currPos) === 123) {\n          s1 = peg$c5;\n          peg$currPos++;\n        } else {\n          s1 = peg$FAILED;\n\n          if (peg$silentFails === 0) {\n            peg$fail(peg$c6);\n          }\n        }\n\n        if (s1 !== peg$FAILED) {\n          s2 = peg$parseliteral();\n\n          if (s2 !== peg$FAILED) {\n            if (input.charCodeAt(peg$currPos) === 125) {\n              s3 = peg$c9;\n              peg$currPos++;\n            } else {\n              s3 = peg$FAILED;\n\n              if (peg$silentFails === 0) {\n                peg$fail(peg$c10);\n              }\n            }\n\n            if (s3 !== peg$FAILED) {\n              peg$savedPos = s0;\n              s1 = peg$c12(s2);\n              s0 = s1;\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      }\n\n      return s0;\n    }\n\n    function peg$parseunbound_segments() {\n      var s0, s1, s2, s3;\n      s0 = peg$currPos;\n      s1 = peg$parseunbound_terminal();\n\n      if (s1 !== peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 47) {\n          s2 = peg$c0;\n          peg$currPos++;\n        } else {\n          s2 = peg$FAILED;\n\n          if (peg$silentFails === 0) {\n            peg$fail(peg$c1);\n          }\n        }\n\n        if (s2 !== peg$FAILED) {\n          s3 = peg$parseunbound_segments();\n\n          if (s3 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s1 = peg$c13(s1, s3);\n            s0 = s1;\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n\n      if (s0 === peg$FAILED) {\n        s0 = peg$parseunbound_terminal();\n      }\n\n      return s0;\n    }\n\n    function peg$parsebound_terminal() {\n      var s0, s1;\n      s0 = peg$currPos;\n      s1 = peg$parseunbound_terminal();\n\n      if (s1 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c14(s1);\n      }\n\n      s0 = s1;\n      return s0;\n    }\n\n    function peg$parseunbound_terminal() {\n      var s0, s1;\n      s0 = peg$currPos;\n\n      if (input.substr(peg$currPos, 2) === peg$c15) {\n        s1 = peg$c15;\n        peg$currPos += 2;\n      } else {\n        s1 = peg$FAILED;\n\n        if (peg$silentFails === 0) {\n          peg$fail(peg$c16);\n        }\n      }\n\n      if (s1 === peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 42) {\n          s1 = peg$c17;\n          peg$currPos++;\n        } else {\n          s1 = peg$FAILED;\n\n          if (peg$silentFails === 0) {\n            peg$fail(peg$c18);\n          }\n        }\n\n        if (s1 === peg$FAILED) {\n          s1 = peg$parseliteral();\n        }\n      }\n\n      if (s1 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c19(s1);\n      }\n\n      s0 = s1;\n      return s0;\n    }\n\n    function peg$parseliteral() {\n      var s0, s1, s2;\n      s0 = peg$currPos;\n      s1 = [];\n\n      if (peg$c20.test(input.charAt(peg$currPos))) {\n        s2 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s2 = peg$FAILED;\n\n        if (peg$silentFails === 0) {\n          peg$fail(peg$c21);\n        }\n      }\n\n      if (s2 !== peg$FAILED) {\n        while (s2 !== peg$FAILED) {\n          s1.push(s2);\n\n          if (peg$c20.test(input.charAt(peg$currPos))) {\n            s2 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s2 = peg$FAILED;\n\n            if (peg$silentFails === 0) {\n              peg$fail(peg$c21);\n            }\n          }\n        }\n      } else {\n        s1 = peg$FAILED;\n      }\n\n      if (s1 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c22(s1);\n      }\n\n      s0 = s1;\n      return s0;\n    }\n\n    var extras = require('./parser_extras');\n\n    peg$result = peg$startRuleFunction();\n\n    if (peg$result !== peg$FAILED && peg$currPos === input.length) {\n      return peg$result;\n    } else {\n      if (peg$result !== peg$FAILED && peg$currPos < input.length) {\n        peg$fail({\n          type: 'end',\n          description: 'end of input'\n        });\n      }\n\n      throw peg$buildException(null, peg$maxFailExpected, peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null, peg$maxFailPos < input.length ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1) : peg$computeLocation(peg$maxFailPos, peg$maxFailPos));\n    }\n  }\n\n  return {\n    SyntaxError: peg$SyntaxError,\n    parse: peg$parse\n  };\n}();","map":null,"metadata":{},"sourceType":"script"}