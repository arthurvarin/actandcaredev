{"ast":null,"code":"/*!\n * Copyright 2015 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/*!\n * @module common/paginator\n */\n'use strict';\n\nvar arrify = require('arrify');\n\nvar concat = require('concat-stream');\n\nvar extend = require('extend');\n\nvar is = require('is');\n\nvar split = require('split-array-stream');\n/**\n * @type {module:common/util}\n * @private\n */\n\n\nvar util = require('./util.js');\n/*! Developer Documentation\n *\n * paginator is used to auto-paginate `nextQuery` methods as well as\n * streamifying them.\n *\n * Before:\n *\n *   search.query('done=true', function(err, results, nextQuery) {\n *     search.query(nextQuery, function(err, results, nextQuery) {});\n *   });\n *\n * After:\n *\n *   search.query('done=true', function(err, results) {});\n *\n * Methods to extend should be written to accept callbacks and return a\n * `nextQuery`.\n */\n\n\nvar paginator = {};\n/**\n * Cache the original method, then overwrite it on the Class's prototype.\n *\n * @param {function} Class - The parent class of the methods to extend.\n * @param {string|string[]} methodNames - Name(s) of the methods to extend.\n */\n\npaginator.extend = function (Class, methodNames) {\n  methodNames = arrify(methodNames);\n  methodNames.forEach(function (methodName) {\n    var originalMethod = Class.prototype[methodName]; // map the original method to a private member\n\n    Class.prototype[methodName + '_'] = originalMethod; // overwrite the original to auto-paginate\n\n    Class.prototype[methodName] = function () {\n      var parsedArguments = paginator.parseArguments_(arguments);\n      return paginator.run_(parsedArguments, originalMethod.bind(this));\n    };\n  });\n};\n/**\n * Wraps paginated API calls in a readable object stream.\n *\n * This method simply calls the nextQuery recursively, emitting results to a\n * stream. The stream ends when `nextQuery` is null.\n *\n * `maxResults` will act as a cap for how many results are fetched and emitted\n * to the stream.\n *\n * @param {string} methodName - Name of the method to streamify.\n * @return {function} - Wrapped function.\n */\n\n\npaginator.streamify = function (methodName) {\n  return function () {\n    var parsedArguments = paginator.parseArguments_(arguments);\n    var originalMethod = this[methodName + '_'] || this[methodName];\n    return paginator.runAsStream_(parsedArguments, originalMethod.bind(this));\n  };\n};\n/**\n * Parse a pseudo-array `arguments` for a query and callback.\n *\n * @param {array} args - The original `arguments` pseduo-array that the original\n *     method received.\n */\n\n\npaginator.parseArguments_ = function (args) {\n  var query;\n  var autoPaginate = true;\n  var maxApiCalls = -1;\n  var maxResults = -1;\n  var callback;\n  var firstArgument = args[0];\n  var lastArgument = args[args.length - 1];\n\n  if (is.fn(firstArgument)) {\n    callback = firstArgument;\n  } else {\n    query = firstArgument;\n  }\n\n  if (is.fn(lastArgument)) {\n    callback = lastArgument;\n  }\n\n  if (is.object(query)) {\n    query = extend(true, {}, query); // Check if the user only asked for a certain amount of results.\n\n    if (is.number(query.maxResults)) {\n      // `maxResults` is used API-wide.\n      maxResults = query.maxResults;\n    } else if (is.number(query.pageSize)) {\n      // `pageSize` is Pub/Sub's `maxResults`.\n      maxResults = query.pageSize;\n    }\n\n    if (is.number(query.maxApiCalls)) {\n      maxApiCalls = query.maxApiCalls;\n      delete query.maxApiCalls;\n    }\n\n    if (callback && (maxResults !== -1 || // The user specified a limit.\n    query.autoPaginate === false)) {\n      autoPaginate = false;\n    }\n  }\n\n  var parsedArguments = {\n    query: query || {},\n    autoPaginate: autoPaginate,\n    maxApiCalls: maxApiCalls,\n    maxResults: maxResults,\n    callback: callback\n  };\n  parsedArguments.streamOptions = extend(true, {}, parsedArguments.query);\n  delete parsedArguments.streamOptions.autoPaginate;\n  delete parsedArguments.streamOptions.maxResults;\n  delete parsedArguments.streamOptions.pageSize;\n  return parsedArguments;\n};\n/**\n * This simply checks to see if `autoPaginate` is set or not, if it's true\n * then we buffer all results, otherwise simply call the original method.\n *\n * @param {array} parsedArguments - Parsed arguments from the original method\n *     call.\n * @param {object=|string=} parsedArguments.query - Query object. This is most\n *     commonly an object, but to make the API more simple, it can also be a\n *     string in some places.\n * @param {function=} parsedArguments.callback - Callback function.\n * @param {boolean} parsedArguments.autoPaginate - Auto-pagination enabled.\n * @param {boolean} parsedArguments.maxApiCalls - Maximum API calls to make.\n * @param {number} parsedArguments.maxResults - Maximum results to return.\n * @param {function} originalMethod - The cached method that accepts a callback\n *     and returns `nextQuery` to receive more results.\n */\n\n\npaginator.run_ = function (parsedArguments, originalMethod) {\n  var query = parsedArguments.query;\n  var callback = parsedArguments.callback;\n  var autoPaginate = parsedArguments.autoPaginate;\n\n  if (autoPaginate) {\n    this.runAsStream_(parsedArguments, originalMethod).on('error', callback).pipe(concat(function (results) {\n      callback(null, results);\n    }));\n  } else {\n    originalMethod(query, callback);\n  }\n};\n/**\n * This method simply calls the nextQuery recursively, emitting results to a\n * stream. The stream ends when `nextQuery` is null.\n *\n * `maxResults` will act as a cap for how many results are fetched and emitted\n * to the stream.\n *\n * @param {object=|string=} parsedArguments.query - Query object. This is most\n *     commonly an object, but to make the API more simple, it can also be a\n *     string in some places.\n * @param {function=} parsedArguments.callback - Callback function.\n * @param {boolean} parsedArguments.autoPaginate - Auto-pagination enabled.\n * @param {boolean} parsedArguments.maxApiCalls - Maximum API calls to make.\n * @param {number} parsedArguments.maxResults - Maximum results to return.\n * @param {function} originalMethod - The cached method that accepts a callback\n *     and returns `nextQuery` to receive more results.\n * @return {stream} - Readable object stream.\n */\n\n\npaginator.runAsStream_ = function (parsedArguments, originalMethod) {\n  var query = parsedArguments.query;\n  var resultsToSend = parsedArguments.maxResults;\n  var limiter = util.createLimiter(makeRequest, {\n    maxApiCalls: parsedArguments.maxApiCalls,\n    streamOptions: parsedArguments.streamOptions\n  });\n  var stream = limiter.stream;\n  stream.once('reading', function () {\n    makeRequest(query);\n  });\n\n  function makeRequest(query) {\n    originalMethod(query, onResultSet);\n  }\n\n  function onResultSet(err, results, nextQuery) {\n    if (err) {\n      stream.destroy(err);\n      return;\n    }\n\n    if (resultsToSend >= 0 && results.length > resultsToSend) {\n      results = results.splice(0, resultsToSend);\n    }\n\n    resultsToSend -= results.length;\n    split(results, stream, function (streamEnded) {\n      if (streamEnded) {\n        return;\n      }\n\n      if (nextQuery && resultsToSend !== 0) {\n        limiter.makeRequest(nextQuery);\n        return;\n      }\n\n      stream.push(null);\n    });\n  }\n\n  return limiter.stream;\n};\n\nmodule.exports = paginator;","map":null,"metadata":{},"sourceType":"script"}