{"ast":null,"code":"'use strict';\n\nexports.__esModule = true;\n\nvar _fragmentGenerator = require('./fragmentGenerator');\n\nvar _fragmentGenerator2 = _interopRequireDefault(_fragmentGenerator);\n\nvar _Block = require('../models/Block');\n\nvar _Block2 = _interopRequireDefault(_Block);\n\nvar _LineFragment = require('../models/LineFragment');\n\nvar _LineFragment2 = _interopRequireDefault(_LineFragment);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nvar NEW_LINE = 10;\nvar ALIGNMENT_FACTORS = {\n  left: 0,\n  center: 0.5,\n  right: 1,\n  justify: 0\n};\n\nvar finalizeLineFragment = function finalizeLineFragment(engines) {\n  return function (line, style, isLastFragment, isTruncated) {\n    var align = isLastFragment && !isTruncated ? style.alignLastLine : style.align;\n\n    if (isLastFragment && isTruncated && style.truncationMode) {\n      engines.truncationEngine.truncate(line, style.truncationMode);\n    }\n\n    var start = 0;\n    var end = line.length; // Remove new line char at the end of line\n\n    if (line.codePointAtGlyphIndex(line.length - 1) === NEW_LINE) {\n      line.deleteGlyph(line.length - 1);\n    } // Ignore whitespace at the start and end of a line for alignment\n\n\n    while (line.isWhiteSpace(start)) {\n      line.overflowLeft += line.getGlyphWidth(start++);\n    }\n\n    while (line.isWhiteSpace(end - 1)) {\n      line.overflowRight += line.getGlyphWidth(--end);\n    } // Adjust line rect for hanging punctuation\n\n\n    if (style.hangingPunctuation) {\n      if (align === 'left' || align === 'justify') {\n        if (line.isHangingPunctuationStart(start)) {\n          line.overflowLeft += line.getGlyphWidth(start++);\n        }\n      }\n\n      if (align === 'right' || align === 'justify') {\n        if (line.isHangingPunctuationEnd(end - 1)) {\n          line.overflowRight += line.getGlyphWidth(--end);\n        }\n      }\n    }\n\n    line.rect.x -= line.overflowLeft;\n    line.rect.width += line.overflowLeft + line.overflowRight; // Adjust line offset for alignment\n\n    var remainingWidth = line.rect.width - line.advanceWidth;\n    line.rect.x += remainingWidth * ALIGNMENT_FACTORS[align];\n\n    if (align === 'justify' || line.advanceWidth > line.rect.width) {\n      engines.justificationEngine.justify(line, {\n        factor: style.justificationFactor\n      });\n    }\n\n    engines.decorationEngine.createDecorationLines(line);\n  };\n};\n\nvar layoutParagraph = function layoutParagraph(engines) {\n  return function (paragraph, container, lineRect) {\n    var value = paragraph.value,\n        syllables = paragraph.syllables;\n    var style = value.glyphRuns[0].attributes; // Guess the line height using the full line before intersecting with the container.\n    // Generate line fragment rectangles by intersecting with the container.\n\n    var lineHeight = value.slice(0, value.glyphIndexAtOffset(lineRect.width)).height;\n    var fragmentRects = (0, _fragmentGenerator2.default)(lineRect, lineHeight, container);\n    var wrappingWidths = fragmentRects.map(function (rect) {\n      return rect.width;\n    });\n    var lines = engines.lineBreaker.suggestLineBreak(value, syllables, wrappingWidths, style);\n    var currentY = lineRect.y;\n    var lineFragments = lines.map(function (line, i) {\n      var lineBox = fragmentRects[Math.min(i, fragmentRects.length - 1)].copy();\n      var fragmentHeight = Math.max(line.height, style.lineHeight);\n      lineBox.y = currentY;\n      lineBox.height = fragmentHeight;\n      currentY += fragmentHeight;\n      return new _LineFragment2.default(lineBox, line);\n    });\n    lineFragments.forEach(function (lineFragment, i) {\n      finalizeLineFragment(engines)(lineFragment, style, i === lineFragments.length - 1);\n    });\n    return new _Block2.default(lineFragments);\n  };\n};\n\nvar typesetter = function typesetter(engines) {\n  return function (containers) {\n    return function (glyphStrings) {\n      var paragraphs = [].concat(glyphStrings);\n\n      var layoutContainer = function layoutContainer(rect, container) {\n        var paragraphRect = rect.copy();\n        var nextParagraph = paragraphs.shift();\n\n        while (nextParagraph) {\n          var block = layoutParagraph(engines)(nextParagraph, container, paragraphRect);\n\n          if (paragraphRect.height >= block.height) {\n            container.blocks.push(block);\n            paragraphRect = paragraphRect.copy();\n            paragraphRect.y += block.height;\n            paragraphRect.height -= block.height;\n            nextParagraph = paragraphs.shift();\n          } else {\n            paragraphs.unshift(nextParagraph);\n            break;\n          }\n        }\n      };\n\n      return containers.forEach(function (container) {\n        layoutContainer(container.bbox.toRect(), container);\n      });\n    };\n  };\n};\n\nexports.default = typesetter;","map":null,"metadata":{},"sourceType":"script"}