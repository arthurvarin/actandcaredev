{"ast":null,"code":"\"use strict\";\n/*\n *\n * Copyright 2016, Google Inc.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are\n * met:\n *\n *     * Redistributions of source code must retain the above copyright\n * notice, this list of conditions and the following disclaimer.\n *     * Redistributions in binary form must reproduce the above\n * copyright notice, this list of conditions and the following disclaimer\n * in the documentation and/or other materials provided with the\n * distribution.\n *     * Neither the name of Google Inc. nor the names of its\n * contributors may be used to endorse or promote products derived from\n * this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\n */\n\nvar _classCallCheck = require(\"/Users/cvoisin/Repos/actandcaredev/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/cvoisin/Repos/actandcaredev/node_modules/@babel/runtime/helpers/createClass\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/*\n * Path template utility.\n */\n\nvar has = require(\"lodash.has\");\n\nvar util = require(\"util\");\n\nvar extras = require(\"./parser_extras\");\n\nvar parser = require('./path_template_parser');\n\nvar PathTemplate =\n/*#__PURE__*/\nfunction () {\n  _createClass(PathTemplate, [{\n    key: \"size\",\n    get: function get() {\n      return this.parseResult.size;\n    }\n  }, {\n    key: \"segments\",\n    get: function get() {\n      return this.parseResult.segments;\n    }\n    /**\n     * @param {String} data the of the template\n     *\n     * @constructor\n     */\n\n  }]);\n\n  function PathTemplate(data) {\n    _classCallCheck(this, PathTemplate);\n\n    this.parseResult = extras.finishParse(parser.parse(data));\n  }\n  /**\n   * Matches a fully-qualified path template string.\n   *\n   * @param {String} path a fully-qualified path template string\n   * @return {Object} contains const names matched to binding values\n   * @throws {TypeError} if path can't be matched to this template\n   */\n\n\n  _createClass(PathTemplate, [{\n    key: \"match\",\n    value: function match(path) {\n      var pathSegments = path.split('/');\n      var bindings = {};\n      var segmentCount = this.size;\n      var current;\n      var index = 0;\n      this.segments.forEach(function (segment) {\n        if (index > pathSegments.length) {\n          return;\n        }\n\n        if (segment.kind === extras.BINDING) {\n          current = segment.literal;\n        } else if (segment.kind === extras.TERMINAL) {\n          if (segment.literal === '*') {\n            bindings[current] = pathSegments[index];\n            index += 1;\n          } else if (segment.literal === '**') {\n            var size = pathSegments.length - segmentCount + 1;\n            segmentCount += size - 1;\n            bindings[current] = pathSegments.slice(index, index + size).join('/');\n            index += size;\n          } else if (segment.literal === pathSegments[index]) {\n            index += 1;\n          } else {\n            var msg = util.format('mismatched literal (index=%d): \\'%s\\' != \\'%s\\'', index, segment.literal, pathSegments[index]);\n            throw new TypeError(msg);\n          }\n        }\n      });\n\n      if (index !== pathSegments.length || index !== segmentCount) {\n        var msg = util.format('match error: could not instantiate a path template from %s', path);\n        throw new TypeError(msg);\n      }\n\n      return bindings;\n    }\n    /**\n     * Renders a path template using the provided bindings.\n     *\n     * @param {Object} bindings a mapping of const names to binding strings\n     * @return {String} a rendered representation of the path template\n     * @throws {TypeError} if a key is missing, or if a sub-template cannot be\n     *   parsed\n     */\n\n  }, {\n    key: \"render\",\n    value: function render(bindings) {\n      var out = [];\n      var inABinding = false;\n      this.segments.forEach(function (segment) {\n        if (segment.kind === extras.BINDING) {\n          if (!has(bindings, segment.literal)) {\n            var msg = util.format('Value for key %s is not provided in %s', segment.literal, bindings);\n            throw new TypeError(msg);\n          }\n\n          var tmp = new PathTemplate(bindings[segment.literal]);\n          Array.prototype.push.apply(out, tmp.segments);\n          inABinding = true;\n        } else if (segment.kind === extras.END_BINDING) {\n          inABinding = false;\n        } else if (inABinding) {\n          return;\n        } else {\n          out.push(segment);\n        }\n      });\n      var result = formatSegments(out);\n      this.match(result);\n      return result;\n    }\n    /**\n     * Renders the path template.\n     *\n     * @return {string} contains const names matched to binding values\n     */\n\n  }, {\n    key: \"inspect\",\n    value: function inspect() {\n      return formatSegments(this.segments);\n    }\n  }]);\n\n  return PathTemplate;\n}();\n\nexports.PathTemplate = PathTemplate;\n/**\n * Creates the string representattion for the segments.\n * @param {Object[]} segments - The array of segments.\n * @return {string} - A string representing segments in the path template\n *   format.\n */\n\nfunction formatSegments(segments) {\n  var out = '';\n  var slash = true;\n  segments.forEach(function (segment) {\n    if (segment.kind === extras.TERMINAL) {\n      if (slash) {\n        out += '/';\n      }\n\n      out += segment.literal;\n      return;\n    }\n\n    slash = true;\n\n    if (segment.kind === extras.BINDING) {\n      out += '/{' + segment.literal + '=';\n      slash = false;\n    } else {\n      out += segment.literal + '}';\n    }\n  });\n  return out.substring(1);\n}","map":null,"metadata":{},"sourceType":"script"}