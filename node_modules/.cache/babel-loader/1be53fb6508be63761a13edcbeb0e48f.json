{"ast":null,"code":"\"use strict\";\n/*!\n * Copyright 2017 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nvar _classCallCheck = require(\"/Users/cvoisin/Repos/actandcaredev/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/cvoisin/Repos/actandcaredev/node_modules/@babel/runtime/helpers/createClass\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar assert = require(\"assert\");\n\nvar rbtree = require(\"functional-red-black-tree\");\n\nvar through2 = require(\"through2\");\n\nvar backoff_1 = require(\"./backoff\");\n\nvar document_1 = require(\"./document\");\n\nvar document_change_1 = require(\"./document-change\");\n\nvar logger_1 = require(\"./logger\");\n\nvar path_1 = require(\"./path\");\n\nvar timestamp_1 = require(\"./timestamp\");\n\nvar util_1 = require(\"./util\");\n\nvar types_1 = require(\"./types\");\n/*!\n * Target ID used by watch. Watch uses a fixed target id since we only support\n * one target per stream.\n *\n * @private\n * @type {number}\n */\n\n\nvar WATCH_TARGET_ID = 0x1;\n/*!\n * The change type for document change events.\n */\n// tslint:disable-next-line:variable-name\n\nvar ChangeType = {\n  added: 'added',\n  modified: 'modified',\n  removed: 'removed'\n};\n/*!\n * List of GRPC Error Codes.\n *\n * This corresponds to\n * {@link https://github.com/grpc/grpc/blob/master/doc/statuscodes.md}.\n */\n\nvar GRPC_STATUS_CODE = {\n  // Not an error; returned on success.\n  OK: 0,\n  // The operation was cancelled (typically by the caller).\n  CANCELLED: 1,\n  // Unknown error. An example of where this error may be returned is if a\n  // Status value received from another address space belongs to an error-space\n  // that is not known in this address space. Also errors raised by APIs that\n  // do not return enough error information may be converted to this error.\n  UNKNOWN: 2,\n  // Client specified an invalid argument. Note that this differs from\n  // FAILED_PRECONDITION. INVALID_ARGUMENT indicates arguments that are\n  // problematic regardless of the state of the system (e.g., a malformed file\n  // name).\n  INVALID_ARGUMENT: 3,\n  // Deadline expired before operation could complete. For operations that\n  // change the state of the system, this error may be returned even if the\n  // operation has completed successfully. For example, a successful response\n  // from a server could have been delayed long enough for the deadline to\n  // expire.\n  DEADLINE_EXCEEDED: 4,\n  // Some requested entity (e.g., file or directory) was not found.\n  NOT_FOUND: 5,\n  // Some entity that we attempted to create (e.g., file or directory) already\n  // exists.\n  ALREADY_EXISTS: 6,\n  // The caller does not have permission to execute the specified operation.\n  // PERMISSION_DENIED must not be used for rejections caused by exhausting\n  // some resource (use RESOURCE_EXHAUSTED instead for those errors).\n  // PERMISSION_DENIED must not be used if the caller can not be identified\n  // (use UNAUTHENTICATED instead for those errors).\n  PERMISSION_DENIED: 7,\n  // The request does not have valid authentication credentials for the\n  // operation.\n  UNAUTHENTICATED: 16,\n  // Some resource has been exhausted, perhaps a per-user quota, or perhaps the\n  // entire file system is out of space.\n  RESOURCE_EXHAUSTED: 8,\n  // Operation was rejected because the system is not in a state required for\n  // the operation's execution. For example, directory to be deleted may be\n  // non-empty, an rmdir operation is applied to a non-directory, etc.\n  //\n  // A litmus test that may help a service implementor in deciding\n  // between FAILED_PRECONDITION, ABORTED, and UNAVAILABLE:\n  //  (a) Use UNAVAILABLE if the client can retry just the failing call.\n  //  (b) Use ABORTED if the client should retry at a higher-level\n  //      (e.g., restarting a read-modify-write sequence).\n  //  (c) Use FAILED_PRECONDITION if the client should not retry until\n  //      the system state has been explicitly fixed. E.g., if an \"rmdir\"\n  //      fails because the directory is non-empty, FAILED_PRECONDITION\n  //      should be returned since the client should not retry unless\n  //      they have first fixed up the directory by deleting files from it.\n  //  (d) Use FAILED_PRECONDITION if the client performs conditional\n  //      REST Get/Update/Delete on a resource and the resource on the\n  //      server does not match the condition. E.g., conflicting\n  //      read-modify-write on the same resource.\n  FAILED_PRECONDITION: 9,\n  // The operation was aborted, typically due to a concurrency issue like\n  // sequencer check failures, transaction aborts, etc.\n  //\n  // See litmus test above for deciding between FAILED_PRECONDITION, ABORTED,\n  // and UNAVAILABLE.\n  ABORTED: 10,\n  // Operation was attempted past the valid range. E.g., seeking or reading\n  // past end of file.\n  //\n  // Unlike INVALID_ARGUMENT, this error indicates a problem that may be fixed\n  // if the system state changes. For example, a 32-bit file system will\n  // generate INVALID_ARGUMENT if asked to read at an offset that is not in the\n  // range [0,2^32-1], but it will generate OUT_OF_RANGE if asked to read from\n  // an offset past the current file size.\n  //\n  // There is a fair bit of overlap between FAILED_PRECONDITION and\n  // OUT_OF_RANGE. We recommend using OUT_OF_RANGE (the more specific error)\n  // when it applies so that callers who are iterating through a space can\n  // easily look for an OUT_OF_RANGE error to detect when they are done.\n  OUT_OF_RANGE: 11,\n  // Operation is not implemented or not supported/enabled in this service.\n  UNIMPLEMENTED: 12,\n  // Internal errors. Means some invariants expected by underlying System has\n  // been broken. If you see one of these errors, Something is very broken.\n  INTERNAL: 13,\n  // The service is currently unavailable. This is a most likely a transient\n  // condition and may be corrected by retrying with a backoff.\n  //\n  // See litmus test above for deciding between FAILED_PRECONDITION, ABORTED,\n  // and UNAVAILABLE.\n  UNAVAILABLE: 14,\n  // Unrecoverable data loss or corruption.\n  DATA_LOSS: 15,\n  // Force users to include a default branch:\n  DO_NOT_USE: -1\n};\n/*!\n * The comparator used for document watches (which should always get called with\n * the same document).\n */\n\nvar DOCUMENT_WATCH_COMPARATOR = function DOCUMENT_WATCH_COMPARATOR(doc1, doc2) {\n  assert(doc1 === doc2, 'Document watches only support one document.');\n  return 0;\n};\n/**\n * Watch provides listen functionality and exposes the 'onSnapshot' observer. It\n * can be used with a valid Firestore Listen target.\n *\n * @class\n * @private\n */\n\n\nvar Watch =\n/*#__PURE__*/\nfunction () {\n  /**\n   * @private\n   * @hideconstructor\n   *\n   * @param firestore The Firestore Database client.\n   * @param target A Firestore 'Target' proto denoting the target to listen on.\n   * @param comparator A comparator for QueryDocumentSnapshots that is used to\n   * order the document snapshots returned by this watch.\n   */\n  function Watch(firestore, target, comparator) {\n    _classCallCheck(this, Watch);\n\n    this._firestore = firestore;\n    this._target = target;\n    this._comparator = comparator;\n    this._backoff = new backoff_1.ExponentialBackoff();\n    this._requestTag = util_1.requestTag();\n  }\n  /**\n   * Creates a new Watch instance to listen on DocumentReferences.\n   *\n   * @private\n   * @param  documentRef - The document reference for this watch.\n   * @returns A newly created Watch instance.\n   */\n\n\n  _createClass(Watch, [{\n    key: \"isPermanentError\",\n\n    /**\n     * Determines whether an error is considered permanent and should not be\n     * retried. Errors that don't provide a GRPC error code are always considered\n     * transient in this context.\n     *\n     * @private\n     * @param error An error object.\n     * @return Whether the error is permanent.\n     */\n    value: function isPermanentError(error) {\n      if (error.code === undefined) {\n        logger_1.logger('Watch.onSnapshot', this._requestTag, 'Unable to determine error code: ', error);\n        return false;\n      }\n\n      switch (error.code) {\n        case GRPC_STATUS_CODE.CANCELLED:\n        case GRPC_STATUS_CODE.UNKNOWN:\n        case GRPC_STATUS_CODE.DEADLINE_EXCEEDED:\n        case GRPC_STATUS_CODE.RESOURCE_EXHAUSTED:\n        case GRPC_STATUS_CODE.INTERNAL:\n        case GRPC_STATUS_CODE.UNAVAILABLE:\n        case GRPC_STATUS_CODE.UNAUTHENTICATED:\n          return false;\n\n        default:\n          return true;\n      }\n    }\n    /**\n     * Determines whether we need to initiate a longer backoff due to system\n     * overload.\n     *\n     * @private\n     * @param error A GRPC Error object that exposes an error code.\n     * @return Whether we need to back off our retries.\n     */\n\n  }, {\n    key: \"isResourceExhaustedError\",\n    value: function isResourceExhaustedError(error) {\n      return error.code === GRPC_STATUS_CODE.RESOURCE_EXHAUSTED;\n    }\n    /**\n     * Starts a watch and attaches a listener for document change events.\n     *\n     * @private\n     * @param onNext A callback to be called every time a new snapshot is\n     * available.\n     * @param onError A callback to be called if the listen fails or is cancelled.\n     * No further callbacks will occur.\n     *\n     * @returns An unsubscribe function that can be called to cancel the snapshot\n     * listener.\n     */\n\n  }, {\n    key: \"onSnapshot\",\n    value: function onSnapshot(onNext, onError) {\n      var _this = this;\n\n      // The sorted tree of QueryDocumentSnapshots as sent in the last snapshot.\n      // We only look at the keys.\n      var docTree = rbtree(this._comparator); // A map of document names to QueryDocumentSnapshots for the last sent\n      // snapshot.\n\n      var docMap = new Map(); // The accumulates map of document changes (keyed by document name) for the\n      // current snapshot.\n\n      var changeMap = new Map(); // The current state of the query results.\n\n      var current = false; // We need this to track whether we've pushed an initial set of changes,\n      // since we should push those even when there are no changes, if there \\\n      // aren't docs.\n\n      var hasPushed = false; // The server assigns and updates the resume token.\n\n      var resumeToken = null; // Indicates whether we are interested in data from the stream. Set to false\n      // in the 'unsubscribe()' callback.\n\n      var isActive = true; // Sentinel value for a document remove.\n\n      var REMOVED = {};\n      var request = {\n        database: this._firestore.formattedName,\n        addTarget: this._target\n      }; // We may need to replace the underlying stream on reset events.\n      // This is the one that will be returned and proxy the current one.\n\n      var stream = through2.obj(); // The current stream to the backend.\n\n      var currentStream = null;\n      /** Helper to clear the docs on RESET or filter mismatch. */\n\n      var resetDocs = function resetDocs() {\n        logger_1.logger('Watch.onSnapshot', _this._requestTag, 'Resetting documents');\n        changeMap.clear();\n        resumeToken = null;\n        docTree.forEach(function (snapshot) {\n          // Mark each document as deleted. If documents are not deleted, they\n          // will be send again by the server.\n          changeMap.set(snapshot.ref.formattedName, REMOVED);\n        });\n        current = false;\n      };\n      /** Closes the stream and calls onError() if the stream is still active. */\n\n\n      var closeStream = function closeStream(err) {\n        if (currentStream) {\n          currentStream.unpipe(stream);\n          currentStream.end();\n          currentStream = null;\n        }\n\n        stream.end();\n\n        if (isActive) {\n          isActive = false;\n          logger_1.logger('Watch.onSnapshot', _this._requestTag, 'Invoking onError: ', err);\n          onError(err);\n        }\n      };\n      /**\n       * Re-opens the stream unless the specified error is considered permanent.\n       * Clears the change map.\n       */\n\n\n      var maybeReopenStream = function maybeReopenStream(err) {\n        if (isActive && !_this.isPermanentError(err)) {\n          logger_1.logger('Watch.onSnapshot', _this._requestTag, 'Stream ended, re-opening after retryable error: ', err);\n          request.addTarget.resumeToken = resumeToken;\n          changeMap.clear();\n\n          if (_this.isResourceExhaustedError(err)) {\n            _this._backoff.resetToMax();\n          }\n\n          resetStream();\n        } else {\n          closeStream(err);\n        }\n      };\n      /** Helper to restart the outgoing stream to the backend. */\n\n\n      var resetStream = function resetStream() {\n        logger_1.logger('Watch.onSnapshot', _this._requestTag, 'Opening new stream');\n\n        if (currentStream) {\n          currentStream.unpipe(stream);\n          currentStream.end();\n          currentStream = null;\n          initStream();\n        }\n      };\n      /**\n       * Initializes a new stream to the backend with backoff.\n       */\n\n\n      var initStream = function initStream() {\n        _this._backoff.backoffAndWait().then(function () {\n          if (!isActive) {\n            logger_1.logger('Watch.onSnapshot', _this._requestTag, 'Not initializing inactive stream');\n            return;\n          } // Note that we need to call the internal _listen API to pass additional\n          // header values in readWriteStream.\n\n\n          _this._firestore.readWriteStream('listen', request, _this._requestTag, true).then(function (backendStream) {\n            if (!isActive) {\n              logger_1.logger('Watch.onSnapshot', _this._requestTag, 'Closing inactive stream');\n              backendStream.end();\n              return;\n            }\n\n            logger_1.logger('Watch.onSnapshot', _this._requestTag, 'Opened new stream');\n            currentStream = backendStream;\n            currentStream.on('error', function (err) {\n              maybeReopenStream(err);\n            });\n            currentStream.on('end', function () {\n              var err = new types_1.GrpcError('Stream ended unexpectedly');\n              err.code = GRPC_STATUS_CODE.UNKNOWN;\n              maybeReopenStream(err);\n            });\n            currentStream.pipe(stream);\n            currentStream.resume();\n          }).catch(closeStream);\n        });\n      };\n      /**\n       * Checks if the current target id is included in the list of target ids.\n       * If no targetIds are provided, returns true.\n       */\n\n\n      function affectsTarget(targetIds, currentId) {\n        if (targetIds === undefined || targetIds.length === 0) {\n          return true;\n        }\n\n        var _iteratorNormalCompletion = true;\n        var _didIteratorError = false;\n        var _iteratorError = undefined;\n\n        try {\n          for (var _iterator = targetIds[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n            var targetId = _step.value;\n\n            if (targetId === currentId) {\n              return true;\n            }\n          }\n        } catch (err) {\n          _didIteratorError = true;\n          _iteratorError = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion && _iterator.return != null) {\n              _iterator.return();\n            }\n          } finally {\n            if (_didIteratorError) {\n              throw _iteratorError;\n            }\n          }\n        }\n\n        return false;\n      }\n      /** Splits up document changes into removals, additions, and updates. */\n\n\n      function extractChanges(docMap, changes, readTime) {\n        var deletes = [];\n        var adds = [];\n        var updates = [];\n        changes.forEach(function (value, name) {\n          if (value === REMOVED) {\n            if (docMap.has(name)) {\n              deletes.push(name);\n            }\n          } else if (docMap.has(name)) {\n            value.readTime = readTime;\n            updates.push(value.build());\n          } else {\n            value.readTime = readTime;\n            adds.push(value.build());\n          }\n        });\n        return {\n          deletes: deletes,\n          adds: adds,\n          updates: updates\n        };\n      }\n      /**\n       * Applies the mutations in changeMap to both the document tree and the\n       * document lookup map. Modified docMap in-place and returns the updated\n       * state.\n       */\n\n\n      var computeSnapshot = function computeSnapshot(docTree, docMap, changes) {\n        var updatedTree = docTree;\n        var updatedMap = docMap;\n        assert(docTree.length === docMap.size, 'The document tree and document ' + 'map should have the same number of entries.');\n        /**\n         * Applies a document delete to the document tree and the document\n         * map. Returns the corresponding DocumentChange event.\n         */\n\n        function deleteDoc(name) {\n          assert(updatedMap.has(name), 'Document to delete does not exist');\n          var oldDocument = updatedMap.get(name);\n          var existing = updatedTree.find(oldDocument);\n          var oldIndex = existing.index;\n          updatedTree = existing.remove();\n          updatedMap.delete(name);\n          return new document_change_1.DocumentChange(ChangeType.removed, oldDocument, oldIndex, -1);\n        }\n        /**\n         * Applies a document add to the document tree and the document map.\n         * Returns the corresponding DocumentChange event.\n         */\n\n\n        function addDoc(newDocument) {\n          var name = newDocument.ref.formattedName;\n          assert(!updatedMap.has(name), 'Document to add already exists');\n          updatedTree = updatedTree.insert(newDocument, null);\n          var newIndex = updatedTree.find(newDocument).index;\n          updatedMap.set(name, newDocument);\n          return new document_change_1.DocumentChange(ChangeType.added, newDocument, -1, newIndex);\n        }\n        /**\n         * Applies a document modification to the document tree and the\n         * document map. Returns the DocumentChange event for successful\n         * modifications.\n         */\n\n\n        function modifyDoc(newDocument) {\n          var name = newDocument.ref.formattedName;\n          assert(updatedMap.has(name), 'Document to modify does not exist');\n          var oldDocument = updatedMap.get(name);\n\n          if (!oldDocument.updateTime.isEqual(newDocument.updateTime)) {\n            var removeChange = deleteDoc(name);\n            var addChange = addDoc(newDocument);\n            return new document_change_1.DocumentChange(ChangeType.modified, newDocument, removeChange.oldIndex, addChange.newIndex);\n          }\n\n          return null;\n        } // Process the sorted changes in the order that is expected by our\n        // clients (removals, additions, and then modifications). We also need\n        // to sort the individual changes to assure that oldIndex/newIndex\n        // keep incrementing.\n\n\n        var appliedChanges = [];\n        changes.deletes.sort(function (name1, name2) {\n          // Deletes are sorted based on the order of the existing document.\n          return _this._comparator(updatedMap.get(name1), updatedMap.get(name2));\n        });\n        changes.deletes.forEach(function (name) {\n          var change = deleteDoc(name);\n          appliedChanges.push(change);\n        });\n        changes.adds.sort(_this._comparator);\n        changes.adds.forEach(function (snapshot) {\n          var change = addDoc(snapshot);\n          appliedChanges.push(change);\n        });\n        changes.updates.sort(_this._comparator);\n        changes.updates.forEach(function (snapshot) {\n          var change = modifyDoc(snapshot);\n\n          if (change) {\n            appliedChanges.push(change);\n          }\n        });\n        assert(updatedTree.length === updatedMap.size, 'The update document ' + 'tree and document map should have the same number of entries.');\n        return {\n          updatedTree: updatedTree,\n          updatedMap: updatedMap,\n          appliedChanges: appliedChanges\n        };\n      };\n      /**\n       * Assembles a new snapshot from the current set of changes and invokes the\n       * user's callback. Clears the current changes on completion.\n       */\n\n\n      var push = function push(readTime, nextResumeToken) {\n        var changes = extractChanges(docMap, changeMap, readTime);\n        var diff = computeSnapshot(docTree, docMap, changes);\n\n        if (!hasPushed || diff.appliedChanges.length > 0) {\n          logger_1.logger('Watch.onSnapshot', _this._requestTag, 'Sending snapshot with %d changes and %d documents', String(diff.appliedChanges.length), diff.updatedTree.length);\n          onNext(readTime, diff.updatedTree.length, function () {\n            return diff.updatedTree.keys;\n          }, function () {\n            return diff.appliedChanges;\n          });\n          hasPushed = true;\n        }\n\n        docTree = diff.updatedTree;\n        docMap = diff.updatedMap;\n        changeMap.clear();\n        resumeToken = nextResumeToken;\n      };\n      /**\n       * Returns the current count of all documents, including the changes from\n       * the current changeMap.\n       */\n\n\n      function currentSize() {\n        var changes = extractChanges(docMap, changeMap, timestamp_1.Timestamp.now());\n        return docMap.size + changes.adds.length - changes.deletes.length;\n      }\n\n      initStream();\n      stream.on('data', function (proto) {\n        if (proto.targetChange) {\n          logger_1.logger('Watch.onSnapshot', _this._requestTag, 'Processing target change');\n          var change = proto.targetChange;\n          var noTargetIds = !change.targetIds || change.targetIds.length === 0;\n\n          if (change.targetChangeType === 'NO_CHANGE') {\n            if (noTargetIds && change.readTime && current) {\n              // This means everything is up-to-date, so emit the current\n              // set of docs as a snapshot, if there were changes.\n              push(timestamp_1.Timestamp.fromProto(change.readTime), change.resumeToken);\n            }\n          } else if (change.targetChangeType === 'ADD') {\n            if (WATCH_TARGET_ID !== change.targetIds[0]) {\n              closeStream(Error('Unexpected target ID sent by server'));\n            }\n          } else if (change.targetChangeType === 'REMOVE') {\n            var code = 13;\n            var message = 'internal error';\n\n            if (change.cause) {\n              code = change.cause.code;\n              message = change.cause.message;\n            } // @todo: Surface a .code property on the exception.\n\n\n            closeStream(new Error('Error ' + code + ': ' + message));\n          } else if (change.targetChangeType === 'RESET') {\n            // Whatever changes have happened so far no longer matter.\n            resetDocs();\n          } else if (change.targetChangeType === 'CURRENT') {\n            current = true;\n          } else {\n            closeStream(new Error('Unknown target change type: ' + JSON.stringify(change)));\n          }\n\n          if (change.resumeToken && affectsTarget(change.targetIds, WATCH_TARGET_ID)) {\n            _this._backoff.reset();\n          }\n        } else if (proto.documentChange) {\n          logger_1.logger('Watch.onSnapshot', _this._requestTag, 'Processing change event'); // No other targetIds can show up here, but we still need to see\n          // if the targetId was in the added list or removed list.\n\n          var targetIds = proto.documentChange.targetIds || [];\n          var removedTargetIds = proto.documentChange.removedTargetIds || [];\n          var changed = false;\n          var removed = false;\n\n          for (var i = 0; i < targetIds.length; i++) {\n            if (targetIds[i] === WATCH_TARGET_ID) {\n              changed = true;\n            }\n          }\n\n          for (var _i = 0; _i < removedTargetIds.length; _i++) {\n            if (removedTargetIds[_i] === WATCH_TARGET_ID) {\n              removed = true;\n            }\n          }\n\n          var document = proto.documentChange.document;\n          var name = document.name;\n\n          if (changed) {\n            logger_1.logger('Watch.onSnapshot', _this._requestTag, 'Received document change');\n            var snapshot = new document_1.DocumentSnapshotBuilder();\n            snapshot.ref = _this._firestore.doc(path_1.ResourcePath.fromSlashSeparatedString(name).relativeName);\n            snapshot.fieldsProto = document.fields || {};\n            snapshot.createTime = timestamp_1.Timestamp.fromProto(document.createTime);\n            snapshot.updateTime = timestamp_1.Timestamp.fromProto(document.updateTime);\n            changeMap.set(name, snapshot);\n          } else if (removed) {\n            logger_1.logger('Watch.onSnapshot', _this._requestTag, 'Received document remove');\n            changeMap.set(name, REMOVED);\n          }\n        } else if (proto.documentDelete || proto.documentRemove) {\n          logger_1.logger('Watch.onSnapshot', _this._requestTag, 'Processing remove event');\n          var _name = (proto.documentDelete || proto.documentRemove).document;\n          changeMap.set(_name, REMOVED);\n        } else if (proto.filter) {\n          logger_1.logger('Watch.onSnapshot', _this._requestTag, 'Processing filter update');\n\n          if (proto.filter.count !== currentSize()) {\n            // We need to remove all the current results.\n            resetDocs(); // The filter didn't match, so re-issue the query.\n\n            resetStream();\n          }\n        } else {\n          closeStream(new Error('Unknown listen response type: ' + JSON.stringify(proto)));\n        }\n      }).on('end', function () {\n        logger_1.logger('Watch.onSnapshot', _this._requestTag, 'Processing stream end');\n\n        if (currentStream) {\n          // Pass the event on to the underlying stream.\n          currentStream.end();\n        }\n      });\n      return function () {\n        logger_1.logger('Watch.onSnapshot', _this._requestTag, 'Ending stream'); // Prevent further callbacks.\n\n        isActive = false;\n\n        onNext = function onNext() {};\n\n        onError = function onError() {};\n\n        stream.end();\n      };\n    }\n  }], [{\n    key: \"forDocument\",\n    value: function forDocument(documentRef) {\n      return new Watch(documentRef.firestore, {\n        documents: {\n          documents: [documentRef.formattedName]\n        },\n        targetId: WATCH_TARGET_ID\n      }, DOCUMENT_WATCH_COMPARATOR);\n    }\n    /**\n     * Creates a new Watch instance to listen on Queries.\n     *\n     * @private\n     * @param query The query used for this watch.\n     * @returns A newly created Watch instance.\n     */\n\n  }, {\n    key: \"forQuery\",\n    value: function forQuery(query) {\n      return new Watch(query.firestore, {\n        query: query.toProto(),\n        targetId: WATCH_TARGET_ID\n      }, query.comparator());\n    }\n  }]);\n\n  return Watch;\n}();\n\nexports.Watch = Watch;","map":null,"metadata":{},"sourceType":"script"}