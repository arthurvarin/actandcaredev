{"ast":null,"code":"\"use strict\";\n/*\n * Copyright 2016, Google Inc.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are\n * met:\n *\n *     * Redistributions of source code must retain the above copyright\n * notice, this list of conditions and the following disclaimer.\n *     * Redistributions in binary form must reproduce the above\n * copyright notice, this list of conditions and the following disclaimer\n * in the documentation and/or other materials provided with the\n * distribution.\n *     * Neither the name of Google Inc. nor the names of its\n * contributors may be used to endorse or promote products derived from\n * this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\nvar _possibleConstructorReturn = require(\"/Users/cvoisin/Repos/actandcaredev/node_modules/@babel/runtime/helpers/possibleConstructorReturn\");\n\nvar _getPrototypeOf = require(\"/Users/cvoisin/Repos/actandcaredev/node_modules/@babel/runtime/helpers/getPrototypeOf\");\n\nvar _inherits = require(\"/Users/cvoisin/Repos/actandcaredev/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _classCallCheck = require(\"/Users/cvoisin/Repos/actandcaredev/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/cvoisin/Repos/actandcaredev/node_modules/@babel/runtime/helpers/createClass\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar events_1 = require(\"events\");\n\nvar api_callable_1 = require(\"./api_callable\");\n\nvar gax_1 = require(\"./gax\");\n\nvar GoogleError_1 = require(\"./GoogleError\");\n\nvar LongrunningDescriptor =\n/*#__PURE__*/\nfunction () {\n  /**\n   * Describes the structure of a page-streaming call.\n   *\n   * @property {OperationsClient} operationsClient\n   * @property {anyDecoder} responseDecoder\n   * @property {anyDecoder} metadataDecoder\n   *\n   * @param {OperationsClient} operationsClient - The client used to poll or\n   *   cancel an operation.\n   * @param {anyDecoder=} responseDecoder - The decoder to unpack\n   *   the response message.\n   * @param {anyDecoder=} metadataDecoder - The decoder to unpack\n   *   the metadata message.\n   *\n   * @constructor\n   */\n  function LongrunningDescriptor(operationsClient, responseDecoder, metadataDecoder) {\n    _classCallCheck(this, LongrunningDescriptor);\n\n    this.operationsClient = operationsClient;\n    this.responseDecoder = responseDecoder;\n    this.metadataDecoder = metadataDecoder;\n  }\n\n  _createClass(LongrunningDescriptor, [{\n    key: \"apiCaller\",\n    value: function apiCaller() {\n      return new LongrunningApiCaller(this);\n    }\n  }]);\n\n  return LongrunningDescriptor;\n}();\n\nexports.LongrunningDescriptor = LongrunningDescriptor;\n\nvar LongrunningApiCaller =\n/*#__PURE__*/\nfunction (_api_callable_1$Norma) {\n  _inherits(LongrunningApiCaller, _api_callable_1$Norma);\n\n  /**\n   * Creates an API caller that performs polling on a long running operation.\n   *\n   * @private\n   * @constructor\n   * @param {LongrunningDescriptor} longrunningDescriptor - Holds the\n   * decoders used for unpacking responses and the operationsClient\n   * used for polling the operation.\n   */\n  function LongrunningApiCaller(longrunningDescriptor) {\n    var _this;\n\n    _classCallCheck(this, LongrunningApiCaller);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(LongrunningApiCaller).call(this));\n    _this.longrunningDescriptor = longrunningDescriptor;\n    return _this;\n  }\n\n  _createClass(LongrunningApiCaller, [{\n    key: \"call\",\n    value: function call(apiCall, argument, settings, canceller) {\n      var _this2 = this;\n\n      canceller.call(function (argument, callback) {\n        return _this2._wrapOperation(apiCall, settings, argument, callback);\n      }, argument);\n    }\n  }, {\n    key: \"_wrapOperation\",\n    value: function _wrapOperation(apiCall, settings, argument, callback) {\n      // TODO: this code defies all logic, and just can't be accurate.\n      // tslint:disable-next-line no-any\n      var backoffSettings = settings.longrunning;\n\n      if (!backoffSettings) {\n        backoffSettings = gax_1.createBackoffSettings(100, 1.3, 60000, null, null, null, null);\n      }\n\n      var longrunningDescriptor = this.longrunningDescriptor;\n      return apiCall(argument, function (err, rawResponse) {\n        if (err) {\n          callback(err, null, rawResponse);\n          return;\n        }\n\n        var operation = new Operation(rawResponse, longrunningDescriptor, backoffSettings, settings);\n        callback(null, operation, rawResponse);\n      });\n    }\n  }]);\n\n  return LongrunningApiCaller;\n}(api_callable_1.NormalApiCaller);\n\nexports.LongrunningApiCaller = LongrunningApiCaller;\n\nvar Operation =\n/*#__PURE__*/\nfunction (_events_1$EventEmitte) {\n  _inherits(Operation, _events_1$EventEmitte);\n\n  /**\n   * Wrapper for a google.longrunnung.Operation.\n   *\n   * @constructor\n   *\n   * @param {google.longrunning.Operation} grpcOp - The operation to be wrapped.\n   * @param {LongrunningDescriptor} longrunningDescriptor - This defines the\n   * operations service client and unpacking mechanisms for the operation.\n   * @param {BackoffSettings} backoffSettings - The backoff settings used in\n   * in polling the operation.\n   * @param {CallOptions=} callOptions - CallOptions used in making get operation\n   * requests.\n   */\n  function Operation(grpcOp, longrunningDescriptor, backoffSettings, callOptions) {\n    var _this3;\n\n    _classCallCheck(this, Operation);\n\n    _this3 = _possibleConstructorReturn(this, _getPrototypeOf(Operation).call(this));\n    _this3.completeListeners = 0;\n    _this3.hasActiveListeners = false;\n    _this3.latestResponse = grpcOp;\n    _this3.longrunningDescriptor = longrunningDescriptor;\n    _this3.result = null;\n    _this3.metadata = null;\n    _this3.backoffSettings = backoffSettings;\n\n    _this3._unpackResponse(grpcOp);\n\n    _this3._listenForEvents();\n\n    _this3._callOptions = callOptions;\n    return _this3;\n  }\n  /**\n   * Begin listening for events on the operation. This method keeps track of how\n   * many \"complete\" listeners are registered and removed, making sure polling\n   * is handled automatically.\n   *\n   * As long as there is one active \"complete\" listener, the connection is open.\n   * When there are no more listeners, the polling stops.\n   *\n   * @private\n   */\n\n\n  _createClass(Operation, [{\n    key: \"_listenForEvents\",\n    value: function _listenForEvents() {\n      var _this4 = this;\n\n      this.on('newListener', function (event) {\n        if (event === 'complete') {\n          _this4.completeListeners++;\n\n          if (!_this4.hasActiveListeners) {\n            _this4.hasActiveListeners = true;\n\n            _this4.startPolling_();\n          }\n        }\n      });\n      this.on('removeListener', function (event) {\n        if (event === 'complete' && --_this4.completeListeners === 0) {\n          _this4.hasActiveListeners = false;\n        }\n      });\n    }\n    /**\n     * Cancels current polling api call and cancels the operation.\n     *\n     * @return {Promise} the promise of the OperationsClient#cancelOperation api\n     * request.\n     */\n\n  }, {\n    key: \"cancel\",\n    value: function cancel() {\n      if (this.currentCallPromise_) {\n        this.currentCallPromise_.cancel();\n      }\n\n      var operationsClient = this.longrunningDescriptor.operationsClient;\n      return operationsClient.cancelOperation({\n        name: this.latestResponse.name\n      });\n    }\n  }, {\n    key: \"getOperation\",\n    value: function getOperation(callback) {\n      var self = this;\n      var operationsClient = this.longrunningDescriptor.operationsClient;\n\n      function promisifyResponse() {\n        if (!callback) {\n          // tslint:disable-next-line variable-name\n          var PromiseCtor = self._callOptions.promise;\n          return new PromiseCtor(function (resolve, reject) {\n            if (self.latestResponse.error) {\n              var error = new GoogleError_1.GoogleError(self.latestResponse.error.message);\n              error.code = self.latestResponse.error.code;\n              reject(error);\n            } else {\n              resolve([self.result, self.metadata, self.latestResponse]);\n            }\n          });\n        }\n\n        return;\n      }\n\n      if (this.latestResponse.done) {\n        this._unpackResponse(this.latestResponse, callback);\n\n        return promisifyResponse();\n      }\n\n      this.currentCallPromise_ = operationsClient.getOperation({\n        name: this.latestResponse.name\n      }, this._callOptions);\n      var noCallbackPromise = this.currentCallPromise_.then(function (responses) {\n        self.latestResponse = responses[0];\n\n        self._unpackResponse(responses[0], callback);\n\n        return promisifyResponse();\n      });\n\n      if (!callback) {\n        return noCallbackPromise;\n      }\n    }\n  }, {\n    key: \"_unpackResponse\",\n    value: function _unpackResponse(op, callback) {\n      var responseDecoder = this.longrunningDescriptor.responseDecoder;\n      var metadataDecoder = this.longrunningDescriptor.metadataDecoder;\n      var response;\n      var metadata;\n\n      if (op.done) {\n        if (op.result === 'error') {\n          var error = new GoogleError_1.GoogleError(op.error.message);\n          error.code = op.error.code;\n\n          if (callback) {\n            callback(error);\n          }\n\n          return;\n        }\n\n        if (responseDecoder && op.response) {\n          response = responseDecoder(op.response.value);\n          this.result = response;\n        }\n      }\n\n      if (metadataDecoder && op.metadata) {\n        metadata = metadataDecoder(op.metadata.value);\n        this.metadata = metadata;\n      }\n\n      if (callback) {\n        callback(null, response, metadata, op);\n      }\n    }\n    /**\n     * Poll `getOperation` to check the operation's status. This runs a loop to\n     * ping using the backoff strategy specified at initialization.\n     *\n     * Note: This method is automatically called once a \"complete\" event handler\n     * is registered on the operation.\n     *\n     * @private\n     */\n\n  }, {\n    key: \"startPolling_\",\n    value: function startPolling_() {\n      var self = this;\n      var now = new Date();\n      var delayMult = this.backoffSettings.retryDelayMultiplier;\n      var maxDelay = this.backoffSettings.maxRetryDelayMillis;\n      var delay = this.backoffSettings.initialRetryDelayMillis;\n      var deadline = Infinity;\n\n      if (this.backoffSettings.totalTimeoutMillis) {\n        deadline = now.getTime() + this.backoffSettings.totalTimeoutMillis;\n      }\n\n      var previousMetadataBytes;\n\n      if (this.latestResponse.metadata) {\n        previousMetadataBytes = this.latestResponse.metadata.value;\n      }\n\n      function emit() {\n        self.emit.apply(self, Array.prototype.slice.call(arguments, 0));\n      }\n\n      function retry() {\n        if (!self.hasActiveListeners) {\n          return;\n        }\n\n        if (now.getTime() >= deadline) {\n          setImmediate(emit, 'error', new Error('Total timeout exceeded before ' + 'any response was received'));\n          return;\n        }\n\n        self.getOperation(function (err, result, metadata, rawResponse) {\n          if (err) {\n            setImmediate(emit, 'error', err);\n            return;\n          }\n\n          if (!result) {\n            if (rawResponse.metadata && (!previousMetadataBytes || !rawResponse.metadata.value.equals(previousMetadataBytes))) {\n              setImmediate(emit, 'progress', metadata, rawResponse);\n              previousMetadataBytes = rawResponse.metadata.value;\n            }\n\n            setTimeout(function () {\n              now = new Date();\n              delay = Math.min(delay * delayMult, maxDelay);\n              retry();\n            }, delay);\n            return;\n          }\n\n          setImmediate(emit, 'complete', result, metadata, rawResponse);\n        });\n      }\n\n      retry();\n    }\n    /**\n     * Wraps the `complete` and `error` events in a Promise.\n     *\n     * @return {promise} - Promise that resolves on operation completion and rejects\n     * on operation error.\n     */\n\n  }, {\n    key: \"promise\",\n    value: function promise() {\n      var self = this; // tslint:disable-next-line variable-name\n\n      var PromiseCtor = this._callOptions.promise;\n      return new PromiseCtor(function (resolve, reject) {\n        self.on('error', reject).on('complete', function (result, metadata, rawResponse) {\n          resolve([result, metadata, rawResponse]);\n        });\n      });\n    }\n  }]);\n\n  return Operation;\n}(events_1.EventEmitter);\n\nexports.Operation = Operation;\n/**\n * Method used to create Operation objects.\n *\n * @constructor\n *\n * @param {google.longrunning.Operation} op - The operation to be wrapped.\n * @param {LongrunningDescriptor} longrunningDescriptor - This defines the\n * operations service client and unpacking mechanisms for the operation.\n * @param {BackoffSettings} backoffSettings - The backoff settings used in\n * in polling the operation.\n * @param {CallOptions=} callOptions - CallOptions used in making get operation\n * requests.\n */\n\nfunction operation(op, longrunningDescriptor, backoffSettings, callOptions) {\n  return new Operation(op, longrunningDescriptor, backoffSettings, callOptions);\n}\n\nexports.operation = operation;","map":null,"metadata":{},"sourceType":"script"}