{"ast":null,"code":"\"use strict\";\n/*!\n * Copyright 2017 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nvar _possibleConstructorReturn = require(\"/Users/cvoisin/Repos/actandcaredev/node_modules/@babel/runtime/helpers/possibleConstructorReturn\");\n\nvar _getPrototypeOf = require(\"/Users/cvoisin/Repos/actandcaredev/node_modules/@babel/runtime/helpers/getPrototypeOf\");\n\nvar _get = require(\"/Users/cvoisin/Repos/actandcaredev/node_modules/@babel/runtime/helpers/get\");\n\nvar _inherits = require(\"/Users/cvoisin/Repos/actandcaredev/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _classCallCheck = require(\"/Users/cvoisin/Repos/actandcaredev/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/cvoisin/Repos/actandcaredev/node_modules/@babel/runtime/helpers/createClass\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar assert = require(\"assert\");\n\nvar deepEqual = require('deep-equal');\n\nvar is = require(\"is\");\n\nvar field_value_1 = require(\"./field-value\");\n\nvar path_1 = require(\"./path\");\n\nvar serializer_1 = require(\"./serializer\");\n\nvar timestamp_1 = require(\"./timestamp\");\n/**\n * Returns a builder for DocumentSnapshot and QueryDocumentSnapshot instances.\n * Invoke `.build()' to assemble the final snapshot.\n *\n * @private\n */\n\n\nvar DocumentSnapshotBuilder =\n/*#__PURE__*/\nfunction () {\n  function DocumentSnapshotBuilder() {\n    _classCallCheck(this, DocumentSnapshotBuilder);\n  }\n\n  _createClass(DocumentSnapshotBuilder, [{\n    key: \"build\",\n\n    /**\n     * Builds the DocumentSnapshot.\n     *\n     * @private\n     * @returns Returns either a QueryDocumentSnapshot (if `fieldsProto` was\n     * provided) or a DocumentSnapshot.\n     */\n    value: function build() {\n      assert(this.fieldsProto !== undefined === (this.createTime !== undefined), 'Create time should be set iff document exists.');\n      assert(this.fieldsProto !== undefined === (this.updateTime !== undefined), 'Update time should be set iff document exists.');\n      return this.fieldsProto ? new QueryDocumentSnapshot(this.ref, this.fieldsProto, this.readTime, this.createTime, this.updateTime) : new DocumentSnapshot(this.ref, undefined, this.readTime);\n    }\n  }]);\n\n  return DocumentSnapshotBuilder;\n}();\n\nexports.DocumentSnapshotBuilder = DocumentSnapshotBuilder;\n/**\n * A DocumentSnapshot is an immutable representation for a document in a\n * Firestore database. The data can be extracted with\n * [data()]{@link DocumentSnapshot#data} or\n * [get(fieldPath)]{@link DocumentSnapshot#get} to get a\n * specific field.\n *\n * <p>For a DocumentSnapshot that points to a non-existing document, any data\n * access will return 'undefined'. You can use the\n * [exists]{@link DocumentSnapshot#exists} property to explicitly verify a\n * document's existence.\n *\n * @class\n */\n\nvar DocumentSnapshot =\n/*#__PURE__*/\nfunction () {\n  /**\n   * @private\n   * @hideconstructor\n   *\n   * @param ref The reference to the document.\n   * @param fieldsProto The fields of the Firestore `Document` Protobuf backing\n   * this document (or undefined if the document does not exist).\n   * @param readTime The time when this snapshot was read  (or undefined if\n   * the document exists only locally).\n   * @param createTime The time when the document was created (or undefined if\n   * the document does not exist).\n   * @param updateTime The time when the document was last updated (or undefined\n   * if the document does not exist).\n   */\n  function DocumentSnapshot(ref, fieldsProto, readTime, createTime, updateTime) {\n    _classCallCheck(this, DocumentSnapshot);\n\n    this._ref = ref;\n    this._fieldsProto = fieldsProto;\n    this._serializer = ref.firestore._serializer;\n    this._validator = ref.firestore._validator;\n    this._readTime = readTime;\n    this._createTime = createTime;\n    this._updateTime = updateTime;\n  }\n  /**\n   * Creates a DocumentSnapshot from an object.\n   *\n   * @private\n   * @param ref The reference to the document.\n   * @param obj The object to store in the DocumentSnapshot.\n   * @return The created DocumentSnapshot.\n   */\n\n\n  _createClass(DocumentSnapshot, [{\n    key: \"data\",\n\n    /**\n     * Retrieves all fields in the document as an object. Returns 'undefined' if\n     * the document doesn't exist.\n     *\n     * @returns {DocumentData|undefined} An object containing all fields in the\n     * document or 'undefined' if the document doesn't exist.\n     *\n     * @example\n     * let documentRef = firestore.doc('col/doc');\n     *\n     * documentRef.get().then(documentSnapshot => {\n     *   let data = documentSnapshot.data();\n     *   console.log(`Retrieved data: ${JSON.stringify(data)}`);\n     * });\n     */\n    value: function data() {\n      var fields = this._fieldsProto;\n\n      if (fields === undefined) {\n        return undefined;\n      }\n\n      var obj = {};\n\n      for (var prop in fields) {\n        if (fields.hasOwnProperty(prop)) {\n          obj[prop] = this._serializer.decodeValue(fields[prop]);\n        }\n      }\n\n      return obj;\n    }\n    /**\n     * Retrieves the field specified by `field`.\n     *\n     * @param {string|FieldPath} field The field path\n     * (e.g. 'foo' or 'foo.bar') to a specific field.\n     * @returns {*} The data at the specified field location or undefined if no\n     * such field exists.\n     *\n     * @example\n     * let documentRef = firestore.doc('col/doc');\n     *\n     * documentRef.set({ a: { b: 'c' }}).then(() => {\n     *   return documentRef.get();\n     * }).then(documentSnapshot => {\n     *   let field = documentSnapshot.get('a.b');\n     *   console.log(`Retrieved field value: ${field}`);\n     * });\n     */\n\n  }, {\n    key: \"get\",\n    value: function get(field) {\n      this._validator.isFieldPath('field', field);\n\n      var protoField = this.protoField(field);\n\n      if (protoField === undefined) {\n        return undefined;\n      }\n\n      return this._serializer.decodeValue(protoField);\n    }\n    /**\n     * Retrieves the field specified by 'fieldPath' in its Protobuf JS\n     * representation.\n     *\n     * @private\n     * @param field The path (e.g. 'foo' or 'foo.bar') to a specific field.\n     * @returns The Protobuf-encoded data at the specified field location or\n     * undefined if no such field exists.\n     */\n\n  }, {\n    key: \"protoField\",\n    value: function protoField(field) {\n      var fields = this._fieldsProto;\n\n      if (fields === undefined) {\n        return undefined;\n      }\n\n      var components = path_1.FieldPath.fromArgument(field).toArray();\n\n      while (components.length > 1) {\n        fields = fields[components.shift()];\n\n        if (!fields || !fields.mapValue) {\n          return undefined;\n        }\n\n        fields = fields.mapValue.fields;\n      }\n\n      return fields[components[0]];\n    }\n    /**\n     * Checks whether this DocumentSnapshot contains any fields.\n     *\n     * @private\n     * @return {boolean}\n     */\n\n  }, {\n    key: \"toProto\",\n\n    /**\n     * Convert a document snapshot to the Firestore 'Document' Protobuf.\n     *\n     * @private\n     * @returns The document in the format the API expects.\n     */\n    value: function toProto() {\n      return {\n        update: {\n          name: this._ref.formattedName,\n          fields: this._fieldsProto\n        }\n      };\n    }\n    /**\n     * Returns true if the document's data and path in this `DocumentSnapshot` is\n     * equal to the provided value.\n     *\n     * @param {*} other The value to compare against.\n     * @return {boolean} true if this `DocumentSnapshot` is equal to the provided\n     * value.\n     */\n\n  }, {\n    key: \"isEqual\",\n    value: function isEqual(other) {\n      // Since the read time is different on every document read, we explicitly\n      // ignore all document metadata in this comparison.\n      return this === other || other instanceof DocumentSnapshot && this._ref.isEqual(other._ref) && deepEqual(this._fieldsProto, other._fieldsProto, {\n        strict: true\n      });\n    }\n  }, {\n    key: \"exists\",\n\n    /**\n     * True if the document exists.\n     *\n     * @type {boolean}\n     * @name DocumentSnapshot#exists\n     * @readonly\n     *\n     * @example\n     * let documentRef = firestore.doc('col/doc');\n     *\n     * documentRef.get().then((documentSnapshot) => {\n     *   if (documentSnapshot.exists) {\n     *     console.log(`Data: ${JSON.stringify(documentSnapshot.data())}`);\n     *   }\n     * });\n     */\n    get: function get() {\n      return this._fieldsProto !== undefined;\n    }\n    /**\n     * A [DocumentReference]{@link DocumentReference} for the document\n     * stored in this snapshot.\n     *\n     * @type {DocumentReference}\n     * @name DocumentSnapshot#ref\n     * @readonly\n     *\n     * @example\n     * let documentRef = firestore.doc('col/doc');\n     *\n     * documentRef.get().then((documentSnapshot) => {\n     *   if (documentSnapshot.exists) {\n     *     console.log(`Found document at '${documentSnapshot.ref.path}'`);\n     *   }\n     * });\n     */\n\n  }, {\n    key: \"ref\",\n    get: function get() {\n      return this._ref;\n    }\n    /**\n     * The ID of the document for which this DocumentSnapshot contains data.\n     *\n     * @type {string}\n     * @name DocumentSnapshot#id\n     * @readonly\n     *\n     * @example\n     * let documentRef = firestore.doc('col/doc');\n     *\n     * documentRef.get().then((documentSnapshot) => {\n     *   if (documentSnapshot.exists) {\n     *     console.log(`Document found with name '${documentSnapshot.id}'`);\n     *   }\n     * });\n     */\n\n  }, {\n    key: \"id\",\n    get: function get() {\n      return this._ref.id;\n    }\n    /**\n     * The time the document was created. Undefined for documents that don't\n     * exist.\n     *\n     * @type {Timestamp|undefined}\n     * @name DocumentSnapshot#createTime\n     * @readonly\n     *\n     * @example\n     * let documentRef = firestore.doc('col/doc');\n     *\n     * documentRef.get().then(documentSnapshot => {\n     *   if (documentSnapshot.exists) {\n     *     let createTime = documentSnapshot.createTime;\n     *     console.log(`Document created at '${createTime.toDate()}'`);\n     *   }\n     * });\n     */\n\n  }, {\n    key: \"createTime\",\n    get: function get() {\n      return this._createTime;\n    }\n    /**\n     * The time the document was last updated (at the time the snapshot was\n     * generated). Undefined for documents that don't exist.\n     *\n     * @type {Timestamp|undefined}\n     * @name DocumentSnapshot#updateTime\n     * @readonly\n     *\n     * @example\n     * let documentRef = firestore.doc('col/doc');\n     *\n     * documentRef.get().then(documentSnapshot => {\n     *   if (documentSnapshot.exists) {\n     *     let updateTime = documentSnapshot.updateTime;\n     *     console.log(`Document updated at '${updateTime.toDate()}'`);\n     *   }\n     * });\n     */\n\n  }, {\n    key: \"updateTime\",\n    get: function get() {\n      return this._updateTime;\n    }\n    /**\n     * The time this snapshot was read.\n     *\n     * @type {Timestamp}\n     * @name DocumentSnapshot#readTime\n     * @readonly\n     *\n     * @example\n     * let documentRef = firestore.doc('col/doc');\n     *\n     * documentRef.get().then(documentSnapshot => {\n     *   let readTime = documentSnapshot.readTime;\n     *   console.log(`Document read at '${readTime.toDate()}'`);\n     * });\n     */\n\n  }, {\n    key: \"readTime\",\n    get: function get() {\n      if (this._readTime === undefined) {\n        throw new Error(\"Called 'readTime' on a local document\");\n      }\n\n      return this._readTime;\n    }\n  }, {\n    key: \"isEmpty\",\n    get: function get() {\n      return is.undefined(this._fieldsProto) || is.empty(this._fieldsProto);\n    }\n  }], [{\n    key: \"fromObject\",\n    value: function fromObject(ref, obj) {\n      var serializer = ref.firestore._serializer;\n      return new DocumentSnapshot(ref, serializer.encodeFields(obj));\n    }\n    /**\n     * Creates a DocumentSnapshot from an UpdateMap.\n     *\n     * This methods expands the top-level field paths in a JavaScript map and\n     * turns { foo.bar : foobar } into { foo { bar : foobar }}\n     *\n     * @private\n     * @param ref The reference to the document.\n     * @param data The field/value map to expand.\n     * @return The created DocumentSnapshot.\n     */\n\n  }, {\n    key: \"fromUpdateMap\",\n    value: function fromUpdateMap(ref, data) {\n      var serializer = ref.firestore._serializer;\n      /**\n       * Merges 'value' at the field path specified by the path array into\n       * 'target'.\n       */\n\n      function merge(target, value, path, pos) {\n        var key = path[pos];\n        var isLast = pos === path.length - 1;\n\n        if (target[key] === undefined) {\n          if (isLast) {\n            if (value instanceof field_value_1.FieldTransform) {\n              // If there is already data at this path, we need to retain it.\n              // Otherwise, we don't include it in the DocumentSnapshot.\n              return !is.empty(target) ? target : null;\n            } // The merge is done.\n\n\n            var leafNode = serializer.encodeValue(value);\n\n            if (leafNode) {\n              target[key] = leafNode;\n            }\n\n            return target;\n          } else {\n            // We need to expand the target object.\n            var childNode = {\n              mapValue: {\n                fields: {}\n              }\n            };\n            var nestedValue = merge(childNode.mapValue.fields, value, path, pos + 1);\n\n            if (nestedValue) {\n              childNode.mapValue.fields = nestedValue;\n              target[key] = childNode;\n              return target;\n            } else {\n              return !is.empty(target) ? target : null;\n            }\n          }\n        } else {\n          assert(!isLast, 'Can\\'t merge current value into a nested object');\n          target[key].mapValue.fields = merge(target[key].mapValue.fields, value, path, pos + 1);\n          return target;\n        }\n      }\n\n      var res = {};\n      data.forEach(function (value, key) {\n        var components = key.toArray();\n        merge(res, value, components, 0);\n      });\n      return new DocumentSnapshot(ref, res);\n    }\n  }]);\n\n  return DocumentSnapshot;\n}();\n\nexports.DocumentSnapshot = DocumentSnapshot;\n/**\n * A QueryDocumentSnapshot contains data read from a document in your\n * Firestore database as part of a query. The document is guaranteed to exist\n * and its data can be extracted with [data()]{@link QueryDocumentSnapshot#data}\n * or [get()]{@link DocumentSnapshot#get} to get a specific field.\n *\n * A QueryDocumentSnapshot offers the same API surface as a\n * {@link DocumentSnapshot}. Since query results contain only existing\n * documents, the [exists]{@link DocumentSnapshot#exists} property will\n * always be true and [data()]{@link QueryDocumentSnapshot#data} will never\n * return 'undefined'.\n *\n * @class\n * @extends DocumentSnapshot\n */\n\nvar QueryDocumentSnapshot =\n/*#__PURE__*/\nfunction (_DocumentSnapshot) {\n  _inherits(QueryDocumentSnapshot, _DocumentSnapshot);\n\n  /**\n   * @private\n   * @hideconstructor\n   *\n   * @param ref The reference to the document.\n   * @param fieldsProto The fields of the Firestore `Document` Protobuf backing\n   * this document.\n   * @param readTime The time when this snapshot was read.\n   * @param createTime The time when the document was created.\n   * @param updateTime The time when the document was last updated.\n   */\n  function QueryDocumentSnapshot(ref, fieldsProto, readTime, createTime, updateTime) {\n    _classCallCheck(this, QueryDocumentSnapshot);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(QueryDocumentSnapshot).call(this, ref, fieldsProto, readTime, createTime, updateTime));\n  }\n  /**\n   * The time the document was created.\n   *\n   * @type {Timestamp}\n   * @name QueryDocumentSnapshot#createTime\n   * @readonly\n   * @override\n   *\n   * @example\n   * let query = firestore.collection('col');\n   *\n   * query.get().forEach(snapshot => {\n   *   console.log(`Document created at '${snapshot.createTime.toDate()}'`);\n   * });\n   */\n\n\n  _createClass(QueryDocumentSnapshot, [{\n    key: \"data\",\n\n    /**\n     * Retrieves all fields in the document as an object.\n     *\n     * @override\n     *\n     * @returns {DocumentData} An object containing all fields in the document.\n     *\n     * @example\n     * let query = firestore.collection('col');\n     *\n     * query.get().forEach(documentSnapshot => {\n     *   let data = documentSnapshot.data();\n     *   console.log(`Retrieved data: ${JSON.stringify(data)}`);\n     * });\n     */\n    value: function data() {\n      var data = _get(_getPrototypeOf(QueryDocumentSnapshot.prototype), \"data\", this).call(this);\n\n      if (!data) {\n        throw new Error('The data in a QueryDocumentSnapshot should always exist.');\n      }\n\n      return data;\n    }\n  }, {\n    key: \"createTime\",\n    get: function get() {\n      return _get(_getPrototypeOf(QueryDocumentSnapshot.prototype), \"createTime\", this);\n    }\n    /**\n     * The time the document was last updated (at the time the snapshot was\n     * generated).\n     *\n     * @type {Timestamp}\n     * @name QueryDocumentSnapshot#updateTime\n     * @readonly\n     * @override\n     *\n     * @example\n     * let query = firestore.collection('col');\n     *\n     * query.get().forEach(snapshot => {\n     *   console.log(`Document updated at '${snapshot.updateTime.toDate()}'`);\n     * });\n     */\n\n  }, {\n    key: \"updateTime\",\n    get: function get() {\n      return _get(_getPrototypeOf(QueryDocumentSnapshot.prototype), \"updateTime\", this);\n    }\n  }]);\n\n  return QueryDocumentSnapshot;\n}(DocumentSnapshot);\n\nexports.QueryDocumentSnapshot = QueryDocumentSnapshot;\n/**\n * A Firestore Document Mask contains the field paths affected by an update.\n *\n * @class\n * @private\n */\n\nvar DocumentMask =\n/*#__PURE__*/\nfunction () {\n  /**\n   * @private\n   * @hideconstructor\n   *\n   * @param fieldPaths The field paths in this mask.\n   */\n  function DocumentMask(fieldPaths) {\n    _classCallCheck(this, DocumentMask);\n\n    this._sortedPaths = fieldPaths;\n\n    this._sortedPaths.sort(function (a, b) {\n      return a.compareTo(b);\n    });\n  }\n  /**\n   * Creates a document mask with the field paths of a document.\n   *\n   * @private\n   * @param data A map with fields to modify. Only the keys are used to extract\n   * the document mask.\n   */\n\n\n  _createClass(DocumentMask, [{\n    key: \"removeFields\",\n\n    /**\n     * Removes the field path specified in 'fieldPaths' from this document mask.\n     *\n     * @private\n     * @param fieldPaths An array of FieldPaths.\n     */\n    value: function removeFields(fieldPaths) {\n      DocumentMask.removeFromSortedArray(this._sortedPaths, fieldPaths);\n    }\n    /**\n     * Returns whether this document mask contains 'fieldPath'.\n     *\n     * @private\n     * @param fieldPath The field path to test.\n     * @return Whether this document mask contains 'fieldPath'.\n     */\n\n  }, {\n    key: \"contains\",\n    value: function contains(fieldPath) {\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = this._sortedPaths[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var sortedPath = _step.value;\n          var cmp = sortedPath.compareTo(fieldPath);\n\n          if (cmp === 0) {\n            return true;\n          } else if (cmp > 0) {\n            return false;\n          }\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return != null) {\n            _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n\n      return false;\n    }\n    /**\n     * Removes all properties from 'data' that are not contained in this document\n     * mask.\n     *\n     * @private\n     * @param data An object to filter.\n     * @return A shallow copy of the object filtered by this document mask.\n     */\n\n  }, {\n    key: \"applyTo\",\n    value: function applyTo(data) {\n      var _this = this;\n\n      /*!\n       * Applies this DocumentMask to 'data' and computes the list of field paths\n       * that were specified in the mask but are not present in 'data'.\n       */\n      var applyDocumentMask = function applyDocumentMask(data) {\n        var remainingPaths = _this._sortedPaths.slice(0);\n\n        var processObject = function processObject(currentData, currentPath) {\n          var result = null;\n          Object.keys(currentData).forEach(function (key) {\n            var childPath = currentPath ? currentPath.append(key) : new path_1.FieldPath(key);\n\n            if (_this.contains(childPath)) {\n              DocumentMask.removeFromSortedArray(remainingPaths, [childPath]);\n              result = result || {};\n              result[key] = currentData[key];\n            } else if (is.object(currentData[key])) {\n              var childObject = processObject(currentData[key], childPath);\n\n              if (childObject) {\n                result = result || {};\n                result[key] = childObject;\n              }\n            }\n          });\n          return result;\n        }; // processObject() returns 'null' if the DocumentMask is empty.\n\n\n        var filteredData = processObject(data) || {};\n        return {\n          filteredData: filteredData,\n          remainingPaths: remainingPaths\n        };\n      };\n\n      var result = applyDocumentMask(data);\n\n      if (result.remainingPaths.length !== 0) {\n        throw new Error(\"Input data is missing for field \\\"\".concat(result.remainingPaths[0].toString(), \"\\\".\"));\n      }\n\n      return result.filteredData;\n    }\n    /**\n     * Converts a document mask to the Firestore 'DocumentMask' Proto.\n     *\n     * @private\n     * @returns A Firestore 'DocumentMask' Proto.\n     */\n\n  }, {\n    key: \"toProto\",\n    value: function toProto() {\n      if (this.isEmpty) {\n        return {};\n      }\n\n      var encodedPaths = [];\n      var _iteratorNormalCompletion2 = true;\n      var _didIteratorError2 = false;\n      var _iteratorError2 = undefined;\n\n      try {\n        for (var _iterator2 = this._sortedPaths[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n          var fieldPath = _step2.value;\n          encodedPaths.push(fieldPath.formattedName);\n        }\n      } catch (err) {\n        _didIteratorError2 = true;\n        _iteratorError2 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n            _iterator2.return();\n          }\n        } finally {\n          if (_didIteratorError2) {\n            throw _iteratorError2;\n          }\n        }\n      }\n\n      return {\n        fieldPaths: encodedPaths\n      };\n    }\n  }, {\n    key: \"isEmpty\",\n\n    /**\n     * Returns true if this document mask contains no fields.\n     *\n     * @private\n     * @return {boolean} Whether this document mask is empty.\n     */\n    get: function get() {\n      return this._sortedPaths.length === 0;\n    }\n    /**\n     * Removes the specified values from a sorted field path array.\n     *\n     * @private\n     * @param input A sorted array of FieldPaths.\n     * @param values An array of FieldPaths to remove.\n     */\n\n  }], [{\n    key: \"fromUpdateMap\",\n    value: function fromUpdateMap(data) {\n      var fieldPaths = [];\n      data.forEach(function (value, key) {\n        if (!(value instanceof field_value_1.FieldTransform) || value.includeInDocumentMask) {\n          fieldPaths.push(path_1.FieldPath.fromArgument(key));\n        }\n      });\n      return new DocumentMask(fieldPaths);\n    }\n    /**\n     * Creates a document mask from an array of field paths.\n     *\n     * @private\n     * @param fieldMask A list of field paths.\n     */\n\n  }, {\n    key: \"fromFieldMask\",\n    value: function fromFieldMask(fieldMask) {\n      var fieldPaths = [];\n      var _iteratorNormalCompletion3 = true;\n      var _didIteratorError3 = false;\n      var _iteratorError3 = undefined;\n\n      try {\n        for (var _iterator3 = fieldMask[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n          var fieldPath = _step3.value;\n          fieldPaths.push(path_1.FieldPath.fromArgument(fieldPath));\n        }\n      } catch (err) {\n        _didIteratorError3 = true;\n        _iteratorError3 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion3 && _iterator3.return != null) {\n            _iterator3.return();\n          }\n        } finally {\n          if (_didIteratorError3) {\n            throw _iteratorError3;\n          }\n        }\n      }\n\n      return new DocumentMask(fieldPaths);\n    }\n    /**\n     * Creates a document mask with the field names of a document.\n     *\n     * @private\n     * @param data An object with fields to modify. Only the keys are used to\n     * extract the document mask.\n     */\n\n  }, {\n    key: \"fromObject\",\n    value: function fromObject(data) {\n      var fieldPaths = [];\n\n      function extractFieldPaths(currentData, currentPath) {\n        var isEmpty = true;\n\n        for (var key in currentData) {\n          if (currentData.hasOwnProperty(key)) {\n            isEmpty = false; // We don't split on dots since fromObject is called with\n            // DocumentData.\n\n            var childSegment = new path_1.FieldPath(key);\n            var childPath = currentPath ? currentPath.append(childSegment) : childSegment;\n            var value = currentData[key];\n\n            if (value instanceof field_value_1.FieldTransform) {\n              if (value.includeInDocumentMask) {\n                fieldPaths.push(childPath);\n              }\n            } else if (serializer_1.isPlainObject(value)) {\n              extractFieldPaths(value, childPath);\n            } else {\n              fieldPaths.push(childPath);\n            }\n          }\n        } // Add a field path for an explicitly updated empty map.\n\n\n        if (currentPath && isEmpty) {\n          fieldPaths.push(currentPath);\n        }\n      }\n\n      extractFieldPaths(data);\n      return new DocumentMask(fieldPaths);\n    }\n  }, {\n    key: \"removeFromSortedArray\",\n    value: function removeFromSortedArray(input, values) {\n      for (var i = 0; i < input.length;) {\n        var removed = false;\n        var _iteratorNormalCompletion4 = true;\n        var _didIteratorError4 = false;\n        var _iteratorError4 = undefined;\n\n        try {\n          for (var _iterator4 = values[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {\n            var fieldPath = _step4.value;\n\n            if (input[i].isEqual(fieldPath)) {\n              input.splice(i, 1);\n              removed = true;\n              break;\n            }\n          }\n        } catch (err) {\n          _didIteratorError4 = true;\n          _iteratorError4 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion4 && _iterator4.return != null) {\n              _iterator4.return();\n            }\n          } finally {\n            if (_didIteratorError4) {\n              throw _iteratorError4;\n            }\n          }\n        }\n\n        if (!removed) {\n          ++i;\n        }\n      }\n    }\n  }]);\n\n  return DocumentMask;\n}();\n\nexports.DocumentMask = DocumentMask;\n/**\n * A Firestore Document Transform.\n *\n * A DocumentTransform contains pending server-side transforms and their\n * corresponding field paths.\n *\n * @private\n * @class\n */\n\nvar DocumentTransform =\n/*#__PURE__*/\nfunction () {\n  /**\n   * @private\n   * @hideconstructor\n   *\n   * @param ref The DocumentReference for this transform.\n   * @param transforms A Map of FieldPaths to FieldTransforms.\n   */\n  function DocumentTransform(ref, transforms) {\n    _classCallCheck(this, DocumentTransform);\n\n    this._ref = ref;\n    this._validator = ref.firestore._validator;\n    this._transforms = transforms;\n  }\n  /**\n   * Generates a DocumentTransform from a JavaScript object.\n   *\n   * @private\n   * @param ref The `DocumentReference` to use for the DocumentTransform.\n   * @param obj The object to extract the transformations from.\n   * @returns The Document Transform.\n   */\n\n\n  _createClass(DocumentTransform, [{\n    key: \"validate\",\n\n    /** Validates the user provided field values in this document transform. */\n    value: function validate() {\n      var _this2 = this;\n\n      this._transforms.forEach(function (transform) {\n        return transform.validate(_this2._validator);\n      });\n    }\n    /**\n     * Converts a document transform to the Firestore 'DocumentTransform' Proto.\n     *\n     * @private\n     * @param serializer The Firestore serializer\n     * @returns A Firestore 'DocumentTransform' Proto or 'null' if this transform\n     * is empty.\n     */\n\n  }, {\n    key: \"toProto\",\n    value: function toProto(serializer) {\n      if (this.isEmpty) {\n        return null;\n      }\n\n      var protoTransforms = [];\n\n      this._transforms.forEach(function (transform, path) {\n        protoTransforms.push(transform.toProto(serializer, path));\n      });\n\n      return {\n        transform: {\n          document: this._ref.formattedName,\n          fieldTransforms: protoTransforms\n        }\n      };\n    }\n  }, {\n    key: \"isEmpty\",\n\n    /**\n     * Whether this DocumentTransform contains any actionable transformations.\n     *\n     * @private\n     */\n    get: function get() {\n      return this._transforms.size === 0;\n    }\n    /**\n     * Returns the array of fields in this DocumentTransform.\n     *\n     * @private\n     */\n\n  }, {\n    key: \"fields\",\n    get: function get() {\n      return Array.from(this._transforms.keys());\n    }\n  }], [{\n    key: \"fromObject\",\n    value: function fromObject(ref, obj) {\n      var updateMap = new Map();\n\n      for (var prop in obj) {\n        if (obj.hasOwnProperty(prop)) {\n          updateMap.set(new path_1.FieldPath(prop), obj[prop]);\n        }\n      }\n\n      return DocumentTransform.fromUpdateMap(ref, updateMap);\n    }\n    /**\n     * Generates a DocumentTransform from an Update Map.\n     *\n     * @private\n     * @param ref The `DocumentReference` to use for the DocumentTransform.\n     * @param data The update data to extract the transformations from.\n     * @returns The Document Transform.\n     */\n\n  }, {\n    key: \"fromUpdateMap\",\n    value: function fromUpdateMap(ref, data) {\n      var transforms = new Map();\n\n      function encode_(val, path, allowTransforms) {\n        if (val instanceof field_value_1.FieldTransform && val.includeInDocumentTransform) {\n          if (allowTransforms) {\n            transforms.set(path, val);\n          } else {\n            throw new Error(\"\".concat(val.methodName, \"() is not supported inside of array values.\"));\n          }\n        } else if (is.array(val)) {\n          for (var i = 0; i < val.length; ++i) {\n            // We need to verify that no array value contains a document transform\n            encode_(val[i], path.append(String(i)), false);\n          }\n        } else if (serializer_1.isPlainObject(val)) {\n          for (var prop in val) {\n            if (val.hasOwnProperty(prop)) {\n              encode_(val[prop], path.append(new path_1.FieldPath(prop)), allowTransforms);\n            }\n          }\n        }\n      }\n\n      data.forEach(function (value, key) {\n        encode_(value, path_1.FieldPath.fromArgument(key), true);\n      });\n      return new DocumentTransform(ref, transforms);\n    }\n  }]);\n\n  return DocumentTransform;\n}();\n\nexports.DocumentTransform = DocumentTransform;\n/*!\n * A Firestore Precondition encapsulates options for database writes.\n *\n * @private\n * @class\n */\n\nvar Precondition =\n/*#__PURE__*/\nfunction () {\n  /**\n   * @private\n   * @hideconstructor\n   *\n   * @param options.exists - Whether the referenced document should exist in\n   * Firestore,\n   * @param options.lastUpdateTime - The last update time of the referenced\n   * document in Firestore.\n   * @param options\n   */\n  function Precondition(options) {\n    _classCallCheck(this, Precondition);\n\n    if (options !== undefined) {\n      this._exists = options.exists;\n      this._lastUpdateTime = options.lastUpdateTime;\n    }\n  }\n  /**\n   * Generates the Protobuf `Preconditon` object for this precondition.\n   *\n   * @private\n   * @returns The `Preconditon` Protobuf object or 'null' if there are no\n   * preconditions.\n   */\n\n\n  _createClass(Precondition, [{\n    key: \"toProto\",\n    value: function toProto() {\n      if (this.isEmpty) {\n        return null;\n      }\n\n      var proto = {};\n\n      if (this._lastUpdateTime !== undefined) {\n        proto.updateTime = this._lastUpdateTime.toProto().timestampValue;\n      } else {\n        proto.exists = this._exists;\n      }\n\n      return proto;\n    }\n    /**\n     * Whether this DocumentTransform contains any enforcement.\n     *\n     * @private\n     */\n\n  }, {\n    key: \"isEmpty\",\n    get: function get() {\n      return this._exists === undefined && !this._lastUpdateTime;\n    }\n  }]);\n\n  return Precondition;\n}();\n\nexports.Precondition = Precondition;\n/**\n * Validates the use of 'options' as a Precondition and enforces that 'exists'\n * and 'lastUpdateTime' use valid types.\n *\n * @private\n * @param options.exists Whether the referenced document should exist.\n * @param options.lastUpdateTime The last update time of the referenced\n * document in Firestore.\n * @param allowExist Whether to allow the 'exists' preconditions.\n * @returns 'true' if the input is a valid Precondition.\n */\n\nfunction validatePrecondition(precondition, allowExist) {\n  if (!is.object(precondition)) {\n    throw new Error('Input is not an object.');\n  }\n\n  var conditions = 0;\n\n  if (precondition.exists !== undefined) {\n    ++conditions;\n\n    if (!allowExist) {\n      throw new Error('\"exists\" is not an allowed condition.');\n    }\n\n    if (!is.boolean(precondition.exists)) {\n      throw new Error('\"exists\" is not a boolean.');\n    }\n  }\n\n  if (precondition.lastUpdateTime !== undefined) {\n    ++conditions;\n\n    if (!(precondition.lastUpdateTime instanceof timestamp_1.Timestamp)) {\n      throw new Error('\"lastUpdateTime\" is not a Firestore Timestamp.');\n    }\n  }\n\n  if (conditions > 1) {\n    throw new Error('Input contains more than one condition.');\n  }\n\n  return true;\n}\n\nexports.validatePrecondition = validatePrecondition;\n/**\n * Validates the use of 'options' as SetOptions and enforces that 'merge' is a\n * boolean.\n *\n * @private\n * @param options.merge - Whether set() should merge the provided data into an\n * existing document.\n * @param options.mergeFields - Whether set() should only merge the specified\n * set of fields.\n * @returns 'true' if the input is a valid SetOptions object.\n */\n\nfunction validateSetOptions(options) {\n  if (!is.object(options)) {\n    throw new Error('Input is not an object.');\n  }\n\n  if (options.merge !== undefined && !is.boolean(options.merge)) {\n    throw new Error('\"merge\" is not a boolean.');\n  }\n\n  if (options.mergeFields !== undefined) {\n    if (!is.array(options.mergeFields)) {\n      throw new Error('\"mergeFields\" is not an array.');\n    }\n\n    for (var i = 0; i < options.mergeFields.length; ++i) {\n      try {\n        path_1.FieldPath.validateFieldPath(options.mergeFields[i]);\n      } catch (err) {\n        throw new Error(\"Element at index \".concat(i, \" is not a valid FieldPath. \").concat(err.message));\n      }\n    }\n  }\n\n  if (options.merge !== undefined && options.mergeFields !== undefined) {\n    throw new Error('You cannot specify both \"merge\" and \"mergeFields\".');\n  }\n\n  return true;\n}\n\nexports.validateSetOptions = validateSetOptions;","map":null,"metadata":{},"sourceType":"script"}