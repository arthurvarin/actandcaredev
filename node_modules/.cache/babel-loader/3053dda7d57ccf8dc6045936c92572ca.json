{"ast":null,"code":"\"use strict\";\n\nmodule.exports = tokenize;\nvar delimRe = /[\\s{}=;:[\\],'\"()<>]/g,\n    stringDoubleRe = /(?:\"([^\"\\\\]*(?:\\\\.[^\"\\\\]*)*)\")/g,\n    stringSingleRe = /(?:'([^'\\\\]*(?:\\\\.[^'\\\\]*)*)')/g;\nvar setCommentRe = /^ *[*/]+ */,\n    setCommentAltRe = /^\\s*\\*?\\/*/,\n    setCommentSplitRe = /\\n/g,\n    whitespaceRe = /\\s/,\n    unescapeRe = /\\\\(.?)/g;\nvar unescapeMap = {\n  \"0\": \"\\0\",\n  \"r\": \"\\r\",\n  \"n\": \"\\n\",\n  \"t\": \"\\t\"\n};\n/**\r\n * Unescapes a string.\r\n * @param {string} str String to unescape\r\n * @returns {string} Unescaped string\r\n * @property {Object.<string,string>} map Special characters map\r\n * @memberof tokenize\r\n */\n\nfunction unescape(str) {\n  return str.replace(unescapeRe, function ($0, $1) {\n    switch ($1) {\n      case \"\\\\\":\n      case \"\":\n        return $1;\n\n      default:\n        return unescapeMap[$1] || \"\";\n    }\n  });\n}\n\ntokenize.unescape = unescape;\n/**\r\n * Gets the next token and advances.\r\n * @typedef TokenizerHandleNext\r\n * @type {function}\r\n * @returns {string|null} Next token or `null` on eof\r\n */\n\n/**\r\n * Peeks for the next token.\r\n * @typedef TokenizerHandlePeek\r\n * @type {function}\r\n * @returns {string|null} Next token or `null` on eof\r\n */\n\n/**\r\n * Pushes a token back to the stack.\r\n * @typedef TokenizerHandlePush\r\n * @type {function}\r\n * @param {string} token Token\r\n * @returns {undefined}\r\n */\n\n/**\r\n * Skips the next token.\r\n * @typedef TokenizerHandleSkip\r\n * @type {function}\r\n * @param {string} expected Expected token\r\n * @param {boolean} [optional=false] If optional\r\n * @returns {boolean} Whether the token matched\r\n * @throws {Error} If the token didn't match and is not optional\r\n */\n\n/**\r\n * Gets the comment on the previous line or, alternatively, the line comment on the specified line.\r\n * @typedef TokenizerHandleCmnt\r\n * @type {function}\r\n * @param {number} [line] Line number\r\n * @returns {string|null} Comment text or `null` if none\r\n */\n\n/**\r\n * Handle object returned from {@link tokenize}.\r\n * @interface ITokenizerHandle\r\n * @property {TokenizerHandleNext} next Gets the next token and advances (`null` on eof)\r\n * @property {TokenizerHandlePeek} peek Peeks for the next token (`null` on eof)\r\n * @property {TokenizerHandlePush} push Pushes a token back to the stack\r\n * @property {TokenizerHandleSkip} skip Skips a token, returns its presence and advances or, if non-optional and not present, throws\r\n * @property {TokenizerHandleCmnt} cmnt Gets the comment on the previous line or the line comment on the specified line, if any\r\n * @property {number} line Current line number\r\n */\n\n/**\r\n * Tokenizes the given .proto source and returns an object with useful utility functions.\r\n * @param {string} source Source contents\r\n * @param {boolean} alternateCommentMode Whether we should activate alternate comment parsing mode.\r\n * @returns {ITokenizerHandle} Tokenizer handle\r\n */\n\nfunction tokenize(source, alternateCommentMode) {\n  /* eslint-disable callback-return */\n  source = source.toString();\n  var offset = 0,\n      length = source.length,\n      line = 1,\n      commentType = null,\n      commentText = null,\n      commentLine = 0,\n      commentLineEmpty = false;\n  var stack = [];\n  var stringDelim = null;\n  /* istanbul ignore next */\n\n  /**\r\n   * Creates an error for illegal syntax.\r\n   * @param {string} subject Subject\r\n   * @returns {Error} Error created\r\n   * @inner\r\n   */\n\n  function illegal(subject) {\n    return Error(\"illegal \" + subject + \" (line \" + line + \")\");\n  }\n  /**\r\n   * Reads a string till its end.\r\n   * @returns {string} String read\r\n   * @inner\r\n   */\n\n\n  function readString() {\n    var re = stringDelim === \"'\" ? stringSingleRe : stringDoubleRe;\n    re.lastIndex = offset - 1;\n    var match = re.exec(source);\n    if (!match) throw illegal(\"string\");\n    offset = re.lastIndex;\n    push(stringDelim);\n    stringDelim = null;\n    return unescape(match[1]);\n  }\n  /**\r\n   * Gets the character at `pos` within the source.\r\n   * @param {number} pos Position\r\n   * @returns {string} Character\r\n   * @inner\r\n   */\n\n\n  function charAt(pos) {\n    return source.charAt(pos);\n  }\n  /**\r\n   * Sets the current comment text.\r\n   * @param {number} start Start offset\r\n   * @param {number} end End offset\r\n   * @returns {undefined}\r\n   * @inner\r\n   */\n\n\n  function setComment(start, end) {\n    commentType = source.charAt(start++);\n    commentLine = line;\n    commentLineEmpty = false;\n    var lookback;\n\n    if (alternateCommentMode) {\n      lookback = 2; // alternate comment parsing: \"//\" or \"/*\"\n    } else {\n      lookback = 3; // \"///\" or \"/**\"\n    }\n\n    var commentOffset = start - lookback,\n        c;\n\n    do {\n      if (--commentOffset < 0 || (c = source.charAt(commentOffset)) === \"\\n\") {\n        commentLineEmpty = true;\n        break;\n      }\n    } while (c === \" \" || c === \"\\t\");\n\n    var lines = source.substring(start, end).split(setCommentSplitRe);\n\n    for (var i = 0; i < lines.length; ++i) {\n      lines[i] = lines[i].replace(alternateCommentMode ? setCommentAltRe : setCommentRe, \"\").trim();\n    }\n\n    commentText = lines.join(\"\\n\").trim();\n  }\n\n  function isDoubleSlashCommentLine(startOffset) {\n    var endOffset = findEndOfLine(startOffset); // see if remaining line matches comment pattern\n\n    var lineText = source.substring(startOffset, endOffset); // look for 1 or 2 slashes since startOffset would already point past\n    // the first slash that started the comment.\n\n    var isComment = /^\\s*\\/{1,2}/.test(lineText);\n    return isComment;\n  }\n\n  function findEndOfLine(cursor) {\n    // find end of cursor's line\n    var endOffset = cursor;\n\n    while (endOffset < length && charAt(endOffset) !== \"\\n\") {\n      endOffset++;\n    }\n\n    return endOffset;\n  }\n  /**\r\n   * Obtains the next token.\r\n   * @returns {string|null} Next token or `null` on eof\r\n   * @inner\r\n   */\n\n\n  function next() {\n    if (stack.length > 0) return stack.shift();\n    if (stringDelim) return readString();\n    var repeat, prev, curr, start, isDoc;\n\n    do {\n      if (offset === length) return null;\n      repeat = false;\n\n      while (whitespaceRe.test(curr = charAt(offset))) {\n        if (curr === \"\\n\") ++line;\n        if (++offset === length) return null;\n      }\n\n      if (charAt(offset) === \"/\") {\n        if (++offset === length) {\n          throw illegal(\"comment\");\n        }\n\n        if (charAt(offset) === \"/\") {\n          // Line\n          if (!alternateCommentMode) {\n            // check for triple-slash comment\n            isDoc = charAt(start = offset + 1) === \"/\";\n\n            while (charAt(++offset) !== \"\\n\") {\n              if (offset === length) {\n                return null;\n              }\n            }\n\n            ++offset;\n\n            if (isDoc) {\n              setComment(start, offset - 1);\n            }\n\n            ++line;\n            repeat = true;\n          } else {\n            // check for double-slash comments, consolidating consecutive lines\n            start = offset;\n            isDoc = false;\n\n            if (isDoubleSlashCommentLine(offset)) {\n              isDoc = true;\n\n              do {\n                offset = findEndOfLine(offset);\n\n                if (offset === length) {\n                  break;\n                }\n\n                offset++;\n              } while (isDoubleSlashCommentLine(offset));\n            } else {\n              offset = Math.min(length, findEndOfLine(offset) + 1);\n            }\n\n            if (isDoc) {\n              setComment(start, offset);\n            }\n\n            line++;\n            repeat = true;\n          }\n        } else if ((curr = charAt(offset)) === \"*\") {\n          /* Block */\n          // check for /** (regular comment mode) or /* (alternate comment mode)\n          start = offset + 1;\n          isDoc = alternateCommentMode || charAt(start) === \"*\";\n\n          do {\n            if (curr === \"\\n\") {\n              ++line;\n            }\n\n            if (++offset === length) {\n              throw illegal(\"comment\");\n            }\n\n            prev = curr;\n            curr = charAt(offset);\n          } while (prev !== \"*\" || curr !== \"/\");\n\n          ++offset;\n\n          if (isDoc) {\n            setComment(start, offset - 2);\n          }\n\n          repeat = true;\n        } else {\n          return \"/\";\n        }\n      }\n    } while (repeat); // offset !== length if we got here\n\n\n    var end = offset;\n    delimRe.lastIndex = 0;\n    var delim = delimRe.test(charAt(end++));\n    if (!delim) while (end < length && !delimRe.test(charAt(end))) {\n      ++end;\n    }\n    var token = source.substring(offset, offset = end);\n    if (token === \"\\\"\" || token === \"'\") stringDelim = token;\n    return token;\n  }\n  /**\r\n   * Pushes a token back to the stack.\r\n   * @param {string} token Token\r\n   * @returns {undefined}\r\n   * @inner\r\n   */\n\n\n  function push(token) {\n    stack.push(token);\n  }\n  /**\r\n   * Peeks for the next token.\r\n   * @returns {string|null} Token or `null` on eof\r\n   * @inner\r\n   */\n\n\n  function peek() {\n    if (!stack.length) {\n      var token = next();\n      if (token === null) return null;\n      push(token);\n    }\n\n    return stack[0];\n  }\n  /**\r\n   * Skips a token.\r\n   * @param {string} expected Expected token\r\n   * @param {boolean} [optional=false] Whether the token is optional\r\n   * @returns {boolean} `true` when skipped, `false` if not\r\n   * @throws {Error} When a required token is not present\r\n   * @inner\r\n   */\n\n\n  function skip(expected, optional) {\n    var actual = peek(),\n        equals = actual === expected;\n\n    if (equals) {\n      next();\n      return true;\n    }\n\n    if (!optional) throw illegal(\"token '\" + actual + \"', '\" + expected + \"' expected\");\n    return false;\n  }\n  /**\r\n   * Gets a comment.\r\n   * @param {number} [trailingLine] Line number if looking for a trailing comment\r\n   * @returns {string|null} Comment text\r\n   * @inner\r\n   */\n\n\n  function cmnt(trailingLine) {\n    var ret = null;\n\n    if (trailingLine === undefined) {\n      if (commentLine === line - 1 && (alternateCommentMode || commentType === \"*\" || commentLineEmpty)) {\n        ret = commentText;\n      }\n    } else {\n      /* istanbul ignore else */\n      if (commentLine < trailingLine) {\n        peek();\n      }\n\n      if (commentLine === trailingLine && !commentLineEmpty && (alternateCommentMode || commentType === \"/\")) {\n        ret = commentText;\n      }\n    }\n\n    return ret;\n  }\n\n  return Object.defineProperty({\n    next: next,\n    peek: peek,\n    push: push,\n    skip: skip,\n    cmnt: cmnt\n  }, \"line\", {\n    get: function get() {\n      return line;\n    }\n  });\n  /* eslint-enable callback-return */\n}","map":null,"metadata":{},"sourceType":"script"}