{"ast":null,"code":"// Public API\n// ==========\n// The main governing power behind the http2 API design is that it should look very similar to the\n// existing node.js [HTTPS API][1] (which is, in turn, almost identical to the [HTTP API][2]). The\n// additional features of HTTP/2 are exposed as extensions to this API. Furthermore, node-http2\n// should fall back to using HTTP/1.1 if needed. Compatibility with undocumented or deprecated\n// elements of the node.js HTTP/HTTPS API is a non-goal.\n//\n// Additional and modified API elements\n// ------------------------------------\n//\n// - **Class: http2.Endpoint**: an API for using the raw HTTP/2 framing layer. For documentation\n//   see [protocol/endpoint.js](protocol/endpoint.html).\n//\n// - **Class: http2.Server**\n//   - **Event: 'connection' (socket, [endpoint])**: there's a second argument if the negotiation of\n//     HTTP/2 was successful: the reference to the [Endpoint](protocol/endpoint.html) object tied to the\n//     socket.\n//\n// - **http2.createServer(options, [requestListener])**: additional option:\n//   - **log**: an optional [bunyan](https://github.com/trentm/node-bunyan) logger object\n//\n// - **Class: http2.ServerResponse**\n//   - **response.push(options)**: initiates a server push. `options` describes the 'imaginary'\n//     request to which the push stream is a response; the possible options are identical to the\n//     ones accepted by `http2.request`. Returns a ServerResponse object that can be used to send\n//     the response headers and content.\n//\n// - **Class: http2.Agent**\n//   - **new Agent(options)**: additional option:\n//     - **log**: an optional [bunyan](https://github.com/trentm/node-bunyan) logger object\n//   - **agent.sockets**: only contains TCP sockets that corresponds to HTTP/1 requests.\n//   - **agent.endpoints**: contains [Endpoint](protocol/endpoint.html) objects for HTTP/2 connections.\n//\n// - **http2.request(options, [callback])**:\n//   - similar to http.request\n//\n// - **http2.get(options, [callback])**:\n//   - similar to http.get\n//\n// - **Class: http2.ClientRequest**\n//   - **Event: 'socket' (socket)**: in case of an HTTP/2 incoming message, `socket` is a reference\n//     to the associated [HTTP/2 Stream](protocol/stream.html) object (and not to the TCP socket).\n//   - **Event: 'push' (promise)**: signals the intention of a server push associated to this\n//     request. `promise` is an IncomingPromise. If there's no listener for this event, the server\n//     push is cancelled.\n//   - **request.setPriority(priority)**: assign a priority to this request. `priority` is a number\n//     between 0 (highest priority) and 2^31-1 (lowest priority). Default value is 2^30.\n//\n// - **Class: http2.IncomingMessage**\n//   - has two subclasses for easier interface description: **IncomingRequest** and\n//     **IncomingResponse**\n//   - **message.socket**: in case of an HTTP/2 incoming message, it's a reference to the associated\n//     [HTTP/2 Stream](protocol/stream.html) object (and not to the TCP socket).\n//\n// - **Class: http2.IncomingRequest (IncomingMessage)**\n//   - **message.url**: in case of an HTTP/2 incoming request, the `url` field always contains the\n//     path, and never a full url (it contains the path in most cases in the HTTPS api as well).\n//   - **message.scheme**: additional field. Mandatory HTTP/2 request metadata.\n//   - **message.host**: additional field. Mandatory HTTP/2 request metadata. Note that this\n//     replaces the old Host header field, but node-http2 will add Host to the `message.headers` for\n//     backwards compatibility.\n//\n// - **Class: http2.IncomingPromise (IncomingRequest)**\n//   - contains the metadata of the 'imaginary' request to which the server push is an answer.\n//   - **Event: 'response' (response)**: signals the arrival of the actual push stream. `response`\n//     is an IncomingResponse.\n//   - **Event: 'push' (promise)**: signals the intention of a server push associated to this\n//     request. `promise` is an IncomingPromise. If there's no listener for this event, the server\n//     push is cancelled.\n//   - **promise.cancel()**: cancels the promised server push.\n//   - **promise.setPriority(priority)**: assign a priority to this push stream. `priority` is a\n//     number between 0 (highest priority) and 2^31-1 (lowest priority). Default value is 2^30.\n//\n// API elements not yet implemented\n// --------------------------------\n//\n// - **Class: http2.Server**\n//   - **server.maxHeadersCount**\n//\n// API elements that are not applicable to HTTP/2\n// ----------------------------------------------\n//\n// The reason may be deprecation of certain HTTP/1.1 features, or that some API elements simply\n// don't make sense when using HTTP/2. These will not be present when a request is done with HTTP/2,\n// but will function normally when falling back to using HTTP/1.1.\n//\n// - **Class: http2.Server**\n//   - **Event: 'checkContinue'**: not in the spec\n//   - **Event: 'upgrade'**: upgrade is deprecated in HTTP/2\n//   - **Event: 'timeout'**: HTTP/2 sockets won't timeout because of application level keepalive\n//     (PING frames)\n//   - **Event: 'connect'**: not yet supported\n//   - **server.setTimeout(msecs, [callback])**\n//   - **server.timeout**\n//\n// - **Class: http2.ServerResponse**\n//   - **Event: 'close'**\n//   - **Event: 'timeout'**\n//   - **response.writeContinue()**\n//   - **response.writeHead(statusCode, [reasonPhrase], [headers])**: reasonPhrase will always be\n//     ignored since [it's not supported in HTTP/2][3]\n//   - **response.setTimeout(timeout, [callback])**\n//\n// - **Class: http2.Agent**\n//   - **agent.maxSockets**: only affects HTTP/1 connection pool. When using HTTP/2, there's always\n//     one connection per host.\n//\n// - **Class: http2.ClientRequest**\n//   - **Event: 'upgrade'**\n//   - **Event: 'connect'**\n//   - **Event: 'continue'**\n//   - **request.setTimeout(timeout, [callback])**\n//   - **request.setNoDelay([noDelay])**\n//   - **request.setSocketKeepAlive([enable], [initialDelay])**\n//\n// - **Class: http2.IncomingMessage**\n//   - **Event: 'close'**\n//   - **message.setTimeout(timeout, [callback])**\n//\n// [1]: https://nodejs.org/api/https.html\n// [2]: https://nodejs.org/api/http.html\n// [3]: https://tools.ietf.org/html/rfc7540#section-8.1.2.4\n// Common server and client side code\n// ==================================\nvar net = require('net');\n\nvar url = require('url');\n\nvar util = require('util');\n\nvar EventEmitter = require('events').EventEmitter;\n\nvar PassThrough = require('stream').PassThrough;\n\nvar Readable = require('stream').Readable;\n\nvar Writable = require('stream').Writable;\n\nvar protocol = require('./protocol');\n\nvar Endpoint = protocol.Endpoint;\n\nvar http = require('http');\n\nvar https = require('https');\n\nexports.STATUS_CODES = http.STATUS_CODES;\nexports.IncomingMessage = IncomingMessage;\nexports.OutgoingMessage = OutgoingMessage;\nexports.protocol = protocol;\nvar deprecatedHeaders = ['connection', 'host', 'keep-alive', 'proxy-connection', 'transfer-encoding', 'upgrade']; // When doing NPN/ALPN negotiation, HTTP/1.1 is used as fallback\n\nvar supportedProtocols = [protocol.VERSION, 'http/1.1', 'http/1.0']; // Ciphersuite list based on the recommendations of https://wiki.mozilla.org/Security/Server_Side_TLS\n// The only modification is that kEDH+AESGCM were placed after DHE and ECDHE suites\n\nvar cipherSuites = ['ECDHE-RSA-AES128-GCM-SHA256', 'ECDHE-ECDSA-AES128-GCM-SHA256', 'ECDHE-RSA-AES256-GCM-SHA384', 'ECDHE-ECDSA-AES256-GCM-SHA384', 'DHE-RSA-AES128-GCM-SHA256', 'DHE-DSS-AES128-GCM-SHA256', 'ECDHE-RSA-AES128-SHA256', 'ECDHE-ECDSA-AES128-SHA256', 'ECDHE-RSA-AES128-SHA', 'ECDHE-ECDSA-AES128-SHA', 'ECDHE-RSA-AES256-SHA384', 'ECDHE-ECDSA-AES256-SHA384', 'ECDHE-RSA-AES256-SHA', 'ECDHE-ECDSA-AES256-SHA', 'DHE-RSA-AES128-SHA256', 'DHE-RSA-AES128-SHA', 'DHE-DSS-AES128-SHA256', 'DHE-RSA-AES256-SHA256', 'DHE-DSS-AES256-SHA', 'DHE-RSA-AES256-SHA', 'kEDH+AESGCM', 'AES128-GCM-SHA256', 'AES256-GCM-SHA384', 'ECDHE-RSA-RC4-SHA', 'ECDHE-ECDSA-RC4-SHA', 'AES128', 'AES256', 'RC4-SHA', 'HIGH', '!aNULL', '!eNULL', '!EXPORT', '!DES', '!3DES', '!MD5', '!PSK'].join(':'); // Logging\n// -------\n// Logger shim, used when no logger is provided by the user.\n\nfunction noop() {}\n\nvar defaultLogger = {\n  fatal: noop,\n  error: noop,\n  warn: noop,\n  info: noop,\n  debug: noop,\n  trace: noop,\n  child: function child() {\n    return this;\n  }\n}; // Bunyan serializers exported by submodules that are worth adding when creating a logger.\n\nexports.serializers = protocol.serializers; // IncomingMessage class\n// ---------------------\n\nfunction IncomingMessage(stream) {\n  // * This is basically a read-only wrapper for the [Stream](protocol/stream.html) class.\n  PassThrough.call(this);\n  stream.pipe(this);\n  this.socket = this.stream = stream;\n  this._log = stream._log.child({\n    component: 'http'\n  }); // * HTTP/2.0 does not define a way to carry the version identifier that is included in the\n  //   HTTP/1.1 request/status line. Version is always 2.0.\n\n  this.httpVersion = '2.0';\n  this.httpVersionMajor = 2;\n  this.httpVersionMinor = 0; // * `this.headers` will store the regular headers (and none of the special colon headers)\n\n  this.headers = {};\n  this.trailers = undefined;\n  this._lastHeadersSeen = undefined; // * Other metadata is filled in when the headers arrive.\n\n  stream.once('headers', this._onHeaders.bind(this));\n  stream.once('end', this._onEnd.bind(this));\n}\n\nIncomingMessage.prototype = Object.create(PassThrough.prototype, {\n  constructor: {\n    value: IncomingMessage\n  }\n}); // [Request Header Fields](https://tools.ietf.org/html/rfc7540#section-8.1.2.3)\n// * `headers` argument: HTTP/2.0 request and response header fields carry information as a series\n//   of key-value pairs. This includes the target URI for the request, the status code for the\n//   response, as well as HTTP header fields.\n\nIncomingMessage.prototype._onHeaders = function _onHeaders(headers) {\n  // * Detects malformed headers\n  this._validateHeaders(headers); // * Store the _regular_ headers in `this.headers`\n\n\n  for (var name in headers) {\n    if (name[0] !== ':') {\n      if (name === 'set-cookie' && !Array.isArray(headers[name])) {\n        this.headers[name] = [headers[name]];\n      } else {\n        this.headers[name] = headers[name];\n      }\n    }\n  } // * The last header block, if it's not the first, will represent the trailers\n\n\n  var self = this;\n  this.stream.on('headers', function (headers) {\n    self._lastHeadersSeen = headers;\n  });\n};\n\nIncomingMessage.prototype._onEnd = function _onEnd() {\n  this.trailers = this._lastHeadersSeen;\n};\n\nIncomingMessage.prototype.setTimeout = noop;\n\nIncomingMessage.prototype._checkSpecialHeader = function _checkSpecialHeader(key, value) {\n  if (typeof value !== 'string' || value.length === 0) {\n    this._log.error({\n      key: key,\n      value: value\n    }, 'Invalid or missing special header field');\n\n    this.stream.reset('PROTOCOL_ERROR');\n  }\n\n  return value;\n};\n\nIncomingMessage.prototype._validateHeaders = function _validateHeaders(headers) {\n  // * An HTTP/2.0 request or response MUST NOT include any of the following header fields:\n  //   Connection, Host, Keep-Alive, Proxy-Connection, Transfer-Encoding, and Upgrade. A server\n  //   MUST treat the presence of any of these header fields as a stream error of type\n  //   PROTOCOL_ERROR.\n  //  If the TE header is present, it's only valid value is 'trailers'\n  for (var i = 0; i < deprecatedHeaders.length; i++) {\n    var key = deprecatedHeaders[i];\n\n    if (key in headers || key === 'te' && headers[key] !== 'trailers') {\n      this._log.error({\n        key: key,\n        value: headers[key]\n      }, 'Deprecated header found');\n\n      this.stream.reset('PROTOCOL_ERROR');\n      return;\n    }\n  }\n\n  for (var headerName in headers) {\n    // * Empty header name field is malformed\n    if (headerName.length <= 1) {\n      this.stream.reset('PROTOCOL_ERROR');\n      return;\n    } // * A request or response containing uppercase header name field names MUST be\n    //   treated as malformed (Section 8.1.3.5). Implementations that detect malformed\n    //   requests or responses need to ensure that the stream ends.\n\n\n    if (/[A-Z]/.test(headerName)) {\n      this.stream.reset('PROTOCOL_ERROR');\n      return;\n    }\n  }\n}; // OutgoingMessage class\n// ---------------------\n\n\nfunction OutgoingMessage() {\n  // * This is basically a read-only wrapper for the [Stream](protocol/stream.html) class.\n  Writable.call(this);\n  this._headers = {};\n  this._trailers = undefined;\n  this.headersSent = false;\n  this.finished = false;\n  this.on('finish', this._finish);\n}\n\nOutgoingMessage.prototype = Object.create(Writable.prototype, {\n  constructor: {\n    value: OutgoingMessage\n  }\n});\n\nOutgoingMessage.prototype._write = function _write(chunk, encoding, callback) {\n  if (this.stream) {\n    this.stream.write(chunk, encoding, callback);\n  } else {\n    this.once('socket', this._write.bind(this, chunk, encoding, callback));\n  }\n};\n\nOutgoingMessage.prototype._finish = function _finish() {\n  if (this.stream) {\n    if (this._trailers) {\n      if (this.request) {\n        this.request.addTrailers(this._trailers);\n      } else {\n        this.stream.headers(this._trailers);\n      }\n    }\n\n    this.finished = true;\n    this.stream.end();\n  } else {\n    this.once('socket', this._finish.bind(this));\n  }\n};\n\nOutgoingMessage.prototype.setHeader = function setHeader(name, value) {\n  if (this.headersSent) {\n    return this.emit('error', new Error('Can\\'t set headers after they are sent.'));\n  } else {\n    name = name.toLowerCase();\n\n    if (deprecatedHeaders.indexOf(name) !== -1) {\n      return this.emit('error', new Error('Cannot set deprecated header: ' + name));\n    }\n\n    this._headers[name] = value;\n  }\n};\n\nOutgoingMessage.prototype.removeHeader = function removeHeader(name) {\n  if (this.headersSent) {\n    return this.emit('error', new Error('Can\\'t remove headers after they are sent.'));\n  } else {\n    delete this._headers[name.toLowerCase()];\n  }\n};\n\nOutgoingMessage.prototype.getHeader = function getHeader(name) {\n  return this._headers[name.toLowerCase()];\n};\n\nOutgoingMessage.prototype.addTrailers = function addTrailers(trailers) {\n  this._trailers = trailers;\n};\n\nOutgoingMessage.prototype.setTimeout = noop;\nOutgoingMessage.prototype._checkSpecialHeader = IncomingMessage.prototype._checkSpecialHeader; // Server side\n// ===========\n\nexports.Server = Server;\nexports.IncomingRequest = IncomingRequest;\nexports.OutgoingResponse = OutgoingResponse;\nexports.ServerResponse = OutgoingResponse; // for API compatibility\n// Forward events `event` on `source` to all listeners on `target`.\n//\n// Note: The calling context is `source`.\n\nfunction forwardEvent(event, source, target) {\n  function forward() {\n    var listeners = target.listeners(event);\n    var n = listeners.length; // Special case for `error` event with no listeners.\n\n    if (n === 0 && event === 'error') {\n      var args = [event];\n      args.push.apply(args, arguments);\n      target.emit.apply(target, args);\n      return;\n    }\n\n    for (var i = 0; i < n; ++i) {\n      listeners[i].apply(source, arguments);\n    }\n  }\n\n  source.on(event, forward); // A reference to the function is necessary to be able to stop\n  // forwarding.\n\n  return forward;\n} // Server class\n// ------------\n\n\nfunction Server(options) {\n  options = util._extend({}, options);\n  this._log = (options.log || defaultLogger).child({\n    component: 'http'\n  });\n  this._settings = options.settings;\n\n  var start = this._start.bind(this);\n\n  var fallback = this._fallback.bind(this); // HTTP2 over TLS (using NPN or ALPN)\n\n\n  if (options.key && options.cert || options.pfx) {\n    this._log.info('Creating HTTP/2 server over TLS');\n\n    this._mode = 'tls';\n    options.ALPNProtocols = supportedProtocols;\n    options.NPNProtocols = supportedProtocols;\n    options.ciphers = options.ciphers || cipherSuites;\n    options.honorCipherOrder = options.honorCipherOrder != false;\n    this._server = https.createServer(options);\n    this._originalSocketListeners = this._server.listeners('secureConnection');\n\n    this._server.removeAllListeners('secureConnection');\n\n    this._server.on('secureConnection', function (socket) {\n      var negotiatedProtocol = socket.alpnProtocol || socket.npnProtocol; // It's true that the client MUST use SNI, but if it doesn't, we don't care, don't fall back to HTTP/1,\n      // since if the ALPN negotiation is otherwise successful, the client thinks we speak HTTP/2 but we don't.\n\n      if (negotiatedProtocol === protocol.VERSION) {\n        start(socket);\n      } else {\n        fallback(socket);\n      }\n    });\n\n    this._server.on('request', this.emit.bind(this, 'request'));\n\n    forwardEvent('error', this._server, this);\n    forwardEvent('listening', this._server, this);\n  } // HTTP2 over plain TCP\n  else if (options.plain) {\n      this._log.info('Creating HTTP/2 server over plain TCP');\n\n      this._mode = 'plain';\n      this._server = net.createServer(start);\n    } // HTTP/2 with HTTP/1.1 upgrade\n    else {\n        this._log.error('Trying to create HTTP/2 server with Upgrade from HTTP/1.1');\n\n        throw new Error('HTTP1.1 -> HTTP2 upgrade is not yet supported. Please provide TLS keys.');\n      }\n\n  this._server.on('close', this.emit.bind(this, 'close'));\n}\n\nServer.prototype = Object.create(EventEmitter.prototype, {\n  constructor: {\n    value: Server\n  }\n}); // Starting HTTP/2\n\nServer.prototype._start = function _start(socket) {\n  var endpoint = new Endpoint(this._log, 'SERVER', this._settings);\n\n  this._log.info({\n    e: endpoint,\n    client: socket.remoteAddress + ':' + socket.remotePort,\n    SNI: socket.servername\n  }, 'New incoming HTTP/2 connection');\n\n  endpoint.pipe(socket).pipe(endpoint);\n  var self = this;\n  endpoint.on('stream', function _onStream(stream) {\n    var response = new OutgoingResponse(stream);\n    var request = new IncomingRequest(stream); // Some conformance to Node.js Https specs allows to distinguish clients:\n\n    request.remoteAddress = socket.remoteAddress;\n    request.remotePort = socket.remotePort;\n    request.connection = request.socket = response.socket = socket;\n    request.once('ready', self.emit.bind(self, 'request', request, response));\n  });\n  endpoint.on('error', this.emit.bind(this, 'clientError'));\n  socket.on('error', this.emit.bind(this, 'clientError'));\n  this.emit('connection', socket, endpoint);\n};\n\nServer.prototype._fallback = function _fallback(socket) {\n  var negotiatedProtocol = socket.alpnProtocol || socket.npnProtocol;\n\n  this._log.info({\n    client: socket.remoteAddress + ':' + socket.remotePort,\n    protocol: negotiatedProtocol,\n    SNI: socket.servername\n  }, 'Falling back to simple HTTPS');\n\n  for (var i = 0; i < this._originalSocketListeners.length; i++) {\n    this._originalSocketListeners[i].call(this._server, socket);\n  }\n\n  this.emit('connection', socket);\n}; // There are [3 possible signatures][1] of the `listen` function. Every arguments is forwarded to\n// the backing TCP or HTTPS server.\n// [1]: https://nodejs.org/api/http.html#http_server_listen_port_hostname_backlog_callback\n\n\nServer.prototype.listen = function listen(port, hostname) {\n  this._log.info({\n    on: typeof hostname === 'string' ? hostname + ':' + port : port\n  }, 'Listening for incoming connections');\n\n  this._server.listen.apply(this._server, arguments);\n\n  return this._server;\n};\n\nServer.prototype.close = function close(callback) {\n  this._log.info('Closing server');\n\n  this._server.close(callback);\n};\n\nServer.prototype.setTimeout = function setTimeout(timeout, callback) {\n  if (this._mode === 'tls') {\n    this._server.setTimeout(timeout, callback);\n  }\n};\n\nObject.defineProperty(Server.prototype, 'timeout', {\n  get: function getTimeout() {\n    if (this._mode === 'tls') {\n      return this._server.timeout;\n    } else {\n      return undefined;\n    }\n  },\n  set: function setTimeout(timeout) {\n    if (this._mode === 'tls') {\n      this._server.timeout = timeout;\n    }\n  }\n}); // Overriding `EventEmitter`'s `on(event, listener)` method to forward certain subscriptions to\n// `server`.There are events on the `http.Server` class where it makes difference whether someone is\n// listening on the event or not. In these cases, we can not simply forward the events from the\n// `server` to `this` since that means a listener. Instead, we forward the subscriptions.\n\nServer.prototype.on = function on(event, listener) {\n  if (event === 'upgrade' || event === 'timeout') {\n    return this._server.on(event, listener && listener.bind(this));\n  } else {\n    return EventEmitter.prototype.on.call(this, event, listener);\n  }\n}; // `addContext` is used to add Server Name Indication contexts\n\n\nServer.prototype.addContext = function addContext(hostname, credentials) {\n  if (this._mode === 'tls') {\n    this._server.addContext(hostname, credentials);\n  }\n};\n\nServer.prototype.address = function address() {\n  return this._server.address();\n};\n\nfunction createServerRaw(options, requestListener) {\n  if (typeof options === 'function') {\n    requestListener = options;\n    options = {};\n  }\n\n  if (options.pfx || options.key && options.cert) {\n    throw new Error('options.pfx, options.key, and options.cert are nonsensical!');\n  }\n\n  options.plain = true;\n  var server = new Server(options);\n\n  if (requestListener) {\n    server.on('request', requestListener);\n  }\n\n  return server;\n}\n\nfunction createServerTLS(options, requestListener) {\n  if (typeof options === 'function') {\n    throw new Error('options are required!');\n  }\n\n  if (!options.pfx && !(options.key && options.cert)) {\n    throw new Error('options.pfx or options.key and options.cert are required!');\n  }\n\n  options.plain = false;\n  var server = new Server(options);\n\n  if (requestListener) {\n    server.on('request', requestListener);\n  }\n\n  return server;\n} // Exposed main interfaces for HTTPS connections (the default)\n\n\nexports.https = {};\nexports.createServer = exports.https.createServer = createServerTLS;\nexports.request = exports.https.request = requestTLS;\nexports.get = exports.https.get = getTLS; // Exposed main interfaces for raw TCP connections (not recommended)\n\nexports.raw = {};\nexports.raw.createServer = createServerRaw;\nexports.raw.request = requestRaw;\nexports.raw.get = getRaw; // Exposed main interfaces for HTTP plaintext upgrade connections (not implemented)\n\nfunction notImplemented() {\n  throw new Error('HTTP UPGRADE is not implemented!');\n}\n\nexports.http = {};\nexports.http.createServer = exports.http.request = exports.http.get = notImplemented; // IncomingRequest class\n// ---------------------\n\nfunction IncomingRequest(stream) {\n  IncomingMessage.call(this, stream);\n}\n\nIncomingRequest.prototype = Object.create(IncomingMessage.prototype, {\n  constructor: {\n    value: IncomingRequest\n  }\n}); // [Request Header Fields](https://tools.ietf.org/html/rfc7540#section-8.1.2.3)\n// * `headers` argument: HTTP/2.0 request and response header fields carry information as a series\n//   of key-value pairs. This includes the target URI for the request, the status code for the\n//   response, as well as HTTP header fields.\n\nIncomingRequest.prototype._onHeaders = function _onHeaders(headers) {\n  // * The \":method\" header field includes the HTTP method\n  // * The \":scheme\" header field includes the scheme portion of the target URI\n  // * The \":authority\" header field includes the authority portion of the target URI\n  // * The \":path\" header field includes the path and query parts of the target URI.\n  //   This field MUST NOT be empty; URIs that do not contain a path component MUST include a value\n  //   of '/', unless the request is an OPTIONS request for '*', in which case the \":path\" header\n  //   field MUST include '*'.\n  // * All HTTP/2.0 requests MUST include exactly one valid value for all of these header fields. A\n  //   server MUST treat the absence of any of these header fields, presence of multiple values, or\n  //   an invalid value as a stream error of type PROTOCOL_ERROR.\n  this.method = this._checkSpecialHeader(':method', headers[':method']);\n  this.scheme = this._checkSpecialHeader(':scheme', headers[':scheme']);\n  this.host = this._checkSpecialHeader(':authority', headers[':authority']);\n  this.url = this._checkSpecialHeader(':path', headers[':path']);\n\n  if (!this.method || !this.scheme || !this.host || !this.url) {\n    // This is invalid, and we've sent a RST_STREAM, so don't continue processing\n    return;\n  } // * Host header is included in the headers object for backwards compatibility.\n\n\n  this.headers.host = this.host; // * Handling regular headers.\n\n  IncomingMessage.prototype._onHeaders.call(this, headers); // * Signaling that the headers arrived.\n\n\n  this._log.info({\n    method: this.method,\n    scheme: this.scheme,\n    host: this.host,\n    path: this.url,\n    headers: this.headers\n  }, 'Incoming request');\n\n  this.emit('ready');\n}; // OutgoingResponse class\n// ----------------------\n\n\nfunction OutgoingResponse(stream) {\n  OutgoingMessage.call(this);\n  this._log = stream._log.child({\n    component: 'http'\n  });\n  this.stream = stream;\n  this.statusCode = 200;\n  this.sendDate = true;\n  this.stream.once('headers', this._onRequestHeaders.bind(this));\n}\n\nOutgoingResponse.prototype = Object.create(OutgoingMessage.prototype, {\n  constructor: {\n    value: OutgoingResponse\n  }\n});\n\nOutgoingResponse.prototype.writeHead = function writeHead(statusCode, reasonPhrase, headers) {\n  if (this.headersSent) {\n    return;\n  }\n\n  if (typeof reasonPhrase === 'string') {\n    this._log.warn('Reason phrase argument was present but ignored by the writeHead method');\n  } else {\n    headers = reasonPhrase;\n  }\n\n  for (var name in headers) {\n    this.setHeader(name, headers[name]);\n  }\n\n  headers = this._headers;\n\n  if (this.sendDate && !('date' in this._headers)) {\n    headers.date = new Date().toUTCString();\n  }\n\n  this._log.info({\n    status: statusCode,\n    headers: this._headers\n  }, 'Sending server response');\n\n  headers[':status'] = this.statusCode = statusCode;\n  this.stream.headers(headers);\n  this.headersSent = true;\n};\n\nOutgoingResponse.prototype._implicitHeaders = function _implicitHeaders() {\n  if (!this.headersSent) {\n    this.writeHead(this.statusCode);\n  }\n};\n\nOutgoingResponse.prototype._implicitHeader = function () {\n  this._implicitHeaders();\n};\n\nOutgoingResponse.prototype.write = function write() {\n  this._implicitHeaders();\n\n  return OutgoingMessage.prototype.write.apply(this, arguments);\n};\n\nOutgoingResponse.prototype.end = function end() {\n  this.finshed = true;\n\n  this._implicitHeaders();\n\n  return OutgoingMessage.prototype.end.apply(this, arguments);\n};\n\nOutgoingResponse.prototype._onRequestHeaders = function _onRequestHeaders(headers) {\n  this._requestHeaders = headers;\n};\n\nOutgoingResponse.prototype.push = function push(options) {\n  if (typeof options === 'string') {\n    options = url.parse(options);\n  }\n\n  if (!options.path) {\n    throw new Error('`path` option is mandatory.');\n  }\n\n  var promise = util._extend({\n    ':method': (options.method || 'GET').toUpperCase(),\n    ':scheme': options.protocol && options.protocol.slice(0, -1) || this._requestHeaders[':scheme'],\n    ':authority': options.hostname || options.host || this._requestHeaders[':authority'],\n    ':path': options.path\n  }, options.headers);\n\n  this._log.info({\n    method: promise[':method'],\n    scheme: promise[':scheme'],\n    authority: promise[':authority'],\n    path: promise[':path'],\n    headers: options.headers\n  }, 'Promising push stream');\n\n  var pushStream = this.stream.promise(promise);\n  return new OutgoingResponse(pushStream);\n};\n\nOutgoingResponse.prototype.altsvc = function altsvc(host, port, protocolID, maxAge, origin) {\n  if (origin === undefined) {\n    origin = \"\";\n  }\n\n  this.stream.altsvc(host, port, protocolID, maxAge, origin);\n}; // Overriding `EventEmitter`'s `on(event, listener)` method to forward certain subscriptions to\n// `request`. See `Server.prototype.on` for explanation.\n\n\nOutgoingResponse.prototype.on = function on(event, listener) {\n  if (this.request && event === 'timeout') {\n    this.request.on(event, listener && listener.bind(this));\n  } else {\n    OutgoingMessage.prototype.on.call(this, event, listener);\n  }\n}; // Client side\n// ===========\n\n\nexports.ClientRequest = OutgoingRequest; // for API compatibility\n\nexports.OutgoingRequest = OutgoingRequest;\nexports.IncomingResponse = IncomingResponse;\nexports.Agent = Agent;\nexports.globalAgent = undefined;\n\nfunction requestRaw(options, callback) {\n  if (typeof options === \"string\") {\n    options = url.parse(options);\n  }\n\n  options.plain = true;\n\n  if (options.protocol && options.protocol !== \"http:\") {\n    throw new Error('This interface only supports http-schemed URLs');\n  }\n\n  if (options.agent && typeof options.agent.request === 'function') {\n    var agentOptions = util._extend({}, options);\n\n    delete agentOptions.agent;\n    return options.agent.request(agentOptions, callback);\n  }\n\n  return exports.globalAgent.request(options, callback);\n}\n\nfunction requestTLS(options, callback) {\n  if (typeof options === \"string\") {\n    options = url.parse(options);\n  }\n\n  options.plain = false;\n\n  if (options.protocol && options.protocol !== \"https:\") {\n    throw new Error('This interface only supports https-schemed URLs');\n  }\n\n  if (options.agent && typeof options.agent.request === 'function') {\n    var agentOptions = util._extend({}, options);\n\n    delete agentOptions.agent;\n    return options.agent.request(agentOptions, callback);\n  }\n\n  return exports.globalAgent.request(options, callback);\n}\n\nfunction getRaw(options, callback) {\n  if (typeof options === \"string\") {\n    options = url.parse(options);\n  }\n\n  options.plain = true;\n\n  if (options.protocol && options.protocol !== \"http:\") {\n    throw new Error('This interface only supports http-schemed URLs');\n  }\n\n  if (options.agent && typeof options.agent.get === 'function') {\n    var agentOptions = util._extend({}, options);\n\n    delete agentOptions.agent;\n    return options.agent.get(agentOptions, callback);\n  }\n\n  return exports.globalAgent.get(options, callback);\n}\n\nfunction getTLS(options, callback) {\n  if (typeof options === \"string\") {\n    options = url.parse(options);\n  }\n\n  options.plain = false;\n\n  if (options.protocol && options.protocol !== \"https:\") {\n    throw new Error('This interface only supports https-schemed URLs');\n  }\n\n  if (options.agent && typeof options.agent.get === 'function') {\n    var agentOptions = util._extend({}, options);\n\n    delete agentOptions.agent;\n    return options.agent.get(agentOptions, callback);\n  }\n\n  return exports.globalAgent.get(options, callback);\n} // Agent class\n// -----------\n\n\nfunction Agent(options) {\n  EventEmitter.call(this);\n  this.setMaxListeners(0);\n  options = util._extend({}, options);\n  this._settings = options.settings;\n  this._log = (options.log || defaultLogger).child({\n    component: 'http'\n  });\n  this.endpoints = {}; // * Using an own HTTPS agent, because the global agent does not look at `NPN/ALPNProtocols` when\n  //   generating the key identifying the connection, so we may get useless non-negotiated TLS\n  //   channels even if we ask for a negotiated one. This agent will contain only negotiated\n  //   channels.\n\n  options.ALPNProtocols = supportedProtocols;\n  options.NPNProtocols = supportedProtocols;\n  this._httpsAgent = new https.Agent(options);\n  this.sockets = this._httpsAgent.sockets;\n  this.requests = this._httpsAgent.requests;\n}\n\nAgent.prototype = Object.create(EventEmitter.prototype, {\n  constructor: {\n    value: Agent\n  }\n});\n\nAgent.prototype.request = function request(options, callback) {\n  if (typeof options === 'string') {\n    options = url.parse(options);\n  } else {\n    options = util._extend({}, options);\n  }\n\n  options.method = (options.method || 'GET').toUpperCase();\n  options.protocol = options.protocol || 'https:';\n  options.host = options.hostname || options.host || 'localhost';\n  options.port = options.port || 443;\n  options.path = options.path || '/';\n\n  if (!options.plain && options.protocol === 'http:') {\n    this._log.error('Trying to negotiate client request with Upgrade from HTTP/1.1');\n\n    this.emit('error', new Error('HTTP1.1 -> HTTP2 upgrade is not yet supported.'));\n  }\n\n  var request = new OutgoingRequest(this._log);\n\n  if (callback) {\n    request.on('response', callback);\n  }\n\n  var key = [!!options.plain, options.host, options.port].join(':');\n  var self = this; // * There's an existing HTTP/2 connection to this host\n\n  if (key in this.endpoints) {\n    var endpoint = this.endpoints[key];\n\n    request._start(endpoint.createStream(), options);\n  } // * HTTP/2 over plain TCP\n  else if (options.plain) {\n      endpoint = new Endpoint(this._log, 'CLIENT', this._settings);\n      endpoint.socket = net.connect({\n        host: options.host,\n        port: options.port,\n        localAddress: options.localAddress\n      });\n      endpoint.socket.on('error', function (error) {\n        self._log.error('Socket error: ' + error.toString());\n\n        request.emit('error', error);\n      });\n      endpoint.on('error', function (error) {\n        self._log.error('Connection error: ' + error.toString());\n\n        request.emit('error', error);\n      });\n      this.endpoints[key] = endpoint;\n      endpoint.pipe(endpoint.socket).pipe(endpoint);\n\n      request._start(endpoint.createStream(), options);\n    } // * HTTP/2 over TLS negotiated using NPN or ALPN, or fallback to HTTPS1\n    else {\n        var negotiated = function negotiated() {\n          var endpoint;\n          var negotiatedProtocol = httpsRequest.socket.alpnProtocol || httpsRequest.socket.npnProtocol;\n\n          if (negotiatedProtocol === protocol.VERSION) {\n            httpsRequest.socket.emit('agentRemove');\n            unbundleSocket(httpsRequest.socket);\n            endpoint = new Endpoint(self._log, 'CLIENT', self._settings);\n            endpoint.socket = httpsRequest.socket;\n            endpoint.pipe(endpoint.socket).pipe(endpoint);\n          }\n\n          if (started) {\n            // ** In the meantime, an other connection was made to the same host...\n            if (endpoint) {\n              // *** and it turned out to be HTTP2 and the request was multiplexed on that one, so we should close this one\n              endpoint.close();\n            } // *** otherwise, the fallback to HTTPS1 is already done.\n\n          } else {\n            if (endpoint) {\n              self._log.info({\n                e: endpoint,\n                server: options.host + ':' + options.port\n              }, 'New outgoing HTTP/2 connection');\n\n              self.endpoints[key] = endpoint;\n              self.emit(key, endpoint);\n            } else {\n              self.emit(key, undefined);\n            }\n          }\n        };\n\n        var started = false;\n        var createAgent = hasAgentOptions(options);\n        options.ALPNProtocols = supportedProtocols;\n        options.NPNProtocols = supportedProtocols;\n        options.servername = options.host; // Server Name Indication\n\n        options.ciphers = options.ciphers || cipherSuites;\n\n        if (createAgent) {\n          options.agent = new https.Agent(options);\n        } else if (options.agent == null) {\n          options.agent = this._httpsAgent;\n        }\n\n        var httpsRequest = https.request(options);\n        httpsRequest.on('error', function (error) {\n          self._log.error('Socket error: ' + error.toString());\n\n          self.removeAllListeners(key);\n          request.emit('error', error);\n        });\n        httpsRequest.on('socket', function (socket) {\n          var negotiatedProtocol = socket.alpnProtocol || socket.npnProtocol;\n\n          if (negotiatedProtocol != null) {\n            // null in >=0.11.0, undefined in <0.11.0\n            negotiated();\n          } else {\n            socket.on('secureConnect', negotiated);\n          }\n        });\n        this.once(key, function (endpoint) {\n          started = true;\n\n          if (endpoint) {\n            request._start(endpoint.createStream(), options);\n          } else {\n            request._fallback(httpsRequest);\n          }\n        });\n      }\n\n  return request;\n};\n\nAgent.prototype.get = function get(options, callback) {\n  var request = this.request(options, callback);\n  request.end();\n  return request;\n};\n\nAgent.prototype.destroy = function (error) {\n  if (this._httpsAgent) {\n    this._httpsAgent.destroy();\n  }\n\n  for (var key in this.endpoints) {\n    this.endpoints[key].close(error);\n  }\n};\n\nfunction unbundleSocket(socket) {\n  socket.removeAllListeners('data');\n  socket.removeAllListeners('end');\n  socket.removeAllListeners('readable');\n  socket.removeAllListeners('close');\n  socket.removeAllListeners('error');\n  socket.unpipe();\n  delete socket.ondata;\n  delete socket.onend;\n}\n\nfunction hasAgentOptions(options) {\n  return options.pfx != null || options.key != null || options.passphrase != null || options.cert != null || options.ca != null || options.ciphers != null || options.rejectUnauthorized != null || options.secureProtocol != null;\n}\n\nObject.defineProperty(Agent.prototype, 'maxSockets', {\n  get: function getMaxSockets() {\n    return this._httpsAgent.maxSockets;\n  },\n  set: function setMaxSockets(value) {\n    this._httpsAgent.maxSockets = value;\n  }\n});\nexports.globalAgent = new Agent(); // OutgoingRequest class\n// ---------------------\n\nfunction OutgoingRequest() {\n  OutgoingMessage.call(this);\n  this._log = undefined;\n  this.stream = undefined;\n}\n\nOutgoingRequest.prototype = Object.create(OutgoingMessage.prototype, {\n  constructor: {\n    value: OutgoingRequest\n  }\n});\n\nOutgoingRequest.prototype._start = function _start(stream, options) {\n  this.stream = stream;\n  this.options = options;\n  this._log = stream._log.child({\n    component: 'http'\n  });\n\n  for (var key in options.headers) {\n    this.setHeader(key, options.headers[key]);\n  }\n\n  var headers = this._headers;\n  delete headers.host;\n\n  if (options.auth) {\n    headers.authorization = 'Basic ' + new Buffer(options.auth).toString('base64');\n  }\n\n  headers[':scheme'] = options.protocol.slice(0, -1);\n  headers[':method'] = options.method;\n  headers[':authority'] = options.host;\n  headers[':path'] = options.path;\n\n  this._log.info({\n    scheme: headers[':scheme'],\n    method: headers[':method'],\n    authority: headers[':authority'],\n    path: headers[':path'],\n    headers: options.headers || {}\n  }, 'Sending request');\n\n  this.stream.headers(headers);\n  this.headersSent = true;\n  this.emit('socket', this.stream);\n  var response = new IncomingResponse(this.stream);\n  response.req = this;\n  response.once('ready', this.emit.bind(this, 'response', response));\n  this.stream.on('promise', this._onPromise.bind(this));\n};\n\nOutgoingRequest.prototype._fallback = function _fallback(request) {\n  request.on('response', this.emit.bind(this, 'response'));\n  this.stream = this.request = request;\n  this.emit('socket', this.socket);\n};\n\nOutgoingRequest.prototype.setPriority = function setPriority(priority) {\n  if (this.stream) {\n    this.stream.priority(priority);\n  } else {\n    this.once('socket', this.setPriority.bind(this, priority));\n  }\n}; // Overriding `EventEmitter`'s `on(event, listener)` method to forward certain subscriptions to\n// `request`. See `Server.prototype.on` for explanation.\n\n\nOutgoingRequest.prototype.on = function on(event, listener) {\n  if (this.request && event === 'upgrade') {\n    this.request.on(event, listener && listener.bind(this));\n  } else {\n    OutgoingMessage.prototype.on.call(this, event, listener);\n  }\n}; // Methods only in fallback mode\n\n\nOutgoingRequest.prototype.setNoDelay = function setNoDelay(noDelay) {\n  if (this.request) {\n    this.request.setNoDelay(noDelay);\n  } else if (!this.stream) {\n    this.on('socket', this.setNoDelay.bind(this, noDelay));\n  }\n};\n\nOutgoingRequest.prototype.setSocketKeepAlive = function setSocketKeepAlive(enable, initialDelay) {\n  if (this.request) {\n    this.request.setSocketKeepAlive(enable, initialDelay);\n  } else if (!this.stream) {\n    this.on('socket', this.setSocketKeepAlive.bind(this, enable, initialDelay));\n  }\n};\n\nOutgoingRequest.prototype.setTimeout = function setTimeout(timeout, callback) {\n  if (this.request) {\n    this.request.setTimeout(timeout, callback);\n  } else if (!this.stream) {\n    this.on('socket', this.setTimeout.bind(this, timeout, callback));\n  }\n}; // Aborting the request\n\n\nOutgoingRequest.prototype.abort = function abort() {\n  if (this.request) {\n    this.request.abort();\n  } else if (this.stream) {\n    this.stream.reset('CANCEL');\n  } else {\n    this.on('socket', this.abort.bind(this));\n  }\n}; // Receiving push promises\n\n\nOutgoingRequest.prototype._onPromise = function _onPromise(stream, headers) {\n  this._log.info({\n    push_stream: stream.id\n  }, 'Receiving push promise');\n\n  var promise = new IncomingPromise(stream, headers);\n\n  if (this.listeners('push').length > 0) {\n    this.emit('push', promise);\n  } else {\n    promise.cancel();\n  }\n}; // IncomingResponse class\n// ----------------------\n\n\nfunction IncomingResponse(stream) {\n  IncomingMessage.call(this, stream);\n}\n\nIncomingResponse.prototype = Object.create(IncomingMessage.prototype, {\n  constructor: {\n    value: IncomingResponse\n  }\n}); // [Response Header Fields](https://tools.ietf.org/html/rfc7540#section-8.1.2.4)\n// * `headers` argument: HTTP/2.0 request and response header fields carry information as a series\n//   of key-value pairs. This includes the target URI for the request, the status code for the\n//   response, as well as HTTP header fields.\n\nIncomingResponse.prototype._onHeaders = function _onHeaders(headers) {\n  // * A single \":status\" header field is defined that carries the HTTP status code field. This\n  //   header field MUST be included in all responses.\n  // * A client MUST treat the absence of the \":status\" header field, the presence of multiple\n  //   values, or an invalid value as a stream error of type PROTOCOL_ERROR.\n  //   Note: currently, we do not enforce it strictly: we accept any format, and parse it as int\n  // * HTTP/2.0 does not define a way to carry the reason phrase that is included in an HTTP/1.1\n  //   status line.\n  this.statusCode = parseInt(this._checkSpecialHeader(':status', headers[':status'])); // * Handling regular headers.\n\n  IncomingMessage.prototype._onHeaders.call(this, headers); // * Signaling that the headers arrived.\n\n\n  this._log.info({\n    status: this.statusCode,\n    headers: this.headers\n  }, 'Incoming response');\n\n  this.emit('ready');\n}; // IncomingPromise class\n// -------------------------\n\n\nfunction IncomingPromise(responseStream, promiseHeaders) {\n  var stream = new Readable();\n  stream._read = noop;\n  stream.push(null);\n  stream._log = responseStream._log;\n  IncomingRequest.call(this, stream);\n\n  this._onHeaders(promiseHeaders);\n\n  this._responseStream = responseStream;\n  var response = new IncomingResponse(this._responseStream);\n  response.once('ready', this.emit.bind(this, 'response', response));\n  this.stream.on('promise', this._onPromise.bind(this));\n}\n\nIncomingPromise.prototype = Object.create(IncomingRequest.prototype, {\n  constructor: {\n    value: IncomingPromise\n  }\n});\n\nIncomingPromise.prototype.cancel = function cancel() {\n  this._responseStream.reset('CANCEL');\n};\n\nIncomingPromise.prototype.setPriority = function setPriority(priority) {\n  this._responseStream.priority(priority);\n};\n\nIncomingPromise.prototype._onPromise = OutgoingRequest.prototype._onPromise;","map":null,"metadata":{},"sourceType":"script"}