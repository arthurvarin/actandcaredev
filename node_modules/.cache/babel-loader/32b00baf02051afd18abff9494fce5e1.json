{"ast":null,"code":"/*! firebase-admin v6.5.0 */\n\"use strict\";\n/*!\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar api_request_1 = require(\"../utils/api-request\");\n\nvar error_1 = require(\"../utils/error\");\n\nvar validator = require(\"../utils/validator\"); // FCM backend constants\n\n\nvar FIREBASE_MESSAGING_TIMEOUT = 10000;\nvar FIREBASE_MESSAGING_HTTP_METHOD = 'POST';\nvar FIREBASE_MESSAGING_HEADERS = {\n  'Sdk-Version': 'Node/Admin/6.5.0',\n  'access_token_auth': 'true'\n};\n/**\n * Class that provides a mechanism to send requests to the Firebase Cloud Messaging backend.\n */\n\nvar FirebaseMessagingRequestHandler =\n/** @class */\nfunction () {\n  /**\n   * @param {FirebaseApp} app The app used to fetch access tokens to sign API requests.\n   * @constructor\n   */\n  function FirebaseMessagingRequestHandler(app) {\n    this.httpClient = new api_request_1.AuthorizedHttpClient(app);\n  }\n  /**\n   * @param {object} response The response to check for errors.\n   * @return {string|null} The error code if present; null otherwise.\n   */\n\n\n  FirebaseMessagingRequestHandler.getErrorCode = function (response) {\n    if (validator.isNonNullObject(response) && 'error' in response) {\n      if (validator.isString(response.error)) {\n        return response.error;\n      }\n\n      if (validator.isArray(response.error.details)) {\n        var fcmErrorType = 'type.googleapis.com/google.firebase.fcm.v1.FcmError';\n\n        for (var _i = 0, _a = response.error.details; _i < _a.length; _i++) {\n          var element = _a[_i];\n\n          if (element['@type'] === fcmErrorType) {\n            return element.errorCode;\n          }\n        }\n      }\n\n      if ('status' in response.error) {\n        return response.error.status;\n      } else {\n        return response.error.message;\n      }\n    }\n\n    return null;\n  };\n  /**\n   * Extracts error message from the given response object.\n   *\n   * @param {object} response The response to check for errors.\n   * @return {string|null} The error message if present; null otherwise.\n   */\n\n\n  FirebaseMessagingRequestHandler.getErrorMessage = function (response) {\n    if (validator.isNonNullObject(response) && 'error' in response && validator.isNonEmptyString(response.error.message)) {\n      return response.error.message;\n    }\n\n    return null;\n  };\n  /**\n   * Invokes the request handler with the provided request data.\n   *\n   * @param {string} host The host to which to send the request.\n   * @param {string} path The path to which to send the request.\n   * @param {object} requestData The request data.\n   * @return {Promise<object>} A promise that resolves with the response.\n   */\n\n\n  FirebaseMessagingRequestHandler.prototype.invokeRequestHandler = function (host, path, requestData) {\n    var _this = this;\n\n    var request = {\n      method: FIREBASE_MESSAGING_HTTP_METHOD,\n      url: \"https://\" + host + path,\n      data: requestData,\n      headers: FIREBASE_MESSAGING_HEADERS,\n      timeout: FIREBASE_MESSAGING_TIMEOUT\n    };\n    return this.httpClient.send(request).then(function (response) {\n      // Send non-JSON responses to the catch() below where they will be treated as errors.\n      if (!response.isJson()) {\n        throw new api_request_1.HttpError(response);\n      } // Check for backend errors in the response.\n\n\n      var errorCode = FirebaseMessagingRequestHandler.getErrorCode(response.data);\n\n      if (errorCode) {\n        throw new api_request_1.HttpError(response);\n      } // Return entire response.\n\n\n      return response.data;\n    }).catch(function (err) {\n      if (err instanceof api_request_1.HttpError) {\n        _this.handleHttpError(err);\n      } // Re-throw the error if it already has the proper format.\n\n\n      throw err;\n    });\n  };\n\n  FirebaseMessagingRequestHandler.prototype.handleHttpError = function (err) {\n    if (err.response.isJson()) {\n      // For JSON responses, map the server response to a client-side error.\n      var json = err.response.data;\n      var errorCode = FirebaseMessagingRequestHandler.getErrorCode(json);\n      var errorMessage = FirebaseMessagingRequestHandler.getErrorMessage(json);\n      throw error_1.FirebaseMessagingError.fromServerError(errorCode, errorMessage, json);\n    } // Non-JSON response\n\n\n    var error;\n\n    switch (err.response.status) {\n      case 400:\n        error = error_1.MessagingClientErrorCode.INVALID_ARGUMENT;\n        break;\n\n      case 401:\n      case 403:\n        error = error_1.MessagingClientErrorCode.AUTHENTICATION_ERROR;\n        break;\n\n      case 500:\n        error = error_1.MessagingClientErrorCode.INTERNAL_ERROR;\n        break;\n\n      case 503:\n        error = error_1.MessagingClientErrorCode.SERVER_UNAVAILABLE;\n        break;\n\n      default:\n        // Treat non-JSON responses with unexpected status codes as unknown errors.\n        error = error_1.MessagingClientErrorCode.UNKNOWN_ERROR;\n    }\n\n    throw new error_1.FirebaseMessagingError({\n      code: error.code,\n      message: error.message + \" Raw server response: \\\"\" + err.response.text + \"\\\". Status code: \" + (err.response.status + \".\")\n    });\n  };\n\n  return FirebaseMessagingRequestHandler;\n}();\n\nexports.FirebaseMessagingRequestHandler = FirebaseMessagingRequestHandler;","map":null,"metadata":{},"sourceType":"script"}