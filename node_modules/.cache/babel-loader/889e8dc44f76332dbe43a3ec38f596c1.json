{"ast":null,"code":"/*! firebase-admin v6.5.0 */\n\"use strict\";\n/*!\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nvar __extends = this && this.__extends || function () {\n  var extendStatics = Object.setPrototypeOf || {\n    __proto__: []\n  } instanceof Array && function (d, b) {\n    d.__proto__ = b;\n  } || function (d, b) {\n    for (var p in b) {\n      if (b.hasOwnProperty(p)) d[p] = b[p];\n    }\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar user_record_1 = require(\"./user-record\");\n\nvar token_generator_1 = require(\"./token-generator\");\n\nvar auth_api_request_1 = require(\"./auth-api-request\");\n\nvar error_1 = require(\"../utils/error\");\n\nvar utils = require(\"../utils/index\");\n\nvar validator = require(\"../utils/validator\");\n\nvar token_verifier_1 = require(\"./token-verifier\");\n/**\n * Internals of an Auth instance.\n */\n\n\nvar AuthInternals =\n/** @class */\nfunction () {\n  function AuthInternals() {}\n  /**\n   * Deletes the service and its associated resources.\n   *\n   * @return {Promise<()>} An empty Promise that will be fulfilled when the service is deleted.\n   */\n\n\n  AuthInternals.prototype.delete = function () {\n    // There are no resources to clean up\n    return Promise.resolve(undefined);\n  };\n\n  return AuthInternals;\n}();\n/**\n * Base Auth class. Mainly used for user management APIs.\n */\n\n\nvar BaseAuth =\n/** @class */\nfunction () {\n  /**\n   * The BaseAuth class constructor.\n   *\n   * @param {string} projectId The corresponding project ID.\n   * @param {FirebaseAuthRequestHandler} authRequestHandler The RPC request handler\n   *     for this instance.\n   * @param {CryptoSigner} cryptoSigner The instance crypto signer used for custom token\n   *     minting.\n   * @constructor\n   */\n  function BaseAuth(projectId, authRequestHandler, cryptoSigner) {\n    this.projectId = projectId;\n    this.authRequestHandler = authRequestHandler;\n    this.tokenGenerator = new token_generator_1.FirebaseTokenGenerator(cryptoSigner);\n    this.sessionCookieVerifier = token_verifier_1.createSessionCookieVerifier(projectId);\n    this.idTokenVerifier = token_verifier_1.createIdTokenVerifier(projectId);\n  }\n  /**\n   * Creates a new custom token that can be sent back to a client to use with\n   * signInWithCustomToken().\n   *\n   * @param {string} uid The uid to use as the JWT subject.\n   * @param {object=} developerClaims Optional additional claims to include in the JWT payload.\n   *\n   * @return {Promise<string>} A JWT for the provided payload.\n   */\n\n\n  BaseAuth.prototype.createCustomToken = function (uid, developerClaims) {\n    return this.tokenGenerator.createCustomToken(uid, developerClaims);\n  };\n  /**\n   * Verifies a JWT auth token. Returns a Promise with the tokens claims. Rejects\n   * the promise if the token could not be verified. If checkRevoked is set to true,\n   * verifies if the session corresponding to the ID token was revoked. If the corresponding\n   * user's session was invalidated, an auth/id-token-revoked error is thrown. If not specified\n   * the check is not applied.\n   *\n   * @param {string} idToken The JWT to verify.\n   * @param {boolean=} checkRevoked Whether to check if the ID token is revoked.\n   * @return {Promise<DecodedIdToken>} A Promise that will be fulfilled after a successful\n   *     verification.\n   */\n\n\n  BaseAuth.prototype.verifyIdToken = function (idToken, checkRevoked) {\n    var _this = this;\n\n    if (checkRevoked === void 0) {\n      checkRevoked = false;\n    }\n\n    return this.idTokenVerifier.verifyJWT(idToken).then(function (decodedIdToken) {\n      // Whether to check if the token was revoked.\n      if (!checkRevoked) {\n        return decodedIdToken;\n      }\n\n      return _this.verifyDecodedJWTNotRevoked(decodedIdToken, error_1.AuthClientErrorCode.ID_TOKEN_REVOKED);\n    });\n  };\n  /**\n   * Looks up the user identified by the provided user id and returns a promise that is\n   * fulfilled with a user record for the given user if that user is found.\n   *\n   * @param {string} uid The uid of the user to look up.\n   * @return {Promise<UserRecord>} A promise that resolves with the corresponding user record.\n   */\n\n\n  BaseAuth.prototype.getUser = function (uid) {\n    return this.authRequestHandler.getAccountInfoByUid(uid).then(function (response) {\n      // Returns the user record populated with server response.\n      return new user_record_1.UserRecord(response.users[0]);\n    });\n  };\n  /**\n   * Looks up the user identified by the provided email and returns a promise that is\n   * fulfilled with a user record for the given user if that user is found.\n   *\n   * @param {string} email The email of the user to look up.\n   * @return {Promise<UserRecord>} A promise that resolves with the corresponding user record.\n   */\n\n\n  BaseAuth.prototype.getUserByEmail = function (email) {\n    return this.authRequestHandler.getAccountInfoByEmail(email).then(function (response) {\n      // Returns the user record populated with server response.\n      return new user_record_1.UserRecord(response.users[0]);\n    });\n  };\n  /**\n   * Looks up the user identified by the provided phone number and returns a promise that is\n   * fulfilled with a user record for the given user if that user is found.\n   *\n   * @param {string} phoneNumber The phone number of the user to look up.\n   * @return {Promise<UserRecord>} A promise that resolves with the corresponding user record.\n   */\n\n\n  BaseAuth.prototype.getUserByPhoneNumber = function (phoneNumber) {\n    return this.authRequestHandler.getAccountInfoByPhoneNumber(phoneNumber).then(function (response) {\n      // Returns the user record populated with server response.\n      return new user_record_1.UserRecord(response.users[0]);\n    });\n  };\n  /**\n   * Exports a batch of user accounts. Batch size is determined by the maxResults argument.\n   * Starting point of the batch is determined by the pageToken argument.\n   *\n   * @param {number=} maxResults The page size, 1000 if undefined. This is also the maximum\n   *     allowed limit.\n   * @param {string=} pageToken The next page token. If not specified, returns users starting\n   *     without any offset.\n   * @return {Promise<{users: UserRecord[], pageToken?: string}>} A promise that resolves with\n   *     the current batch of downloaded users and the next page token. For the last page, an\n   *     empty list of users and no page token are returned.\n   */\n\n\n  BaseAuth.prototype.listUsers = function (maxResults, pageToken) {\n    return this.authRequestHandler.downloadAccount(maxResults, pageToken).then(function (response) {\n      // List of users to return.\n      var users = []; // Convert each user response to a UserRecord.\n\n      response.users.forEach(function (userResponse) {\n        users.push(new user_record_1.UserRecord(userResponse));\n      }); // Return list of user records and the next page token if available.\n\n      var result = {\n        users: users,\n        pageToken: response.nextPageToken\n      }; // Delete result.pageToken if undefined.\n\n      if (typeof result.pageToken === 'undefined') {\n        delete result.pageToken;\n      }\n\n      return result;\n    });\n  };\n  /**\n   * Creates a new user with the properties provided.\n   *\n   * @param {CreateRequest} properties The properties to set on the new user record to be created.\n   * @return {Promise<UserRecord>} A promise that resolves with the newly created user record.\n   */\n\n\n  BaseAuth.prototype.createUser = function (properties) {\n    var _this = this;\n\n    return this.authRequestHandler.createNewAccount(properties).then(function (uid) {\n      // Return the corresponding user record.\n      return _this.getUser(uid);\n    }).catch(function (error) {\n      if (error.code === 'auth/user-not-found') {\n        // Something must have happened after creating the user and then retrieving it.\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'Unable to create the user record provided.');\n      }\n\n      throw error;\n    });\n  };\n  /**\n   * Deletes the user identified by the provided user id and returns a promise that is\n   * fulfilled when the user is found and successfully deleted.\n   *\n   * @param {string} uid The uid of the user to delete.\n   * @return {Promise<void>} A promise that resolves when the user is successfully deleted.\n   */\n\n\n  BaseAuth.prototype.deleteUser = function (uid) {\n    return this.authRequestHandler.deleteAccount(uid).then(function (response) {// Return nothing on success.\n    });\n  };\n  /**\n   * Updates an existing user with the properties provided.\n   *\n   * @param {string} uid The uid identifier of the user to update.\n   * @param {UpdateRequest} properties The properties to update on the existing user.\n   * @return {Promise<UserRecord>} A promise that resolves with the modified user record.\n   */\n\n\n  BaseAuth.prototype.updateUser = function (uid, properties) {\n    var _this = this;\n\n    return this.authRequestHandler.updateExistingAccount(uid, properties).then(function (existingUid) {\n      // Return the corresponding user record.\n      return _this.getUser(existingUid);\n    });\n  };\n  /**\n   * Sets additional developer claims on an existing user identified by the provided UID.\n   *\n   * @param {string} uid The user to edit.\n   * @param {object} customUserClaims The developer claims to set.\n   * @return {Promise<void>} A promise that resolves when the operation completes\n   *     successfully.\n   */\n\n\n  BaseAuth.prototype.setCustomUserClaims = function (uid, customUserClaims) {\n    return this.authRequestHandler.setCustomUserClaims(uid, customUserClaims).then(function (existingUid) {// Return nothing on success.\n    });\n  };\n  /**\n   * Revokes all refresh tokens for the specified user identified by the provided UID.\n   * In addition to revoking all refresh tokens for a user, all ID tokens issued before\n   * revocation will also be revoked on the Auth backend. Any request with an ID token\n   * generated before revocation will be rejected with a token expired error.\n   *\n   * @param {string} uid The user whose tokens are to be revoked.\n   * @return {Promise<void>} A promise that resolves when the operation completes\n   *     successfully.\n   */\n\n\n  BaseAuth.prototype.revokeRefreshTokens = function (uid) {\n    return this.authRequestHandler.revokeRefreshTokens(uid).then(function (existingUid) {// Return nothing on success.\n    });\n  };\n  /**\n   * Imports the list of users provided to Firebase Auth. This is useful when\n   * migrating from an external authentication system without having to use the Firebase CLI SDK.\n   * At most, 1000 users are allowed to be imported one at a time.\n   * When importing a list of password users, UserImportOptions are required to be specified.\n   *\n   * @param {UserImportRecord[]} users The list of user records to import to Firebase Auth.\n   * @param {UserImportOptions=} options The user import options, required when the users provided\n   *     include password credentials.\n   * @return {Promise<UserImportResult>} A promise that resolves when the operation completes\n   *     with the result of the import. This includes the number of successful imports, the number\n   *     of failed uploads and their corresponding errors.\n   */\n\n\n  BaseAuth.prototype.importUsers = function (users, options) {\n    return this.authRequestHandler.uploadAccount(users, options);\n  };\n  /**\n   * Creates a new Firebase session cookie with the specified options that can be used for\n   * session management (set as a server side session cookie with custom cookie policy).\n   * The session cookie JWT will have the same payload claims as the provided ID token.\n   *\n   * @param {string} idToken The Firebase ID token to exchange for a session cookie.\n   * @param {SessionCookieOptions} sessionCookieOptions The session cookie options which includes\n   *     custom session duration.\n   *\n   * @return {Promise<string>} A promise that resolves on success with the created session cookie.\n   */\n\n\n  BaseAuth.prototype.createSessionCookie = function (idToken, sessionCookieOptions) {\n    // Return rejected promise if expiresIn is not available.\n    if (!validator.isNonNullObject(sessionCookieOptions) || !validator.isNumber(sessionCookieOptions.expiresIn)) {\n      return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_SESSION_COOKIE_DURATION));\n    }\n\n    return this.authRequestHandler.createSessionCookie(idToken, sessionCookieOptions.expiresIn);\n  };\n  /**\n   * Verifies a Firebase session cookie. Returns a Promise with the tokens claims. Rejects\n   * the promise if the token could not be verified. If checkRevoked is set to true,\n   * verifies if the session corresponding to the session cookie was revoked. If the corresponding\n   * user's session was invalidated, an auth/session-cookie-revoked error is thrown. If not\n   * specified the check is not performed.\n   *\n   * @param {string} sessionCookie The session cookie to verify.\n   * @param {boolean=} checkRevoked Whether to check if the session cookie is revoked.\n   * @return {Promise<DecodedIdToken>} A Promise that will be fulfilled after a successful\n   *     verification.\n   */\n\n\n  BaseAuth.prototype.verifySessionCookie = function (sessionCookie, checkRevoked) {\n    var _this = this;\n\n    if (checkRevoked === void 0) {\n      checkRevoked = false;\n    }\n\n    return this.sessionCookieVerifier.verifyJWT(sessionCookie).then(function (decodedIdToken) {\n      // Whether to check if the token was revoked.\n      if (!checkRevoked) {\n        return decodedIdToken;\n      }\n\n      return _this.verifyDecodedJWTNotRevoked(decodedIdToken, error_1.AuthClientErrorCode.SESSION_COOKIE_REVOKED);\n    });\n  };\n  /**\n   * Generates the out of band email action link for password reset flows for the\n   * email specified using the action code settings provided.\n   * Returns a promise that resolves with the generated link.\n   *\n   * @param {string} email The email of the user whose password is to be reset.\n   * @param {ActionCodeSettings=} actionCodeSettings The optional action code setings which defines whether\n   *     the link is to be handled by a mobile app and the additional state information to be passed in the\n   *     deep link, etc.\n   * @return {Promise<string>} A promise that resolves with the password reset link.\n   */\n\n\n  BaseAuth.prototype.generatePasswordResetLink = function (email, actionCodeSettings) {\n    return this.authRequestHandler.getEmailActionLink('PASSWORD_RESET', email, actionCodeSettings);\n  };\n  /**\n   * Generates the out of band email action link for email verification flows for the\n   * email specified using the action code settings provided.\n   * Returns a promise that resolves with the generated link.\n   *\n   * @param {string} email The email of the user to be verified.\n   * @param {ActionCodeSettings=} actionCodeSettings The optional action code setings which defines whether\n   *     the link is to be handled by a mobile app and the additional state information to be passed in the\n   *     deep link, etc.\n   * @return {Promise<string>} A promise that resolves with the email verification link.\n   */\n\n\n  BaseAuth.prototype.generateEmailVerificationLink = function (email, actionCodeSettings) {\n    return this.authRequestHandler.getEmailActionLink('VERIFY_EMAIL', email, actionCodeSettings);\n  };\n  /**\n   * Generates the out of band email action link for email link sign-in flows for the\n   * email specified using the action code settings provided.\n   * Returns a promise that resolves with the generated link.\n   *\n   * @param {string} email The email of the user signing in.\n   * @param {ActionCodeSettings} actionCodeSettings The required action code setings which defines whether\n   *     the link is to be handled by a mobile app and the additional state information to be passed in the\n   *     deep link, etc.\n   * @return {Promise<string>} A promise that resolves with the email sign-in link.\n   */\n\n\n  BaseAuth.prototype.generateSignInWithEmailLink = function (email, actionCodeSettings) {\n    return this.authRequestHandler.getEmailActionLink('EMAIL_SIGNIN', email, actionCodeSettings);\n  };\n  /**\n   * Verifies the decoded Firebase issued JWT is not revoked. Returns a promise that resolves\n   * with the decoded claims on success. Rejects the promise with revocation error if revoked.\n   *\n   * @param {DecodedIdToken} decodedIdToken The JWT's decoded claims.\n   * @param {ErrorInfo} revocationErrorInfo The revocation error info to throw on revocation\n   *     detection.\n   * @return {Promise<DecodedIdToken>} A Promise that will be fulfilled after a successful\n   *     verification.\n   */\n\n\n  BaseAuth.prototype.verifyDecodedJWTNotRevoked = function (decodedIdToken, revocationErrorInfo) {\n    // Get tokens valid after time for the corresponding user.\n    return this.getUser(decodedIdToken.sub).then(function (user) {\n      // If no tokens valid after time available, token is not revoked.\n      if (user.tokensValidAfterTime) {\n        // Get the ID token authentication time and convert to milliseconds UTC.\n        var authTimeUtc = decodedIdToken.auth_time * 1000; // Get user tokens valid after time in milliseconds UTC.\n\n        var validSinceUtc = new Date(user.tokensValidAfterTime).getTime(); // Check if authentication time is older than valid since time.\n\n        if (authTimeUtc < validSinceUtc) {\n          throw new error_1.FirebaseAuthError(revocationErrorInfo);\n        }\n      } // All checks above passed. Return the decoded token.\n\n\n      return decodedIdToken;\n    });\n  };\n\n  return BaseAuth;\n}();\n/**\n * Auth service bound to the provided app.\n */\n\n\nvar Auth =\n/** @class */\nfunction (_super) {\n  __extends(Auth, _super);\n  /**\n   * @param {object} app The app for this Auth service.\n   * @constructor\n   */\n\n\n  function Auth(app) {\n    var _this = _super.call(this, Auth.getProjectId(app), new auth_api_request_1.FirebaseAuthRequestHandler(app), token_generator_1.cryptoSignerFromApp(app)) || this;\n\n    _this.INTERNAL = new AuthInternals();\n    _this.app_ = app;\n    return _this;\n  }\n  /**\n   * Returns the FirebaseApp's project ID.\n   *\n   * @param {FirebaseApp} app The project ID for an app.\n   * @return {string} The FirebaseApp's project ID.\n   */\n\n\n  Auth.getProjectId = function (app) {\n    if (typeof app !== 'object' || app === null || !('options' in app)) {\n      throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, 'First argument passed to admin.auth() must be a valid Firebase app instance.');\n    }\n\n    return utils.getProjectId(app);\n  };\n\n  Object.defineProperty(Auth.prototype, \"app\", {\n    /**\n     * Returns the app associated with this Auth instance.\n     *\n     * @return {FirebaseApp} The app associated with this Auth instance.\n     */\n    get: function get() {\n      return this.app_;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  return Auth;\n}(BaseAuth);\n\nexports.Auth = Auth;","map":null,"metadata":{},"sourceType":"script"}