{"ast":null,"code":"'use strict';\n\nexports.__esModule = true;\n\nvar _getIterator2 = require('babel-runtime/core-js/get-iterator');\n\nvar _getIterator3 = _interopRequireDefault(_getIterator2);\n\nvar _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');\n\nvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\nvar _lodash = require('lodash.clone');\n\nvar _lodash2 = _interopRequireDefault(_lodash);\n\nvar _lodash3 = require('lodash.merge');\n\nvar _lodash4 = _interopRequireDefault(_lodash3);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nvar KASHIDA_PRIORITY = 0;\nvar WHITESPACE_PRIORITY = 1;\nvar LETTER_PRIORITY = 2;\nvar NULL_PRIORITY = 3;\nvar EXPAND_WHITESPACE_FACTOR = {\n  before: 0.5,\n  after: 0.5,\n  priority: WHITESPACE_PRIORITY,\n  unconstrained: false\n};\nvar EXPAND_CHAR_FACTOR = {\n  before: 0.14453125,\n  // 37/256\n  after: 0.14453125,\n  priority: LETTER_PRIORITY,\n  unconstrained: false\n};\nvar SHRINK_WHITESPACE_FACTOR = {\n  before: -0.04296875,\n  // -11/256\n  after: -0.04296875,\n  priority: WHITESPACE_PRIORITY,\n  unconstrained: false\n};\nvar SHRINK_CHAR_FACTOR = {\n  before: -0.04296875,\n  after: -0.04296875,\n  priority: LETTER_PRIORITY,\n  unconstrained: false\n};\n/**\n * A JustificationEngine is used by a Typesetter to perform line fragment\n * justification. This implementation is based on a description of Apple's\n * justification algorithm from a PDF in the Apple Font Tools package.\n */\n\nexports.default = function () {\n  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n      _ref$expandCharFactor = _ref.expandCharFactor,\n      expandCharFactor = _ref$expandCharFactor === undefined ? {} : _ref$expandCharFactor,\n      _ref$expandWhitespace = _ref.expandWhitespaceFactor,\n      expandWhitespaceFactor = _ref$expandWhitespace === undefined ? {} : _ref$expandWhitespace,\n      _ref$shrinkCharFactor = _ref.shrinkCharFactor,\n      shrinkCharFactor = _ref$shrinkCharFactor === undefined ? {} : _ref$shrinkCharFactor,\n      _ref$shrinkWhitespace = _ref.shrinkWhitespaceFactor,\n      shrinkWhitespaceFactor = _ref$shrinkWhitespace === undefined ? {} : _ref$shrinkWhitespace;\n\n  return function () {\n    return function () {\n      function JustificationEngine() {\n        (0, _classCallCheck3.default)(this, JustificationEngine);\n        this.expandCharFactor = (0, _lodash4.default)(EXPAND_CHAR_FACTOR, expandCharFactor);\n        this.expandWhitespaceFactor = (0, _lodash4.default)(EXPAND_WHITESPACE_FACTOR, expandWhitespaceFactor);\n        this.shrinkCharFactor = (0, _lodash4.default)(SHRINK_CHAR_FACTOR, shrinkCharFactor);\n        this.shrinkWhitespaceFactor = (0, _lodash4.default)(SHRINK_WHITESPACE_FACTOR, shrinkWhitespaceFactor);\n      }\n\n      JustificationEngine.prototype.justify = function justify(line) {\n        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        var factor = options.factor || 1;\n\n        if (factor < 0 || factor > 1) {\n          throw new Error('Invalid justification factor: ' + factor);\n        }\n\n        var gap = line.rect.width - line.advanceWidth;\n\n        if (gap === 0) {\n          return;\n        }\n\n        var factors = [];\n        var start = 0;\n\n        for (var _iterator = line.glyphRuns, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : (0, _getIterator3.default)(_iterator);;) {\n          var _ref2;\n\n          if (_isArray) {\n            if (_i >= _iterator.length) break;\n            _ref2 = _iterator[_i++];\n          } else {\n            _i = _iterator.next();\n            if (_i.done) break;\n            _ref2 = _i.value;\n          }\n\n          var run = _ref2;\n          factors.push.apply(factors, this.factor(line, start, run.glyphs, gap > 0 ? 'GROW' : 'SHRINK'));\n          start += run.glyphs.length;\n        }\n\n        factors[0].before = 0;\n        factors[factors.length - 1].after = 0;\n        var distances = this.assign(gap, factors);\n        var index = 0;\n\n        for (var _iterator2 = line.glyphRuns, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : (0, _getIterator3.default)(_iterator2);;) {\n          var _ref3;\n\n          if (_isArray2) {\n            if (_i2 >= _iterator2.length) break;\n            _ref3 = _iterator2[_i2++];\n          } else {\n            _i2 = _iterator2.next();\n            if (_i2.done) break;\n            _ref3 = _i2.value;\n          }\n\n          var _run = _ref3;\n\n          for (var _iterator3 = _run.positions, _isArray3 = Array.isArray(_iterator3), _i3 = 0, _iterator3 = _isArray3 ? _iterator3 : (0, _getIterator3.default)(_iterator3);;) {\n            var _ref4;\n\n            if (_isArray3) {\n              if (_i3 >= _iterator3.length) break;\n              _ref4 = _iterator3[_i3++];\n            } else {\n              _i3 = _iterator3.next();\n              if (_i3.done) break;\n              _ref4 = _i3.value;\n            }\n\n            var position = _ref4;\n            position.xAdvance += distances[index++];\n          }\n        }\n      };\n\n      JustificationEngine.prototype.factor = function factor(line, start, glyphs, direction) {\n        var charFactor = void 0;\n        var whitespaceFactor = void 0;\n\n        if (direction === 'GROW') {\n          charFactor = (0, _lodash2.default)(this.expandCharFactor);\n          whitespaceFactor = (0, _lodash2.default)(this.expandWhitespaceFactor);\n        } else {\n          charFactor = (0, _lodash2.default)(this.shrinkCharFactor);\n          whitespaceFactor = (0, _lodash2.default)(this.shrinkWhitespaceFactor);\n        }\n\n        var factors = [];\n\n        for (var index = 0; index < glyphs.length; index++) {\n          var factor = void 0;\n          var glyph = glyphs[index];\n\n          if (line.isWhiteSpace(start + index)) {\n            factor = (0, _lodash2.default)(whitespaceFactor);\n\n            if (index === glyphs.length - 1) {\n              factor.before = 0;\n\n              if (index > 0) {\n                factors[index - 1].after = 0;\n              }\n            }\n          } else if (glyph.isMark && index > 0) {\n            factor = (0, _lodash2.default)(factors[index - 1]);\n            factor.before = 0;\n            factors[index - 1].after = 0;\n          } else {\n            factor = (0, _lodash2.default)(charFactor);\n          }\n\n          factors.push(factor);\n        }\n\n        return factors;\n      };\n\n      JustificationEngine.prototype.assign = function assign(gap, factors) {\n        var total = 0;\n        var priorities = [];\n        var unconstrained = [];\n\n        for (var _priority = KASHIDA_PRIORITY; _priority <= NULL_PRIORITY; _priority++) {\n          priorities[_priority] = unconstrained[_priority] = 0;\n        } // sum the factors at each priority\n\n\n        for (var j = 0; j < factors.length; j++) {\n          var factor = factors[j];\n          var sum = factor.before + factor.after;\n          total += sum;\n          priorities[factor.priority] += sum;\n\n          if (factor.unconstrained) {\n            unconstrained[factor.priority] += sum;\n          }\n        } // choose the priorities that need to be applied\n\n\n        var highestPriority = -1;\n        var highestPrioritySum = 0;\n        var remainingGap = gap;\n        var priority = void 0;\n\n        for (priority = KASHIDA_PRIORITY; priority <= NULL_PRIORITY; priority++) {\n          var prioritySum = priorities[priority];\n\n          if (prioritySum !== 0) {\n            if (highestPriority === -1) {\n              highestPriority = priority;\n              highestPrioritySum = prioritySum;\n            } // if this priority covers the remaining gap, we're done\n\n\n            if (Math.abs(remainingGap) <= Math.abs(prioritySum)) {\n              priorities[priority] = remainingGap / prioritySum;\n              unconstrained[priority] = 0;\n              remainingGap = 0;\n              break;\n            } // mark that we need to use 100% of the adjustment from\n            // this priority, and subtract the space that it consumes\n\n\n            priorities[priority] = 1;\n            remainingGap -= prioritySum; // if this priority has unconstrained glyphs, let them consume the remaining space\n\n            if (unconstrained[priority] !== 0) {\n              unconstrained[priority] = remainingGap / unconstrained[priority];\n              remainingGap = 0;\n              break;\n            }\n          }\n        } // zero out remaining priorities (if any)\n\n\n        for (var p = priority + 1; p <= NULL_PRIORITY; p++) {\n          priorities[p] = 0;\n          unconstrained[p] = 0;\n        } // if there is still space left over, assign it to the highest priority that we saw.\n        // this violates their factors, but it only happens in extreme cases\n\n\n        if (remainingGap > 0 && highestPriority > -1) {\n          priorities[highestPriority] = (highestPrioritySum + (gap - total)) / highestPrioritySum;\n        } // create and return an array of distances to add to each glyph's advance\n\n\n        var distances = [];\n\n        for (var index = 0; index < factors.length; index++) {\n          // the distance to add to this glyph is the sum of the space to add\n          // after this glyph, and the space to add before the next glyph\n          var _factor = factors[index];\n          var next = factors[index + 1];\n          var dist = _factor.after * priorities[_factor.priority];\n\n          if (next) {\n            dist += next.before * priorities[next.priority];\n          } // if this glyph is unconstrained, add the unconstrained distance as well\n\n\n          if (_factor.unconstrained) {\n            dist += _factor.after * unconstrained[_factor.priority];\n\n            if (next) {\n              dist += next.before * unconstrained[next.priority];\n            }\n          }\n\n          distances.push(dist);\n        }\n\n        return distances;\n      };\n\n      JustificationEngine.prototype.postprocess = function postprocess() {\n        // do nothing by default\n        return false;\n      };\n\n      return JustificationEngine;\n    }();\n  };\n};","map":null,"metadata":{},"sourceType":"script"}