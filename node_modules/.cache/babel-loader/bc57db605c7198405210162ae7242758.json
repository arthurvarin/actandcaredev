{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar ConfigStore = require(\"configstore\");\n\nvar crypto = require(\"crypto\");\n\nvar r = require(\"request\");\n\nvar stream_1 = require(\"stream\");\n\nvar util = require(\"util\");\n\nvar streamEvents = require('stream-events');\n\nvar googleAuth = require('google-auto-auth');\n\nvar pumpify = require('pumpify');\n\nvar request = r.defaults({\n  json: true,\n  pool: {\n    maxSockets: Infinity\n  }\n});\nvar BASE_URI = 'https://www.googleapis.com/upload/storage/v1/b';\nvar TERMINATED_UPLOAD_STATUS_CODE = 410;\nvar RESUMABLE_INCOMPLETE_STATUS_CODE = 308;\nvar RETRY_LIMIT = 5;\n\nvar wrapError = function wrapError(message, err) {\n  return new Error([message, err.message].join('\\n'));\n};\n\nfunction Upload(cfg) {\n  var _this = this;\n\n  pumpify.call(this);\n  streamEvents.call(this);\n  cfg = cfg || {};\n\n  if (!cfg.bucket || !cfg.file) {\n    throw new Error('A bucket and file name are required');\n  }\n\n  cfg.authConfig = cfg.authConfig || {};\n  cfg.authConfig.scopes = ['https://www.googleapis.com/auth/devstorage.full_control'];\n  this.authClient = cfg.authClient || googleAuth(cfg.authConfig);\n  this.bucket = cfg.bucket;\n  this.file = cfg.file;\n  this.generation = cfg.generation;\n  this.kmsKeyName = cfg.kmsKeyName;\n  this.metadata = cfg.metadata || {};\n  this.offset = cfg.offset;\n  this.origin = cfg.origin;\n  this.userProject = cfg.userProject;\n\n  if (cfg.key) {\n    /**\r\n     * NOTE: This is `as string` because there appears to be some weird kind\r\n     * of TypeScript bug as 2.8. Tracking the issue here:\r\n     * https://github.com/Microsoft/TypeScript/issues/23155\r\n     */\n    var base64Key = Buffer.from(cfg.key).toString('base64');\n    this.encryption = {\n      key: base64Key,\n      hash: crypto.createHash('sha256').update(cfg.key).digest('base64')\n    };\n  }\n\n  this.predefinedAcl = cfg.predefinedAcl;\n  if (cfg.private) this.predefinedAcl = 'private';\n  if (cfg.public) this.predefinedAcl = 'publicRead';\n  this.configStore = new ConfigStore('gcs-resumable-upload');\n  this.uriProvidedManually = !!cfg.uri;\n  this.uri = cfg.uri || this.get('uri');\n  this.numBytesWritten = 0;\n  this.numRetries = 0;\n  var contentLength = cfg.metadata ? Number(cfg.metadata.contentLength) : NaN;\n  this.contentLength = isNaN(contentLength) ? '*' : contentLength;\n  this.once('writing', function () {\n    if (_this.uri) {\n      _this.continueUploading();\n    } else {\n      _this.createURI(function (err) {\n        if (err) {\n          return _this.destroy(err);\n        }\n\n        _this.startUploading();\n      });\n    }\n  });\n}\n\nutil.inherits(Upload, pumpify);\n\nUpload.prototype.createURI = function (callback) {\n  var _this = this;\n\n  var metadata = this.metadata;\n  var reqOpts = {\n    method: 'POST',\n    uri: [BASE_URI, this.bucket, 'o'].join('/'),\n    qs: {\n      name: this.file,\n      uploadType: 'resumable'\n    },\n    json: metadata,\n    headers: {}\n  };\n\n  if (metadata.contentLength) {\n    reqOpts.headers['X-Upload-Content-Length'] = metadata.contentLength;\n  }\n\n  if (metadata.contentType) {\n    reqOpts.headers['X-Upload-Content-Type'] = metadata.contentType;\n  }\n\n  if (typeof this.generation !== 'undefined') {\n    reqOpts.qs.ifGenerationMatch = this.generation;\n  }\n\n  if (this.kmsKeyName) {\n    reqOpts.qs.kmsKeyName = this.kmsKeyName;\n  }\n\n  if (this.predefinedAcl) {\n    reqOpts.qs.predefinedAcl = this.predefinedAcl;\n  }\n\n  if (this.origin) {\n    reqOpts.headers.Origin = this.origin;\n  }\n\n  this.makeRequest(reqOpts, function (err, resp) {\n    if (err) {\n      return callback(err);\n    }\n\n    var uri = resp.headers.location;\n    _this.uri = uri;\n\n    _this.set({\n      uri: uri\n    });\n\n    _this.offset = 0;\n    callback(null, uri);\n  });\n};\n\nUpload.prototype.continueUploading = function () {\n  if (typeof this.offset === 'number') {\n    return this.startUploading();\n  }\n\n  this.getAndSetOffset(this.startUploading.bind(this));\n};\n\nUpload.prototype.startUploading = function () {\n  var _this = this;\n\n  var reqOpts = {\n    method: 'PUT',\n    uri: this.uri,\n    headers: {\n      'Content-Range': 'bytes ' + this.offset + '-*/' + this.contentLength\n    }\n  };\n  var bufferStream = this.bufferStream = new stream_1.PassThrough();\n  var offsetStream = this.offsetStream = new stream_1.PassThrough({\n    transform: this.onChunk.bind(this)\n  });\n  var delayStream = new stream_1.PassThrough();\n  this.getRequestStream(reqOpts, function (requestStream) {\n    _this.setPipeline(bufferStream, offsetStream, requestStream, delayStream); // wait for \"complete\" from request before letting the stream finish\n\n\n    delayStream.on('prefinish', function () {\n      _this.cork();\n    });\n    requestStream.on('complete', function (resp) {\n      if (resp.statusCode < 200 || resp.statusCode > 299) {\n        _this.destroy(new Error('Upload failed'));\n\n        return;\n      }\n\n      _this.emit('metadata', resp.body);\n\n      _this.deleteConfig();\n\n      _this.uncork();\n    });\n  });\n};\n\nUpload.prototype.onChunk = function (chunk, enc, next) {\n  var offset = this.offset;\n  var numBytesWritten = this.numBytesWritten; // check if this is the same content uploaded previously. this caches a slice\n  // of the first chunk, then compares it with the first byte of incoming data\n\n  if (numBytesWritten === 0) {\n    var cachedFirstChunk = this.get('firstChunk');\n    var firstChunk = chunk.slice(0, 16).valueOf();\n\n    if (!cachedFirstChunk) {\n      // This is a new upload. Cache the first chunk.\n      this.set({\n        uri: this.uri,\n        firstChunk: firstChunk\n      });\n    } else {\n      // this continues an upload in progress. check if the bytes are the same\n      cachedFirstChunk = Buffer.from(cachedFirstChunk);\n      var nextChunk = Buffer.from(firstChunk);\n\n      if (Buffer.compare(cachedFirstChunk, nextChunk) !== 0) {\n        // this data is not the same. start a new upload\n        this.bufferStream.unshift(chunk);\n        this.bufferStream.unpipe(this.offsetStream);\n        this.restart();\n        return;\n      }\n    }\n  }\n\n  var length = chunk.length;\n  if (typeof chunk === 'string') length = Buffer.byteLength(chunk, enc);\n  if (numBytesWritten < offset) chunk = chunk.slice(offset - numBytesWritten);\n  this.numBytesWritten += length; // only push data from the byte after the one we left off on\n\n  next(null, this.numBytesWritten > offset ? chunk : undefined);\n};\n\nUpload.prototype.getAndSetOffset = function (callback) {\n  var _this = this;\n\n  this.makeRequest({\n    method: 'PUT',\n    uri: this.uri,\n    headers: {\n      'Content-Length': 0,\n      'Content-Range': 'bytes */*'\n    }\n  }, function (err, resp) {\n    if (err) {\n      // we don't return a 404 to the user if they provided the resumable\n      // URI. if we're just using the configstore file to tell us that this\n      // file exists, and it turns out that it doesn't (the 404), that's\n      // probably stale config data.\n      if (resp && resp.statusCode === 404 && !_this.uriProvidedManually) {\n        return _this.restart();\n      } // this resumable upload is unrecoverable (bad data or service error).\n      //  -\n      //  https://github.com/stephenplusplus/gcs-resumable-upload/issues/15\n      //  -\n      //  https://github.com/stephenplusplus/gcs-resumable-upload/pull/16#discussion_r80363774\n\n\n      if (resp && resp.statusCode === TERMINATED_UPLOAD_STATUS_CODE) {\n        return _this.restart();\n      }\n\n      return _this.destroy(err);\n    }\n\n    if (resp.statusCode === RESUMABLE_INCOMPLETE_STATUS_CODE) {\n      if (resp.headers.range) {\n        var range = resp.headers.range;\n        _this.offset = Number(range.split('-')[1]) + 1;\n        callback();\n        return;\n      }\n    }\n\n    _this.offset = 0;\n    callback();\n  });\n};\n\nUpload.prototype.makeRequest = function (reqOpts, callback) {\n  if (this.encryption) {\n    reqOpts.headers = reqOpts.headers || {};\n    reqOpts.headers['x-goog-encryption-algorithm'] = 'AES256';\n    reqOpts.headers['x-goog-encryption-key'] = this.encryption.key;\n    reqOpts.headers['x-goog-encryption-key-sha256'] = this.encryption.hash;\n  }\n\n  if (this.userProject) {\n    reqOpts.qs = reqOpts.qs || {};\n    reqOpts.qs.userProject = this.userProject;\n  }\n\n  this.authClient.authorizeRequest(reqOpts, function (err, authorizedReqOpts) {\n    if (err) {\n      err = wrapError('Could not authenticate request', err);\n      return callback(err, null, null);\n    }\n\n    request(authorizedReqOpts, function (err, resp, body) {\n      if (err) {\n        return callback(err, resp, body);\n      }\n\n      if (body && body.error) {\n        return callback(body.error, resp, body);\n      }\n\n      var nonSuccess = Math.floor(resp.statusCode / 100) !== 2; // 200-299 status code\n\n      if (nonSuccess && resp.statusCode !== RESUMABLE_INCOMPLETE_STATUS_CODE) {\n        return callback(new Error(body), resp, body);\n      }\n\n      callback(null, resp, body);\n    });\n  });\n};\n\nUpload.prototype.getRequestStream = function (reqOpts, callback) {\n  var _this = this;\n\n  if (this.userProject) {\n    reqOpts.qs = reqOpts.qs || {};\n    reqOpts.qs.userProject = this.userProject;\n  }\n\n  this.authClient.authorizeRequest(reqOpts, function (err, authorizedReqOpts) {\n    if (err) {\n      return _this.destroy(wrapError('Could not authenticate request', err));\n    }\n\n    var requestStream = request(authorizedReqOpts);\n    requestStream.on('error', _this.destroy.bind(_this));\n    requestStream.on('response', _this.onResponse.bind(_this));\n    requestStream.on('complete', function (resp) {\n      var body = resp.body;\n      if (body && body.error) _this.destroy(body.error);\n    }); // this makes the response body come back in the response (weird?)\n\n    requestStream.callback = function () {};\n\n    callback(requestStream);\n  });\n};\n\nUpload.prototype.restart = function () {\n  var _this = this;\n\n  this.numBytesWritten = 0;\n  this.deleteConfig();\n  this.createURI(function (err) {\n    if (err) {\n      return _this.destroy(err);\n    }\n\n    _this.startUploading();\n  });\n};\n\nUpload.prototype.get = function (prop) {\n  var store = this.configStore.get([this.bucket, this.file].join('/'));\n  return store && store[prop];\n}; // tslint:disable-next-line no-any\n\n\nUpload.prototype.set = function (props) {\n  this.configStore.set([this.bucket, this.file].join('/'), props);\n};\n\nUpload.prototype.deleteConfig = function () {\n  this.configStore.delete([this.bucket, this.file].join('/'));\n};\n/**\r\n * @return {bool} is the request good?\r\n */\n\n\nUpload.prototype.onResponse = function (resp) {\n  if (resp.statusCode === 404) {\n    if (this.numRetries < RETRY_LIMIT) {\n      this.numRetries++;\n      this.startUploading();\n    } else {\n      this.destroy(new Error('Retry limit exceeded'));\n    }\n\n    return false;\n  }\n\n  if (resp.statusCode > 499 && resp.statusCode < 600) {\n    if (this.numRetries < RETRY_LIMIT) {\n      var randomMs = Math.round(Math.random() * 1000);\n      var waitTime = Math.pow(2, this.numRetries) * 1000 + randomMs;\n      this.numRetries++;\n      setTimeout(this.continueUploading.bind(this), waitTime);\n    } else {\n      this.destroy(new Error('Retry limit exceeded'));\n    }\n\n    return false;\n  }\n\n  this.emit('response', resp);\n  return true;\n};\n\nfunction upload(cfg) {\n  // tslint:disable-next-line no-any\n  return new Upload(cfg);\n} // tslint:disable-next-line no-any\n\n\nupload.createURI = function (cfg, callback) {\n  // tslint:disable-next-line no-any\n  var up = new Upload(cfg);\n  up.createURI(callback);\n};\n\nmodule.exports = upload;","map":null,"metadata":{},"sourceType":"script"}