{"ast":null,"code":"\"use strict\";\n\nmodule.exports = decoder;\n\nvar Enum = require(\"./enum\"),\n    types = require(\"./types\"),\n    util = require(\"./util\");\n\nfunction missing(field) {\n  return \"missing required '\" + field.name + \"'\";\n}\n/**\r\n * Generates a decoder specific to the specified message type.\r\n * @param {Type} mtype Message type\r\n * @returns {Codegen} Codegen instance\r\n */\n\n\nfunction decoder(mtype) {\n  /* eslint-disable no-unexpected-multiline */\n  var gen = util.codegen([\"r\", \"l\"], mtype.name + \"$decode\")(\"if(!(r instanceof Reader))\")(\"r=Reader.create(r)\")(\"var c=l===undefined?r.len:r.pos+l,m=new this.ctor\" + (mtype.fieldsArray.filter(function (field) {\n    return field.map;\n  }).length ? \",k\" : \"\"))(\"while(r.pos<c){\")(\"var t=r.uint32()\");\n  if (mtype.group) gen(\"if((t&7)===4)\")(\"break\");\n  gen(\"switch(t>>>3){\");\n  var i = 0;\n\n  for (; i <\n  /* initializes */\n  mtype.fieldsArray.length; ++i) {\n    var field = mtype._fieldsArray[i].resolve(),\n        type = field.resolvedType instanceof Enum ? \"int32\" : field.type,\n        ref = \"m\" + util.safeProp(field.name);\n\n    gen(\"case %i:\", field.id); // Map fields\n\n    if (field.map) {\n      gen(\"r.skip().pos++\") // assumes id 1 + key wireType\n      (\"if(%s===util.emptyObject)\", ref)(\"%s={}\", ref)(\"k=r.%s()\", field.keyType)(\"r.pos++\"); // assumes id 2 + value wireType\n\n      if (types.long[field.keyType] !== undefined) {\n        if (types.basic[type] === undefined) gen(\"%s[typeof k===\\\"object\\\"?util.longToHash(k):k]=types[%i].decode(r,r.uint32())\", ref, i); // can't be groups\n        else gen(\"%s[typeof k===\\\"object\\\"?util.longToHash(k):k]=r.%s()\", ref, type);\n      } else {\n        if (types.basic[type] === undefined) gen(\"%s[k]=types[%i].decode(r,r.uint32())\", ref, i); // can't be groups\n        else gen(\"%s[k]=r.%s()\", ref, type);\n      } // Repeated fields\n\n    } else if (field.repeated) {\n      gen(\"if(!(%s&&%s.length))\", ref, ref)(\"%s=[]\", ref); // Packable (always check for forward and backward compatiblity)\n\n      if (types.packed[type] !== undefined) gen(\"if((t&7)===2){\")(\"var c2=r.uint32()+r.pos\")(\"while(r.pos<c2)\")(\"%s.push(r.%s())\", ref, type)(\"}else\"); // Non-packed\n\n      if (types.basic[type] === undefined) gen(field.resolvedType.group ? \"%s.push(types[%i].decode(r))\" : \"%s.push(types[%i].decode(r,r.uint32()))\", ref, i);else gen(\"%s.push(r.%s())\", ref, type); // Non-repeated\n    } else if (types.basic[type] === undefined) gen(field.resolvedType.group ? \"%s=types[%i].decode(r)\" : \"%s=types[%i].decode(r,r.uint32())\", ref, i);else gen(\"%s=r.%s()\", ref, type);\n\n    gen(\"break\"); // Unknown fields\n  }\n\n  gen(\"default:\")(\"r.skipType(t&7)\")(\"break\")(\"}\")(\"}\"); // Field presence\n\n  for (i = 0; i < mtype._fieldsArray.length; ++i) {\n    var rfield = mtype._fieldsArray[i];\n    if (rfield.required) gen(\"if(!m.hasOwnProperty(%j))\", rfield.name)(\"throw util.ProtocolError(%j,{instance:m})\", missing(rfield));\n  }\n\n  return gen(\"return m\");\n  /* eslint-enable no-unexpected-multiline */\n}","map":null,"metadata":{},"sourceType":"script"}