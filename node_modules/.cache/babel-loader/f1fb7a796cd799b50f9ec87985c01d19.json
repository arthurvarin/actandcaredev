{"ast":null,"code":"\"use strict\";\n\nvar _slicedToArray = require(\"/Users/cvoisin/Repos/actandcaredev/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nvar _classCallCheck = require(\"/Users/cvoisin/Repos/actandcaredev/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/cvoisin/Repos/actandcaredev/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _possibleConstructorReturn = require(\"/Users/cvoisin/Repos/actandcaredev/node_modules/@babel/runtime/helpers/possibleConstructorReturn\");\n\nvar _getPrototypeOf = require(\"/Users/cvoisin/Repos/actandcaredev/node_modules/@babel/runtime/helpers/getPrototypeOf\");\n\nvar _inherits = require(\"/Users/cvoisin/Repos/actandcaredev/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _assertThisInitialized = require(\"/Users/cvoisin/Repos/actandcaredev/node_modules/@babel/runtime/helpers/assertThisInitialized\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar events_1 = require(\"events\");\n\nvar http2 = require(\"http2\");\n\nvar tls_1 = require(\"tls\");\n\nvar url = require(\"url\");\n\nvar call_credentials_filter_1 = require(\"./call-credentials-filter\");\n\nvar call_stream_1 = require(\"./call-stream\");\n\nvar channel_options_1 = require(\"./channel-options\");\n\nvar compression_filter_1 = require(\"./compression-filter\");\n\nvar constants_1 = require(\"./constants\");\n\nvar deadline_filter_1 = require(\"./deadline-filter\");\n\nvar filter_stack_1 = require(\"./filter-stack\");\n\nvar metadata_status_filter_1 = require(\"./metadata-status-filter\");\n\nvar subchannel_1 = require(\"./subchannel\");\n\nvar _require = require('../../package.json'),\n    clientVersion = _require.version;\n\nvar MIN_CONNECT_TIMEOUT_MS = 20000;\nvar INITIAL_BACKOFF_MS = 1000;\nvar BACKOFF_MULTIPLIER = 1.6;\nvar MAX_BACKOFF_MS = 120000;\nvar BACKOFF_JITTER = 0.2;\nvar _http2$constants = http2.constants,\n    HTTP2_HEADER_AUTHORITY = _http2$constants.HTTP2_HEADER_AUTHORITY,\n    HTTP2_HEADER_CONTENT_TYPE = _http2$constants.HTTP2_HEADER_CONTENT_TYPE,\n    HTTP2_HEADER_METHOD = _http2$constants.HTTP2_HEADER_METHOD,\n    HTTP2_HEADER_PATH = _http2$constants.HTTP2_HEADER_PATH,\n    HTTP2_HEADER_TE = _http2$constants.HTTP2_HEADER_TE,\n    HTTP2_HEADER_USER_AGENT = _http2$constants.HTTP2_HEADER_USER_AGENT;\nvar ConnectivityState;\n\n(function (ConnectivityState) {\n  ConnectivityState[ConnectivityState[\"CONNECTING\"] = 0] = \"CONNECTING\";\n  ConnectivityState[ConnectivityState[\"READY\"] = 1] = \"READY\";\n  ConnectivityState[ConnectivityState[\"TRANSIENT_FAILURE\"] = 2] = \"TRANSIENT_FAILURE\";\n  ConnectivityState[ConnectivityState[\"IDLE\"] = 3] = \"IDLE\";\n  ConnectivityState[ConnectivityState[\"SHUTDOWN\"] = 4] = \"SHUTDOWN\";\n})(ConnectivityState = exports.ConnectivityState || (exports.ConnectivityState = {}));\n\nfunction uniformRandom(min, max) {\n  return Math.random() * (max - min) + min;\n}\n\nvar Http2Channel =\n/*#__PURE__*/\nfunction (_events_1$EventEmitte) {\n  _inherits(Http2Channel, _events_1$EventEmitte);\n\n  function Http2Channel(address, credentials, options) {\n    var _this;\n\n    _classCallCheck(this, Http2Channel);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(Http2Channel).call(this));\n    _this.credentials = credentials;\n    _this.options = options;\n    _this.connectivityState = ConnectivityState.IDLE; // Helper Promise object only used in the implementation of connect().\n\n    _this.connecting = null;\n    /* For now, we have up to one subchannel, which will exist as long as we are\n     * connecting or trying to connect */\n\n    _this.subChannel = null;\n\n    _this.subChannelConnectCallback = function () {};\n\n    _this.subChannelCloseCallback = function () {};\n\n    _this.currentBackoff = INITIAL_BACKOFF_MS;\n\n    for (var option in options) {\n      if (options.hasOwnProperty(option)) {\n        if (!channel_options_1.recognizedOptions.hasOwnProperty(option)) {\n          console.warn(\"Unrecognized channel argument '\".concat(option, \"' will be ignored.\"));\n        }\n      }\n    }\n\n    if (credentials._isSecure()) {\n      _this.target = new url.URL(\"https://\".concat(address));\n    } else {\n      _this.target = new url.URL(\"http://\".concat(address));\n    } // TODO(murgatroid99): Add more centralized handling of channel options\n\n\n    if (_this.options['grpc.default_authority']) {\n      _this.defaultAuthority = _this.options['grpc.default_authority'];\n    } else {\n      _this.defaultAuthority = _this.target.host;\n    }\n\n    _this.filterStackFactory = new filter_stack_1.FilterStackFactory([new call_credentials_filter_1.CallCredentialsFilterFactory(_assertThisInitialized(_assertThisInitialized(_this))), new deadline_filter_1.DeadlineFilterFactory(_assertThisInitialized(_assertThisInitialized(_this))), new metadata_status_filter_1.MetadataStatusFilterFactory(_assertThisInitialized(_assertThisInitialized(_this))), new compression_filter_1.CompressionFilterFactory(_assertThisInitialized(_assertThisInitialized(_this)))]);\n    _this.currentBackoffDeadline = new Date();\n    /* The only purpose of these lines is to ensure that this.backoffTimerId has\n     * a value of type NodeJS.Timer. */\n\n    _this.backoffTimerId = setTimeout(function () {}, 0); // Build user-agent string.\n\n    _this.userAgent = [options['grpc.primary_user_agent'], \"grpc-node-js/\".concat(clientVersion), options['grpc.secondary_user_agent']].filter(function (e) {\n      return e;\n    }).join(' '); // remove falsey values first\n\n    return _this;\n  }\n\n  _createClass(Http2Channel, [{\n    key: \"handleStateChange\",\n    value: function handleStateChange(oldState, newState) {\n      var _this2 = this;\n\n      var now = new Date();\n\n      switch (newState) {\n        case ConnectivityState.CONNECTING:\n          if (oldState === ConnectivityState.IDLE) {\n            this.currentBackoff = INITIAL_BACKOFF_MS;\n            this.currentBackoffDeadline = new Date(now.getTime() + INITIAL_BACKOFF_MS);\n          } else if (oldState === ConnectivityState.TRANSIENT_FAILURE) {\n            this.currentBackoff = Math.min(this.currentBackoff * BACKOFF_MULTIPLIER, MAX_BACKOFF_MS);\n            var jitterMagnitude = BACKOFF_JITTER * this.currentBackoff;\n            this.currentBackoffDeadline = new Date(now.getTime() + this.currentBackoff + uniformRandom(-jitterMagnitude, jitterMagnitude));\n          }\n\n          this.startConnecting();\n          break;\n\n        case ConnectivityState.READY:\n          this.emit('connect');\n          break;\n\n        case ConnectivityState.TRANSIENT_FAILURE:\n          this.subChannel = null;\n          this.backoffTimerId = setTimeout(function () {\n            _this2.transitionToState([ConnectivityState.TRANSIENT_FAILURE], ConnectivityState.CONNECTING);\n          }, this.currentBackoffDeadline.getTime() - now.getTime());\n          break;\n\n        case ConnectivityState.IDLE:\n        case ConnectivityState.SHUTDOWN:\n          if (this.subChannel) {\n            this.subChannel.close();\n            this.subChannel.removeListener('connect', this.subChannelConnectCallback);\n            this.subChannel.removeListener('close', this.subChannelCloseCallback);\n            this.subChannel = null;\n            this.emit('shutdown');\n            clearTimeout(this.backoffTimerId);\n          }\n\n          break;\n\n        default:\n          throw new Error('This should never happen');\n      }\n    } // Transition from any of a set of oldStates to a specific newState\n\n  }, {\n    key: \"transitionToState\",\n    value: function transitionToState(oldStates, newState) {\n      if (oldStates.indexOf(this.connectivityState) > -1) {\n        var oldState = this.connectivityState;\n        this.connectivityState = newState;\n        this.handleStateChange(oldState, newState);\n        this.emit('connectivityStateChanged', newState);\n      }\n    }\n  }, {\n    key: \"startConnecting\",\n    value: function startConnecting() {\n      var _this3 = this;\n\n      var connectionOptions = this.credentials._getConnectionOptions() || {};\n\n      if (connectionOptions.secureContext !== null) {\n        // If provided, the value of grpc.ssl_target_name_override should be used\n        // to override the target hostname when checking server identity.\n        // This option is used for testing only.\n        if (this.options['grpc.ssl_target_name_override']) {\n          var sslTargetNameOverride = this.options['grpc.ssl_target_name_override'];\n\n          connectionOptions.checkServerIdentity = function (host, cert) {\n            return tls_1.checkServerIdentity(sslTargetNameOverride, cert);\n          };\n\n          connectionOptions.servername = sslTargetNameOverride;\n        }\n      }\n\n      var subChannel = new subchannel_1.Http2SubChannel(this.target, connectionOptions, this.userAgent, this.options);\n      this.subChannel = subChannel;\n      var now = new Date();\n      var connectionTimeout = Math.max(this.currentBackoffDeadline.getTime() - now.getTime(), MIN_CONNECT_TIMEOUT_MS);\n      var connectionTimerId = setTimeout(function () {\n        // This should trigger the 'close' event, which will send us back to\n        // TRANSIENT_FAILURE\n        subChannel.close();\n      }, connectionTimeout);\n\n      this.subChannelConnectCallback = function () {\n        // Connection succeeded\n        clearTimeout(connectionTimerId);\n\n        _this3.transitionToState([ConnectivityState.CONNECTING], ConnectivityState.READY);\n      };\n\n      subChannel.once('connect', this.subChannelConnectCallback);\n\n      this.subChannelCloseCallback = function () {\n        // Connection failed\n        clearTimeout(connectionTimerId);\n        /* TODO(murgatroid99): verify that this works for\n         * CONNECTING->TRANSITIVE_FAILURE see nodejs/node#16645 */\n\n        _this3.transitionToState([ConnectivityState.CONNECTING, ConnectivityState.READY], ConnectivityState.TRANSIENT_FAILURE);\n      };\n\n      subChannel.once('close', this.subChannelCloseCallback);\n    }\n  }, {\n    key: \"_startHttp2Stream\",\n    value: function _startHttp2Stream(authority, methodName, stream, metadata) {\n      var _this4 = this;\n\n      var finalMetadata = stream.filterStack.sendMetadata(Promise.resolve(metadata.clone()));\n      Promise.all([finalMetadata, this.connect()]).then(function (_ref) {\n        var _ref2 = _slicedToArray(_ref, 1),\n            metadataValue = _ref2[0];\n\n        var headers = metadataValue.toHttp2Headers();\n        headers[HTTP2_HEADER_AUTHORITY] = authority;\n        headers[HTTP2_HEADER_USER_AGENT] = _this4.userAgent;\n        headers[HTTP2_HEADER_CONTENT_TYPE] = 'application/grpc';\n        headers[HTTP2_HEADER_METHOD] = 'POST';\n        headers[HTTP2_HEADER_PATH] = methodName;\n        headers[HTTP2_HEADER_TE] = 'trailers';\n\n        if (_this4.connectivityState === ConnectivityState.READY) {\n          var subChannel = _this4.subChannel;\n          subChannel.startCallStream(metadataValue, stream);\n        } else {\n          /* In this case, we lost the connection while finalizing\n           * metadata. That should be very unusual */\n          setImmediate(function () {\n            _this4._startHttp2Stream(authority, methodName, stream, metadata);\n          });\n        }\n      }).catch(function (error) {\n        // We assume the error code isn't 0 (Status.OK)\n        stream.cancelWithStatus(error.code || constants_1.Status.UNKNOWN, \"Getting metadata from plugin failed with error: \".concat(error.message));\n      });\n    }\n  }, {\n    key: \"createCall\",\n    value: function createCall(method, deadline, host, parentCall, propagateFlags) {\n      if (this.connectivityState === ConnectivityState.SHUTDOWN) {\n        throw new Error('Channel has been shut down');\n      }\n\n      var finalOptions = {\n        deadline: deadline === null || deadline === undefined ? Infinity : deadline,\n        flags: propagateFlags || 0,\n        host: host || this.defaultAuthority,\n        parentCall: parentCall || null\n      };\n      var stream = new call_stream_1.Http2CallStream(method, this, finalOptions, this.filterStackFactory);\n      return stream;\n    }\n    /**\n     * Attempts to connect, returning a Promise that resolves when the connection\n     * is successful, or rejects if the channel is shut down.\n     */\n\n  }, {\n    key: \"connect\",\n    value: function connect() {\n      var _this5 = this;\n\n      if (this.connectivityState === ConnectivityState.READY) {\n        return Promise.resolve();\n      } else if (this.connectivityState === ConnectivityState.SHUTDOWN) {\n        return Promise.reject(new Error('Channel has been shut down'));\n      } else {\n        // In effect, this.connecting is only assigned upon the first attempt to\n        // transition from IDLE to CONNECTING, so this condition could have also\n        // been (connectivityState === IDLE).\n        if (!this.connecting) {\n          this.connecting = new Promise(function (resolve, reject) {\n            _this5.transitionToState([ConnectivityState.IDLE], ConnectivityState.CONNECTING);\n\n            var onConnect = function onConnect() {\n              _this5.connecting = null;\n\n              _this5.removeListener('shutdown', onShutdown);\n\n              resolve();\n            };\n\n            var onShutdown = function onShutdown() {\n              _this5.connecting = null;\n\n              _this5.removeListener('connect', onConnect);\n\n              reject(new Error('Channel has been shut down'));\n            };\n\n            _this5.once('connect', onConnect);\n\n            _this5.once('shutdown', onShutdown);\n          });\n        }\n\n        return this.connecting;\n      }\n    }\n  }, {\n    key: \"getConnectivityState\",\n    value: function getConnectivityState(tryToConnect) {\n      if (tryToConnect) {\n        this.transitionToState([ConnectivityState.IDLE], ConnectivityState.CONNECTING);\n      }\n\n      return this.connectivityState;\n    }\n  }, {\n    key: \"watchConnectivityState\",\n    value: function watchConnectivityState(currentState, deadline, callback) {\n      var _this6 = this;\n\n      if (this.connectivityState !== currentState) {\n        /* If the connectivity state is different from the provided currentState,\n         * we assume that a state change has successfully occurred */\n        setImmediate(callback);\n      } else {\n        var deadlineMs = 0;\n\n        if (deadline instanceof Date) {\n          deadlineMs = deadline.getTime();\n        } else {\n          deadlineMs = deadline;\n        }\n\n        var timeout = deadlineMs - Date.now();\n\n        if (timeout < 0) {\n          timeout = 0;\n        }\n\n        var timeoutId = setTimeout(function () {\n          _this6.removeListener('connectivityStateChanged', eventCb);\n\n          callback(new Error('Channel state did not change before deadline'));\n        }, timeout);\n\n        var eventCb = function eventCb() {\n          clearTimeout(timeoutId);\n          callback();\n        };\n\n        this.once('connectivityStateChanged', eventCb);\n      }\n    }\n  }, {\n    key: \"getTarget\",\n    value: function getTarget() {\n      return this.target.toString();\n    }\n  }, {\n    key: \"close\",\n    value: function close() {\n      if (this.connectivityState === ConnectivityState.SHUTDOWN) {\n        throw new Error('Channel has been shut down');\n      }\n\n      this.transitionToState([ConnectivityState.CONNECTING, ConnectivityState.READY, ConnectivityState.TRANSIENT_FAILURE, ConnectivityState.IDLE], ConnectivityState.SHUTDOWN);\n    }\n  }]);\n\n  return Http2Channel;\n}(events_1.EventEmitter);\n\nexports.Http2Channel = Http2Channel;","map":null,"metadata":{},"sourceType":"script"}