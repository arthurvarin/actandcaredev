{"ast":null,"code":"\"use strict\";\n/*!\n * Copyright 2018 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nvar _classCallCheck = require(\"/Users/cvoisin/Repos/actandcaredev/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/cvoisin/Repos/actandcaredev/node_modules/@babel/runtime/helpers/createClass\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar is = require(\"is\");\n\nvar timestamp_1 = require(\"./timestamp\");\n\nvar field_value_1 = require(\"./field-value\");\n\nvar validate_1 = require(\"./validate\");\n\nvar path_1 = require(\"./path\");\n\nvar convert_1 = require(\"./convert\");\n\nvar geo_point_1 = require(\"./geo-point\");\n/**\n * Serializer that is used to convert between JavaScripts types and their\n * Firestore Protobuf representation.\n *\n * @private\n */\n\n\nvar Serializer =\n/*#__PURE__*/\nfunction () {\n  function Serializer(firestore) {\n    _classCallCheck(this, Serializer);\n\n    // Instead of storing the `firestore` object, we store just a reference to\n    // its `.doc()` method. This avoid a circular reference, which breaks\n    // JSON.stringify().\n    this.createReference = function (path) {\n      return firestore.doc(path);\n    };\n\n    this.timestampsInSnapshots = !!firestore._settings.timestampsInSnapshots;\n  }\n  /**\n   * Encodes a JavaScrip object into the Firestore 'Fields' representation.\n   *\n   * @private\n   * @param obj The object to encode.\n   * @returns The Firestore 'Fields' representation\n   */\n\n\n  _createClass(Serializer, [{\n    key: \"encodeFields\",\n    value: function encodeFields(obj) {\n      var fields = {};\n\n      for (var prop in obj) {\n        if (obj.hasOwnProperty(prop)) {\n          var val = this.encodeValue(obj[prop]);\n\n          if (val) {\n            fields[prop] = val;\n          }\n        }\n      }\n\n      return fields;\n    }\n    /**\n     * Encodes a JavaScript value into the Firestore 'Value' representation.\n     *\n     * @private\n     * @param val The object to encode\n     * @returns The Firestore Proto or null if we are deleting a field.\n     */\n\n  }, {\n    key: \"encodeValue\",\n    value: function encodeValue(val) {\n      if (val instanceof field_value_1.FieldTransform) {\n        return null;\n      }\n\n      if (is.string(val)) {\n        return {\n          stringValue: val\n        };\n      }\n\n      if (typeof val === 'boolean') {\n        return {\n          booleanValue: val\n        };\n      }\n\n      if (typeof val === 'number' && is.integer(val)) {\n        return {\n          integerValue: val\n        };\n      } // Integers are handled above, the remaining numbers are treated as doubles\n\n\n      if (is.number(val)) {\n        return {\n          doubleValue: val\n        };\n      }\n\n      if (is.date(val)) {\n        var timestamp = timestamp_1.Timestamp.fromDate(val);\n        return {\n          timestampValue: {\n            seconds: timestamp.seconds,\n            nanos: timestamp.nanoseconds\n          }\n        };\n      }\n\n      if (val === null) {\n        return {\n          nullValue: 'NULL_VALUE'\n        };\n      }\n\n      if (val instanceof Buffer || val instanceof Uint8Array) {\n        return {\n          bytesValue: val\n        };\n      }\n\n      if (typeof val === 'object' && 'toProto' in val && typeof val.toProto === 'function') {\n        return val.toProto();\n      }\n\n      if (val instanceof Array) {\n        var array = {\n          arrayValue: {}\n        };\n\n        if (val.length > 0) {\n          array.arrayValue.values = [];\n\n          for (var i = 0; i < val.length; ++i) {\n            var enc = this.encodeValue(val[i]);\n\n            if (enc) {\n              array.arrayValue.values.push(enc);\n            }\n          }\n        }\n\n        return array;\n      }\n\n      if (typeof val === 'object' && isPlainObject(val)) {\n        var map = {\n          mapValue: {}\n        }; // If we encounter an empty object, we always need to send it to make sure\n        // the server creates a map entry.\n\n        if (!is.empty(val)) {\n          map.mapValue.fields = this.encodeFields(val);\n\n          if (is.empty(map.mapValue.fields)) {\n            return null;\n          }\n        }\n\n        return map;\n      }\n\n      throw validate_1.customObjectError(val);\n    }\n    /**\n     * Decodes a single Firestore 'Value' Protobuf.\n     *\n     * @private\n     * @param proto A Firestore 'Value' Protobuf.\n     * @returns The converted JS type.\n     */\n\n  }, {\n    key: \"decodeValue\",\n    value: function decodeValue(proto) {\n      var valueType = convert_1.detectValueType(proto);\n\n      switch (valueType) {\n        case 'stringValue':\n          {\n            return proto.stringValue;\n          }\n\n        case 'booleanValue':\n          {\n            return proto.booleanValue;\n          }\n\n        case 'integerValue':\n          {\n            return Number(proto.integerValue);\n          }\n\n        case 'doubleValue':\n          {\n            return Number(proto.doubleValue);\n          }\n\n        case 'timestampValue':\n          {\n            var timestamp = timestamp_1.Timestamp.fromProto(proto.timestampValue);\n            return this.timestampsInSnapshots ? timestamp : timestamp.toDate();\n          }\n\n        case 'referenceValue':\n          {\n            var resourcePath = path_1.ResourcePath.fromSlashSeparatedString(proto.referenceValue);\n            return this.createReference(resourcePath.relativeName);\n          }\n\n        case 'arrayValue':\n          {\n            var array = [];\n\n            if (is.array(proto.arrayValue.values)) {\n              var _iteratorNormalCompletion = true;\n              var _didIteratorError = false;\n              var _iteratorError = undefined;\n\n              try {\n                for (var _iterator = proto.arrayValue.values[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n                  var value = _step.value;\n                  array.push(this.decodeValue(value));\n                }\n              } catch (err) {\n                _didIteratorError = true;\n                _iteratorError = err;\n              } finally {\n                try {\n                  if (!_iteratorNormalCompletion && _iterator.return != null) {\n                    _iterator.return();\n                  }\n                } finally {\n                  if (_didIteratorError) {\n                    throw _iteratorError;\n                  }\n                }\n              }\n            }\n\n            return array;\n          }\n\n        case 'nullValue':\n          {\n            return null;\n          }\n\n        case 'mapValue':\n          {\n            var obj = {};\n            var fields = proto.mapValue.fields;\n\n            for (var prop in fields) {\n              if (fields.hasOwnProperty(prop)) {\n                obj[prop] = this.decodeValue(fields[prop]);\n              }\n            }\n\n            return obj;\n          }\n\n        case 'geoPointValue':\n          {\n            return geo_point_1.GeoPoint.fromProto(proto.geoPointValue);\n          }\n\n        case 'bytesValue':\n          {\n            return proto.bytesValue;\n          }\n\n        default:\n          {\n            throw new Error('Cannot decode type from Firestore Value: ' + JSON.stringify(proto));\n          }\n      }\n    }\n  }]);\n\n  return Serializer;\n}();\n\nexports.Serializer = Serializer;\n/**\n * Verifies that 'obj' is a plain JavaScript object that can be encoded as a\n * 'Map' in Firestore.\n *\n * @private\n * @param input The argument to verify.\n * @returns 'true' if the input can be a treated as a plain object.\n */\n\nfunction isPlainObject(input) {\n  return typeof input === 'object' && input !== null && (Object.getPrototypeOf(input) === Object.prototype || Object.getPrototypeOf(input) === null);\n}\n\nexports.isPlainObject = isPlainObject;","map":null,"metadata":{},"sourceType":"script"}