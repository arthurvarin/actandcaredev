{"ast":null,"code":"\"use strict\";\n\nvar _classCallCheck = require(\"/Users/cvoisin/Repos/actandcaredev/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/cvoisin/Repos/actandcaredev/node_modules/@babel/runtime/helpers/createClass\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar call_1 = require(\"./call\");\n\nvar channel_1 = require(\"./channel\");\n\nvar constants_1 = require(\"./constants\");\n\nvar metadata_1 = require(\"./metadata\"); // This symbol must be exported (for now).\n// See: https://github.com/Microsoft/TypeScript/issues/20080\n\n\nexports.kChannel = Symbol();\n/**\n * A generic gRPC client. Primarily useful as a base class for all generated\n * clients.\n */\n\nvar Client =\n/*#__PURE__*/\nfunction () {\n  function Client(address, credentials) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n    _classCallCheck(this, Client);\n\n    if (options.channelOverride) {\n      this[exports.kChannel] = options.channelOverride;\n    } else if (options.channelFactoryOverride) {\n      this[exports.kChannel] = options.channelFactoryOverride(address, credentials, options);\n    } else {\n      this[exports.kChannel] = new channel_1.Http2Channel(address, credentials, options);\n    }\n  }\n\n  _createClass(Client, [{\n    key: \"close\",\n    value: function close() {\n      this[exports.kChannel].close();\n    }\n  }, {\n    key: \"getChannel\",\n    value: function getChannel() {\n      return this[exports.kChannel];\n    }\n  }, {\n    key: \"waitForReady\",\n    value: function waitForReady(deadline, callback) {\n      var _this = this;\n\n      var checkState = function checkState(err) {\n        if (err) {\n          callback(new Error('Failed to connect before the deadline'));\n          return;\n        }\n\n        var newState;\n\n        try {\n          newState = _this[exports.kChannel].getConnectivityState(true);\n        } catch (e) {\n          callback(new Error('The channel has been closed'));\n          return;\n        }\n\n        if (newState === channel_1.ConnectivityState.READY) {\n          callback();\n        } else {\n          try {\n            _this[exports.kChannel].watchConnectivityState(newState, deadline, checkState);\n          } catch (e) {\n            callback(new Error('The channel has been closed'));\n          }\n        }\n      };\n\n      setImmediate(checkState);\n    }\n  }, {\n    key: \"handleUnaryResponse\",\n    value: function handleUnaryResponse(call, deserialize, callback) {\n      var responseMessage = null;\n      call.on('data', function (data) {\n        if (responseMessage != null) {\n          call.cancelWithStatus(constants_1.Status.INTERNAL, 'Too many responses received');\n        }\n\n        try {\n          responseMessage = deserialize(data);\n        } catch (e) {\n          call.cancelWithStatus(constants_1.Status.INTERNAL, 'Failed to parse server response');\n        }\n      });\n      call.on('end', function () {\n        if (responseMessage == null) {\n          call.cancelWithStatus(constants_1.Status.INTERNAL, 'Not enough responses received');\n        }\n      });\n      call.on('status', function (status) {\n        /* We assume that call emits status after it emits end, and that it\n         * accounts for any cancelWithStatus calls up until it emits status.\n         * Therefore, considering the above event handlers, status.code should be\n         * OK if and only if we have a non-null responseMessage */\n        if (status.code === constants_1.Status.OK) {\n          callback(null, responseMessage);\n        } else {\n          var error = Object.assign(new Error(status.details), status);\n          callback(error);\n        }\n      });\n    }\n  }, {\n    key: \"checkOptionalUnaryResponseArguments\",\n    value: function checkOptionalUnaryResponseArguments(arg1, arg2, arg3) {\n      if (arg1 instanceof Function) {\n        return {\n          metadata: new metadata_1.Metadata(),\n          options: {},\n          callback: arg1\n        };\n      } else if (arg2 instanceof Function) {\n        if (arg1 instanceof metadata_1.Metadata) {\n          return {\n            metadata: arg1,\n            options: {},\n            callback: arg2\n          };\n        } else {\n          return {\n            metadata: new metadata_1.Metadata(),\n            options: arg1,\n            callback: arg2\n          };\n        }\n      } else {\n        if (!(arg1 instanceof metadata_1.Metadata && arg2 instanceof Object && arg3 instanceof Function)) {\n          throw new Error('Incorrect arguments passed');\n        }\n\n        return {\n          metadata: arg1,\n          options: arg2,\n          callback: arg3\n        };\n      }\n    }\n  }, {\n    key: \"makeUnaryRequest\",\n    value: function makeUnaryRequest(method, serialize, deserialize, argument, metadata, options, callback) {\n      var _this$checkOptionalUn = this.checkOptionalUnaryResponseArguments(metadata, options, callback);\n\n      metadata = _this$checkOptionalUn.metadata;\n      options = _this$checkOptionalUn.options;\n      callback = _this$checkOptionalUn.callback;\n      var call = this[exports.kChannel].createCall(method, options.deadline, options.host, options.parent, options.propagate_flags);\n\n      if (options.credentials) {\n        call.setCredentials(options.credentials);\n      }\n\n      var message = serialize(argument);\n      var writeObj = {\n        message: message\n      };\n      call.sendMetadata(metadata);\n      call.write(writeObj);\n      call.end();\n      this.handleUnaryResponse(call, deserialize, callback);\n      return new call_1.ClientUnaryCallImpl(call);\n    }\n  }, {\n    key: \"makeClientStreamRequest\",\n    value: function makeClientStreamRequest(method, serialize, deserialize, metadata, options, callback) {\n      var _this$checkOptionalUn2 = this.checkOptionalUnaryResponseArguments(metadata, options, callback);\n\n      metadata = _this$checkOptionalUn2.metadata;\n      options = _this$checkOptionalUn2.options;\n      callback = _this$checkOptionalUn2.callback;\n      var call = this[exports.kChannel].createCall(method, options.deadline, options.host, options.parent, options.propagate_flags);\n\n      if (options.credentials) {\n        call.setCredentials(options.credentials);\n      }\n\n      call.sendMetadata(metadata);\n      this.handleUnaryResponse(call, deserialize, callback);\n      return new call_1.ClientWritableStreamImpl(call, serialize);\n    }\n  }, {\n    key: \"checkMetadataAndOptions\",\n    value: function checkMetadataAndOptions(arg1, arg2) {\n      var metadata;\n      var options;\n\n      if (arg1 instanceof metadata_1.Metadata) {\n        metadata = arg1;\n\n        if (arg2) {\n          options = arg2;\n        } else {\n          options = {};\n        }\n      } else {\n        if (arg1) {\n          options = arg1;\n        } else {\n          options = {};\n        }\n\n        metadata = new metadata_1.Metadata();\n      }\n\n      return {\n        metadata: metadata,\n        options: options\n      };\n    }\n  }, {\n    key: \"makeServerStreamRequest\",\n    value: function makeServerStreamRequest(method, serialize, deserialize, argument, metadata, options) {\n      var _this$checkMetadataAn = this.checkMetadataAndOptions(metadata, options);\n\n      metadata = _this$checkMetadataAn.metadata;\n      options = _this$checkMetadataAn.options;\n      var call = this[exports.kChannel].createCall(method, options.deadline, options.host, options.parent, options.propagate_flags);\n\n      if (options.credentials) {\n        call.setCredentials(options.credentials);\n      }\n\n      var message = serialize(argument);\n      var writeObj = {\n        message: message\n      };\n      call.sendMetadata(metadata);\n      call.write(writeObj);\n      call.end();\n      return new call_1.ClientReadableStreamImpl(call, deserialize);\n    }\n  }, {\n    key: \"makeBidiStreamRequest\",\n    value: function makeBidiStreamRequest(method, serialize, deserialize, metadata, options) {\n      var _this$checkMetadataAn2 = this.checkMetadataAndOptions(metadata, options);\n\n      metadata = _this$checkMetadataAn2.metadata;\n      options = _this$checkMetadataAn2.options;\n      var call = this[exports.kChannel].createCall(method, options.deadline, options.host, options.parent, options.propagate_flags);\n\n      if (options.credentials) {\n        call.setCredentials(options.credentials);\n      }\n\n      call.sendMetadata(metadata);\n      return new call_1.ClientDuplexStreamImpl(call, serialize, deserialize);\n    }\n  }]);\n\n  return Client;\n}();\n\nexports.Client = Client;","map":null,"metadata":{},"sourceType":"script"}