{"ast":null,"code":"\"use strict\";\n\nvar _assertThisInitialized = require(\"/Users/cvoisin/Repos/actandcaredev/node_modules/@babel/runtime/helpers/assertThisInitialized\");\n\nvar _classCallCheck = require(\"/Users/cvoisin/Repos/actandcaredev/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/cvoisin/Repos/actandcaredev/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _possibleConstructorReturn = require(\"/Users/cvoisin/Repos/actandcaredev/node_modules/@babel/runtime/helpers/possibleConstructorReturn\");\n\nvar _getPrototypeOf = require(\"/Users/cvoisin/Repos/actandcaredev/node_modules/@babel/runtime/helpers/getPrototypeOf\");\n\nvar _inherits = require(\"/Users/cvoisin/Repos/actandcaredev/node_modules/@babel/runtime/helpers/inherits\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar events_1 = require(\"events\");\n\nvar stream_1 = require(\"stream\");\n\nvar constants_1 = require(\"./constants\");\n\nvar ClientUnaryCallImpl =\n/*#__PURE__*/\nfunction (_events_1$EventEmitte) {\n  _inherits(ClientUnaryCallImpl, _events_1$EventEmitte);\n\n  function ClientUnaryCallImpl(call) {\n    var _this;\n\n    _classCallCheck(this, ClientUnaryCallImpl);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(ClientUnaryCallImpl).call(this));\n    _this.call = call;\n    call.on('metadata', function (metadata) {\n      _this.emit('metadata', metadata);\n    });\n    call.on('status', function (status) {\n      _this.emit('status', status);\n    });\n    return _this;\n  }\n\n  _createClass(ClientUnaryCallImpl, [{\n    key: \"cancel\",\n    value: function cancel() {\n      this.call.cancelWithStatus(constants_1.Status.CANCELLED, 'Cancelled on client');\n    }\n  }, {\n    key: \"getPeer\",\n    value: function getPeer() {\n      return this.call.getPeer();\n    }\n  }]);\n\n  return ClientUnaryCallImpl;\n}(events_1.EventEmitter);\n\nexports.ClientUnaryCallImpl = ClientUnaryCallImpl;\n\nfunction setUpReadableStream(stream, call, deserialize) {\n  var statusEmitted = false;\n  call.on('data', function (data) {\n    var deserialized;\n\n    try {\n      deserialized = deserialize(data);\n    } catch (e) {\n      call.cancelWithStatus(constants_1.Status.INTERNAL, 'Failed to parse server response');\n      return;\n    }\n\n    if (!stream.push(deserialized)) {\n      call.pause();\n    }\n  });\n  call.on('end', function () {\n    if (statusEmitted) {\n      stream.push(null);\n    } else {\n      call.once('status', function () {\n        stream.push(null);\n      });\n    }\n  });\n  call.on('status', function (status) {\n    if (status.code !== constants_1.Status.OK) {\n      var error = Object.assign(new Error(status.details), status);\n      stream.emit('error', error);\n    }\n\n    stream.emit('status', status);\n    statusEmitted = true;\n  });\n  call.pause();\n}\n\nvar ClientReadableStreamImpl =\n/*#__PURE__*/\nfunction (_stream_1$Readable) {\n  _inherits(ClientReadableStreamImpl, _stream_1$Readable);\n\n  function ClientReadableStreamImpl(call, deserialize) {\n    var _this2;\n\n    _classCallCheck(this, ClientReadableStreamImpl);\n\n    _this2 = _possibleConstructorReturn(this, _getPrototypeOf(ClientReadableStreamImpl).call(this, {\n      objectMode: true\n    }));\n    _this2.call = call;\n    _this2.deserialize = deserialize;\n    call.on('metadata', function (metadata) {\n      _this2.emit('metadata', metadata);\n    });\n    setUpReadableStream(_assertThisInitialized(_assertThisInitialized(_this2)), call, deserialize);\n    return _this2;\n  }\n\n  _createClass(ClientReadableStreamImpl, [{\n    key: \"cancel\",\n    value: function cancel() {\n      this.call.cancelWithStatus(constants_1.Status.CANCELLED, 'Cancelled on client');\n    }\n  }, {\n    key: \"getPeer\",\n    value: function getPeer() {\n      return this.call.getPeer();\n    }\n  }, {\n    key: \"_read\",\n    value: function _read(_size) {\n      this.call.resume();\n    }\n  }]);\n\n  return ClientReadableStreamImpl;\n}(stream_1.Readable);\n\nexports.ClientReadableStreamImpl = ClientReadableStreamImpl;\n\nfunction tryWrite(call, serialize, chunk, encoding, cb) {\n  var message;\n  var flags = Number(encoding);\n\n  try {\n    message = serialize(chunk);\n  } catch (e) {\n    call.cancelWithStatus(constants_1.Status.INTERNAL, 'Serialization failure');\n    cb(e);\n    return;\n  }\n\n  var writeObj = {\n    message: message\n  };\n\n  if (!Number.isNaN(flags)) {\n    writeObj.flags = flags;\n  }\n\n  call.write(writeObj, cb);\n}\n\nvar ClientWritableStreamImpl =\n/*#__PURE__*/\nfunction (_stream_1$Writable) {\n  _inherits(ClientWritableStreamImpl, _stream_1$Writable);\n\n  function ClientWritableStreamImpl(call, serialize) {\n    var _this3;\n\n    _classCallCheck(this, ClientWritableStreamImpl);\n\n    _this3 = _possibleConstructorReturn(this, _getPrototypeOf(ClientWritableStreamImpl).call(this, {\n      objectMode: true\n    }));\n    _this3.call = call;\n    _this3.serialize = serialize;\n    call.on('metadata', function (metadata) {\n      _this3.emit('metadata', metadata);\n    });\n    call.on('status', function (status) {\n      _this3.emit('status', status);\n    });\n    return _this3;\n  }\n\n  _createClass(ClientWritableStreamImpl, [{\n    key: \"cancel\",\n    value: function cancel() {\n      this.call.cancelWithStatus(constants_1.Status.CANCELLED, 'Cancelled on client');\n    }\n  }, {\n    key: \"getPeer\",\n    value: function getPeer() {\n      return this.call.getPeer();\n    }\n  }, {\n    key: \"_write\",\n    value: function _write(chunk, encoding, cb) {\n      tryWrite(this.call, this.serialize, chunk, encoding, cb);\n    }\n  }, {\n    key: \"_final\",\n    value: function _final(cb) {\n      this.call.end();\n      cb();\n    }\n  }]);\n\n  return ClientWritableStreamImpl;\n}(stream_1.Writable);\n\nexports.ClientWritableStreamImpl = ClientWritableStreamImpl;\n\nvar ClientDuplexStreamImpl =\n/*#__PURE__*/\nfunction (_stream_1$Duplex) {\n  _inherits(ClientDuplexStreamImpl, _stream_1$Duplex);\n\n  function ClientDuplexStreamImpl(call, serialize, deserialize) {\n    var _this4;\n\n    _classCallCheck(this, ClientDuplexStreamImpl);\n\n    _this4 = _possibleConstructorReturn(this, _getPrototypeOf(ClientDuplexStreamImpl).call(this, {\n      objectMode: true\n    }));\n    _this4.call = call;\n    _this4.serialize = serialize;\n    _this4.deserialize = deserialize;\n    call.on('metadata', function (metadata) {\n      _this4.emit('metadata', metadata);\n    });\n    setUpReadableStream(_assertThisInitialized(_assertThisInitialized(_this4)), call, deserialize);\n    return _this4;\n  }\n\n  _createClass(ClientDuplexStreamImpl, [{\n    key: \"cancel\",\n    value: function cancel() {\n      this.call.cancelWithStatus(constants_1.Status.CANCELLED, 'Cancelled on client');\n    }\n  }, {\n    key: \"getPeer\",\n    value: function getPeer() {\n      return this.call.getPeer();\n    }\n  }, {\n    key: \"_read\",\n    value: function _read(_size) {\n      this.call.resume();\n    }\n  }, {\n    key: \"_write\",\n    value: function _write(chunk, encoding, cb) {\n      tryWrite(this.call, this.serialize, chunk, encoding, cb);\n    }\n  }, {\n    key: \"_final\",\n    value: function _final(cb) {\n      this.call.end();\n      cb();\n    }\n  }]);\n\n  return ClientDuplexStreamImpl;\n}(stream_1.Duplex);\n\nexports.ClientDuplexStreamImpl = ClientDuplexStreamImpl;","map":null,"metadata":{},"sourceType":"script"}