{"ast":null,"code":"// The framer consists of two [Transform Stream][1] subclasses that operate in [object mode][2]:\n// the Serializer and the Deserializer\n// [1]: https://nodejs.org/api/stream.html#stream_class_stream_transform\n// [2]: https://nodejs.org/api/stream.html#stream_new_stream_readable_options\nvar assert = require('assert');\n\nvar Transform = require('stream').Transform;\n\nexports.Serializer = Serializer;\nexports.Deserializer = Deserializer;\nvar logData = Boolean(process.env.HTTP2_LOG_DATA);\nvar MAX_PAYLOAD_SIZE = 16384;\nvar WINDOW_UPDATE_PAYLOAD_SIZE = 4; // Serializer\n// ----------\n//\n//     Frame Objects\n//     * * * * * * * --+---------------------------\n//                     |                          |\n//                     v                          v           Buffers\n//      [] -----> Payload Ser. --[buffers]--> Header Ser. --> * * * *\n//     empty      adds payload                adds header\n//     array        buffers                     buffer\n\nfunction Serializer(log) {\n  this._log = log.child({\n    component: 'serializer'\n  });\n  Transform.call(this, {\n    objectMode: true\n  });\n}\n\nSerializer.prototype = Object.create(Transform.prototype, {\n  constructor: {\n    value: Serializer\n  }\n}); // When there's an incoming frame object, it first generates the frame type specific part of the\n// frame (payload), and then then adds the header part which holds fields that are common to all\n// frame types (like the length of the payload).\n\nSerializer.prototype._transform = function _transform(frame, encoding, done) {\n  this._log.trace({\n    frame: frame\n  }, 'Outgoing frame');\n\n  assert(frame.type in Serializer, 'Unknown frame type: ' + frame.type);\n  var buffers = [];\n  Serializer[frame.type](frame, buffers);\n  var length = Serializer.commonHeader(frame, buffers);\n  assert(length <= MAX_PAYLOAD_SIZE, 'Frame too large!');\n\n  for (var i = 0; i < buffers.length; i++) {\n    if (logData) {\n      this._log.trace({\n        data: buffers[i]\n      }, 'Outgoing data');\n    }\n\n    this.push(buffers[i]);\n  }\n\n  done();\n}; // Deserializer\n// ------------\n//\n//     Buffers\n//     * * * * --------+-------------------------\n//                     |                        |\n//                     v                        v           Frame Objects\n//      {} -----> Header Des. --{frame}--> Payload Des. --> * * * * * * *\n//     empty      adds parsed              adds parsed\n//     object  header properties        payload properties\n\n\nfunction Deserializer(log, role) {\n  this._role = role;\n  this._log = log.child({\n    component: 'deserializer'\n  });\n  Transform.call(this, {\n    objectMode: true\n  });\n\n  this._next(COMMON_HEADER_SIZE);\n}\n\nDeserializer.prototype = Object.create(Transform.prototype, {\n  constructor: {\n    value: Deserializer\n  }\n}); // The Deserializer is stateful, and it's two main alternating states are: *waiting for header* and\n// *waiting for payload*. The state is stored in the boolean property `_waitingForHeader`.\n//\n// When entering a new state, a `_buffer` is created that will hold the accumulated data (header or\n// payload). The `_cursor` is used to track the progress.\n\nDeserializer.prototype._next = function (size) {\n  this._cursor = 0;\n  this._buffer = new Buffer(size);\n  this._waitingForHeader = !this._waitingForHeader;\n\n  if (this._waitingForHeader) {\n    this._frame = {};\n  }\n}; // Parsing an incoming buffer is an iterative process because it can hold multiple frames if it's\n// large enough. A `cursor` is used to track the progress in parsing the incoming `chunk`.\n\n\nDeserializer.prototype._transform = function _transform(chunk, encoding, done) {\n  var cursor = 0;\n\n  if (logData) {\n    this._log.trace({\n      data: chunk\n    }, 'Incoming data');\n  }\n\n  while (cursor < chunk.length) {\n    // The content of an incoming buffer is first copied to `_buffer`. If it can't hold the full\n    // chunk, then only a part of it is copied.\n    var toCopy = Math.min(chunk.length - cursor, this._buffer.length - this._cursor);\n    chunk.copy(this._buffer, this._cursor, cursor, cursor + toCopy);\n    this._cursor += toCopy;\n    cursor += toCopy; // When `_buffer` is full, it's content gets parsed either as header or payload depending on\n    // the actual state.\n    // If it's header then the parsed data is stored in a temporary variable and then the\n    // deserializer waits for the specified length payload.\n\n    if (this._cursor === this._buffer.length && this._waitingForHeader) {\n      var payloadSize = Deserializer.commonHeader(this._buffer, this._frame);\n\n      if (payloadSize <= MAX_PAYLOAD_SIZE) {\n        this._next(payloadSize);\n      } else {\n        this.emit('error', 'FRAME_SIZE_ERROR');\n        return;\n      }\n    } // If it's payload then the the frame object is finalized and then gets pushed out.\n    // Unknown frame types are ignored.\n    //\n    // Note: If we just finished the parsing of a header and the payload length is 0, this branch\n    // will also run.\n\n\n    if (this._cursor === this._buffer.length && !this._waitingForHeader) {\n      if (this._frame.type) {\n        var error = Deserializer[this._frame.type](this._buffer, this._frame, this._role);\n\n        if (error) {\n          this._log.error('Incoming frame parsing error: ' + error);\n\n          this.emit('error', error);\n        } else {\n          this._log.trace({\n            frame: this._frame\n          }, 'Incoming frame');\n\n          this.push(this._frame);\n        }\n      } else {\n        this._log.error('Unknown type incoming frame'); // Ignore it other than logging\n\n      }\n\n      this._next(COMMON_HEADER_SIZE);\n    }\n  }\n\n  done();\n}; // [Frame Header](https://tools.ietf.org/html/rfc7540#section-4.1)\n// --------------------------------------------------------------\n//\n// HTTP/2 frames share a common base format consisting of a 9-byte header followed by 0 to 2^24 - 1\n// bytes of data.\n//\n// Additional size limits can be set by specific application uses. HTTP limits the frame size to\n// 16,384 octets by default, though this can be increased by a receiver.\n//\n//      0                   1                   2                   3\n//      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n//     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n//     |                 Length (24)                   |\n//     +---------------+---------------+---------------+\n//     |   Type (8)    |   Flags (8)   |\n//     +-+-----------------------------+---------------+---------------+\n//     |R|                 Stream Identifier (31)                      |\n//     +-+-------------------------------------------------------------+\n//     |                     Frame Data (0...)                       ...\n//     +---------------------------------------------------------------+\n//\n// The fields of the frame header are defined as:\n//\n// * Length:\n//   The length of the frame data expressed as an unsigned 24-bit integer. The 9 bytes of the frame\n//   header are not included in this value.\n//\n// * Type:\n//   The 8-bit type of the frame. The frame type determines how the remainder of the frame header\n//   and data are interpreted. Implementations MUST ignore unsupported and unrecognized frame types.\n//\n// * Flags:\n//   An 8-bit field reserved for frame-type specific boolean flags.\n//\n//   Flags are assigned semantics specific to the indicated frame type. Flags that have no defined\n//   semantics for a particular frame type MUST be ignored, and MUST be left unset (0) when sending.\n//\n// * R:\n//   A reserved 1-bit field. The semantics of this bit are undefined and the bit MUST remain unset\n//   (0) when sending and MUST be ignored when receiving.\n//\n// * Stream Identifier:\n//   A 31-bit stream identifier. The value 0 is reserved for frames that are associated with the\n//   connection as a whole as opposed to an individual stream.\n//\n// The structure and content of the remaining frame data is dependent entirely on the frame type.\n\n\nvar COMMON_HEADER_SIZE = 9;\nvar frameTypes = [];\nvar frameFlags = {};\nvar genericAttributes = ['type', 'flags', 'stream'];\nvar typeSpecificAttributes = {};\n\nSerializer.commonHeader = function writeCommonHeader(frame, buffers) {\n  var headerBuffer = new Buffer(COMMON_HEADER_SIZE);\n  var size = 0;\n\n  for (var i = 0; i < buffers.length; i++) {\n    size += buffers[i].length;\n  }\n\n  headerBuffer.writeUInt8(0, 0);\n  headerBuffer.writeUInt16BE(size, 1);\n  var typeId = frameTypes.indexOf(frame.type); // If we are here then the type is valid for sure\n\n  headerBuffer.writeUInt8(typeId, 3);\n  var flagByte = 0;\n\n  for (var flag in frame.flags) {\n    var position = frameFlags[frame.type].indexOf(flag);\n    assert(position !== -1, 'Unknown flag for frame type ' + frame.type + ': ' + flag);\n\n    if (frame.flags[flag]) {\n      flagByte |= 1 << position;\n    }\n  }\n\n  headerBuffer.writeUInt8(flagByte, 4);\n  assert(0 <= frame.stream && frame.stream < 0x7fffffff, frame.stream);\n  headerBuffer.writeUInt32BE(frame.stream || 0, 5);\n  buffers.unshift(headerBuffer);\n  return size;\n};\n\nDeserializer.commonHeader = function readCommonHeader(buffer, frame) {\n  if (buffer.length < 9) {\n    return 'FRAME_SIZE_ERROR';\n  }\n\n  var totallyWastedByte = buffer.readUInt8(0);\n  var length = buffer.readUInt16BE(1); // We do this just for sanity checking later on, to make sure no one sent us a\n  // frame that's super large.\n\n  length += totallyWastedByte << 16;\n  frame.type = frameTypes[buffer.readUInt8(3)];\n\n  if (!frame.type) {\n    // We are required to ignore unknown frame types\n    return length;\n  }\n\n  frame.flags = {};\n  var flagByte = buffer.readUInt8(4);\n  var definedFlags = frameFlags[frame.type];\n\n  for (var i = 0; i < definedFlags.length; i++) {\n    frame.flags[definedFlags[i]] = Boolean(flagByte & 1 << i);\n  }\n\n  frame.stream = buffer.readUInt32BE(5) & 0x7fffffff;\n  return length;\n}; // Frame types\n// ===========\n// Every frame type is registered in the following places:\n//\n// * `frameTypes`: a register of frame type codes (used by `commonHeader()`)\n// * `frameFlags`: a register of valid flags for frame types (used by `commonHeader()`)\n// * `typeSpecificAttributes`: a register of frame specific frame object attributes (used by\n//   logging code and also serves as documentation for frame objects)\n// [DATA Frames](https://tools.ietf.org/html/rfc7540#section-6.1)\n// ------------------------------------------------------------\n//\n// DATA frames (type=0x0) convey arbitrary, variable-length sequences of octets associated with a\n// stream.\n//\n// The DATA frame defines the following flags:\n//\n// * END_STREAM (0x1):\n//   Bit 1 being set indicates that this frame is the last that the endpoint will send for the\n//   identified stream.\n// * PADDED (0x08):\n//   Bit 4 being set indicates that the Pad Length field is present.\n\n\nframeTypes[0x0] = 'DATA';\nframeFlags.DATA = ['END_STREAM', 'RESERVED2', 'RESERVED4', 'PADDED'];\ntypeSpecificAttributes.DATA = ['data'];\n\nSerializer.DATA = function writeData(frame, buffers) {\n  buffers.push(frame.data);\n};\n\nDeserializer.DATA = function readData(buffer, frame) {\n  var dataOffset = 0;\n  var paddingLength = 0;\n\n  if (frame.flags.PADDED) {\n    if (buffer.length < 1) {\n      // We must have at least one byte for padding control, but we don't. Bad peer!\n      return 'FRAME_SIZE_ERROR';\n    }\n\n    paddingLength = buffer.readUInt8(dataOffset) & 0xff;\n    dataOffset = 1;\n  }\n\n  if (paddingLength) {\n    if (paddingLength >= buffer.length - 1) {\n      // We don't have enough room for the padding advertised - bad peer!\n      return 'FRAME_SIZE_ERROR';\n    }\n\n    frame.data = buffer.slice(dataOffset, -1 * paddingLength);\n  } else {\n    frame.data = buffer.slice(dataOffset);\n  }\n}; // [HEADERS](https://tools.ietf.org/html/rfc7540#section-6.2)\n// --------------------------------------------------------------\n//\n// The HEADERS frame (type=0x1) allows the sender to create a stream.\n//\n// The HEADERS frame defines the following flags:\n//\n// * END_STREAM (0x1):\n//   Bit 1 being set indicates that this frame is the last that the endpoint will send for the\n//   identified stream.\n// * END_HEADERS (0x4):\n//   The END_HEADERS bit indicates that this frame contains the entire payload necessary to provide\n//   a complete set of headers.\n// * PADDED (0x08):\n//   Bit 4 being set indicates that the Pad Length field is present.\n// * PRIORITY (0x20):\n//   Bit 6 being set indicates that the Exlusive Flag (E), Stream Dependency, and Weight fields are\n//   present.\n\n\nframeTypes[0x1] = 'HEADERS';\nframeFlags.HEADERS = ['END_STREAM', 'RESERVED2', 'END_HEADERS', 'PADDED', 'RESERVED5', 'PRIORITY'];\ntypeSpecificAttributes.HEADERS = ['priorityDependency', 'priorityWeight', 'exclusiveDependency', 'headers', 'data']; //      0                   1                   2                   3\n//      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n//     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n//     |Pad Length? (8)|\n//     +-+-------------+---------------+-------------------------------+\n//     |E|                 Stream Dependency? (31)                     |\n//     +-+-------------+-----------------------------------------------+\n//     |  Weight? (8)  |\n//     +-+-------------+-----------------------------------------------+\n//     |                   Header Block Fragment (*)                 ...\n//     +---------------------------------------------------------------+\n//     |                           Padding (*)                       ...\n//     +---------------------------------------------------------------+\n//\n// The payload of a HEADERS frame contains a Headers Block\n\nSerializer.HEADERS = function writeHeadersPriority(frame, buffers) {\n  if (frame.flags.PRIORITY) {\n    var buffer = new Buffer(5);\n    assert(0 <= frame.priorityDependency && frame.priorityDependency <= 0x7fffffff, frame.priorityDependency);\n    buffer.writeUInt32BE(frame.priorityDependency, 0);\n\n    if (frame.exclusiveDependency) {\n      buffer[0] |= 0x80;\n    }\n\n    assert(0 <= frame.priorityWeight && frame.priorityWeight <= 0xff, frame.priorityWeight);\n    buffer.writeUInt8(frame.priorityWeight, 4);\n    buffers.push(buffer);\n  }\n\n  buffers.push(frame.data);\n};\n\nDeserializer.HEADERS = function readHeadersPriority(buffer, frame) {\n  var minFrameLength = 0;\n\n  if (frame.flags.PADDED) {\n    minFrameLength += 1;\n  }\n\n  if (frame.flags.PRIORITY) {\n    minFrameLength += 5;\n  }\n\n  if (buffer.length < minFrameLength) {\n    // Peer didn't send enough data - bad peer!\n    return 'FRAME_SIZE_ERROR';\n  }\n\n  var dataOffset = 0;\n  var paddingLength = 0;\n\n  if (frame.flags.PADDED) {\n    paddingLength = buffer.readUInt8(dataOffset) & 0xff;\n    dataOffset = 1;\n  }\n\n  if (frame.flags.PRIORITY) {\n    var dependencyData = new Buffer(4);\n    buffer.copy(dependencyData, 0, dataOffset, dataOffset + 4);\n    dataOffset += 4;\n    frame.exclusiveDependency = !!(dependencyData[0] & 0x80);\n    dependencyData[0] &= 0x7f;\n    frame.priorityDependency = dependencyData.readUInt32BE(0);\n    frame.priorityWeight = buffer.readUInt8(dataOffset);\n    dataOffset += 1;\n  }\n\n  if (paddingLength) {\n    if (buffer.length - dataOffset < paddingLength) {\n      // Not enough data left to satisfy the advertised padding - bad peer!\n      return 'FRAME_SIZE_ERROR';\n    }\n\n    frame.data = buffer.slice(dataOffset, -1 * paddingLength);\n  } else {\n    frame.data = buffer.slice(dataOffset);\n  }\n}; // [PRIORITY](https://tools.ietf.org/html/rfc7540#section-6.3)\n// -------------------------------------------------------\n//\n// The PRIORITY frame (type=0x2) specifies the sender-advised priority of a stream.\n//\n// The PRIORITY frame does not define any flags.\n\n\nframeTypes[0x2] = 'PRIORITY';\nframeFlags.PRIORITY = [];\ntypeSpecificAttributes.PRIORITY = ['priorityDependency', 'priorityWeight', 'exclusiveDependency']; //      0                   1                   2                   3\n//      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n//     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n//     |E|                 Stream Dependency? (31)                     |\n//     +-+-------------+-----------------------------------------------+\n//     |  Weight? (8)  |\n//     +-+-------------+\n//\n// The payload of a PRIORITY frame contains an exclusive bit, a 31-bit dependency, and an 8-bit weight\n\nSerializer.PRIORITY = function writePriority(frame, buffers) {\n  var buffer = new Buffer(5);\n  assert(0 <= frame.priorityDependency && frame.priorityDependency <= 0x7fffffff, frame.priorityDependency);\n  buffer.writeUInt32BE(frame.priorityDependency, 0);\n\n  if (frame.exclusiveDependency) {\n    buffer[0] |= 0x80;\n  }\n\n  assert(0 <= frame.priorityWeight && frame.priorityWeight <= 0xff, frame.priorityWeight);\n  buffer.writeUInt8(frame.priorityWeight, 4);\n  buffers.push(buffer);\n};\n\nDeserializer.PRIORITY = function readPriority(buffer, frame) {\n  if (buffer.length < 5) {\n    // PRIORITY frames are 5 bytes long. Bad peer!\n    return 'FRAME_SIZE_ERROR';\n  }\n\n  var dependencyData = new Buffer(4);\n  buffer.copy(dependencyData, 0, 0, 4);\n  frame.exclusiveDependency = !!(dependencyData[0] & 0x80);\n  dependencyData[0] &= 0x7f;\n  frame.priorityDependency = dependencyData.readUInt32BE(0);\n  frame.priorityWeight = buffer.readUInt8(4);\n}; // [RST_STREAM](https://tools.ietf.org/html/rfc7540#section-6.4)\n// -----------------------------------------------------------\n//\n// The RST_STREAM frame (type=0x3) allows for abnormal termination of a stream.\n//\n// No type-flags are defined.\n\n\nframeTypes[0x3] = 'RST_STREAM';\nframeFlags.RST_STREAM = [];\ntypeSpecificAttributes.RST_STREAM = ['error']; //      0                   1                   2                   3\n//      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n//     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n//     |                         Error Code (32)                       |\n//     +---------------------------------------------------------------+\n//\n// The RST_STREAM frame contains a single unsigned, 32-bit integer identifying the error\n// code (see Error Codes). The error code indicates why the stream is being terminated.\n\nSerializer.RST_STREAM = function writeRstStream(frame, buffers) {\n  var buffer = new Buffer(4);\n  var code = errorCodes.indexOf(frame.error);\n  assert(0 <= code && code <= 0xffffffff, code);\n  buffer.writeUInt32BE(code, 0);\n  buffers.push(buffer);\n};\n\nDeserializer.RST_STREAM = function readRstStream(buffer, frame) {\n  if (buffer.length < 4) {\n    // RST_STREAM is 4 bytes long. Bad peer!\n    return 'FRAME_SIZE_ERROR';\n  }\n\n  frame.error = errorCodes[buffer.readUInt32BE(0)];\n\n  if (!frame.error) {\n    // Unknown error codes are considered equivalent to INTERNAL_ERROR\n    frame.error = 'INTERNAL_ERROR';\n  }\n}; // [SETTINGS](https://tools.ietf.org/html/rfc7540#section-6.5)\n// -------------------------------------------------------\n//\n// The SETTINGS frame (type=0x4) conveys configuration parameters that affect how endpoints\n// communicate.\n//\n// The SETTINGS frame defines the following flag:\n// * ACK (0x1):\n//   Bit 1 being set indicates that this frame acknowledges receipt and application of the peer's\n//   SETTINGS frame.\n\n\nframeTypes[0x4] = 'SETTINGS';\nframeFlags.SETTINGS = ['ACK'];\ntypeSpecificAttributes.SETTINGS = ['settings']; // The payload of a SETTINGS frame consists of zero or more settings. Each setting consists of a\n// 16-bit identifier, and an unsigned 32-bit value.\n//\n//      0                   1                   2                   3\n//      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n//     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n//     |         Identifier(16)          |        Value (32)           |\n//     +-----------------+---------------------------------------------+\n//     ...Value                          |\n//     +---------------------------------+\n//\n// Each setting in a SETTINGS frame replaces the existing value for that setting.  Settings are\n// processed in the order in which they appear, and a receiver of a SETTINGS frame does not need to\n// maintain any state other than the current value of settings.  Therefore, the value of a setting\n// is the last value that is seen by a receiver. This permits the inclusion of the same settings\n// multiple times in the same SETTINGS frame, though doing so does nothing other than waste\n// connection capacity.\n\nSerializer.SETTINGS = function writeSettings(frame, buffers) {\n  var settings = [],\n      settingsLeft = Object.keys(frame.settings);\n  definedSettings.forEach(function (setting, id) {\n    if (setting.name in frame.settings) {\n      settingsLeft.splice(settingsLeft.indexOf(setting.name), 1);\n      var value = frame.settings[setting.name];\n      settings.push({\n        id: id,\n        value: setting.flag ? Boolean(value) : value\n      });\n    }\n  });\n  assert(settingsLeft.length === 0, 'Unknown settings: ' + settingsLeft.join(', '));\n  var buffer = new Buffer(settings.length * 6);\n\n  for (var i = 0; i < settings.length; i++) {\n    buffer.writeUInt16BE(settings[i].id & 0xffff, i * 6);\n    buffer.writeUInt32BE(settings[i].value, i * 6 + 2);\n  }\n\n  buffers.push(buffer);\n};\n\nDeserializer.SETTINGS = function readSettings(buffer, frame, role) {\n  frame.settings = {}; // Receipt of a SETTINGS frame with the ACK flag set and a length\n  // field value other than 0 MUST be treated as a connection error\n  // (Section 5.4.1) of type FRAME_SIZE_ERROR.\n\n  if (frame.flags.ACK && buffer.length != 0) {\n    return 'FRAME_SIZE_ERROR';\n  }\n\n  if (buffer.length % 6 !== 0) {\n    return 'PROTOCOL_ERROR';\n  }\n\n  for (var i = 0; i < buffer.length / 6; i++) {\n    var id = buffer.readUInt16BE(i * 6) & 0xffff;\n    var setting = definedSettings[id];\n\n    if (setting) {\n      if (role == 'CLIENT' && setting.name == 'SETTINGS_ENABLE_PUSH') {\n        return 'SETTINGS frame on client got SETTINGS_ENABLE_PUSH';\n      }\n\n      var value = buffer.readUInt32BE(i * 6 + 2);\n      frame.settings[setting.name] = setting.flag ? Boolean(value & 0x1) : value;\n    }\n  }\n}; // The following settings are defined:\n\n\nvar definedSettings = []; // * SETTINGS_HEADER_TABLE_SIZE (1):\n//   Allows the sender to inform the remote endpoint of the size of the header compression table\n//   used to decode header blocks.\n\ndefinedSettings[1] = {\n  name: 'SETTINGS_HEADER_TABLE_SIZE',\n  flag: false\n}; // * SETTINGS_ENABLE_PUSH (2):\n//   This setting can be use to disable server push. An endpoint MUST NOT send a PUSH_PROMISE frame\n//   if it receives this setting set to a value of 0. The default value is 1, which indicates that\n//   push is permitted.\n\ndefinedSettings[2] = {\n  name: 'SETTINGS_ENABLE_PUSH',\n  flag: true\n}; // * SETTINGS_MAX_CONCURRENT_STREAMS (3):\n//   indicates the maximum number of concurrent streams that the sender will allow.\n\ndefinedSettings[3] = {\n  name: 'SETTINGS_MAX_CONCURRENT_STREAMS',\n  flag: false\n}; // * SETTINGS_INITIAL_WINDOW_SIZE (4):\n//   indicates the sender's initial stream window size (in bytes) for new streams.\n\ndefinedSettings[4] = {\n  name: 'SETTINGS_INITIAL_WINDOW_SIZE',\n  flag: false\n}; // * SETTINGS_MAX_FRAME_SIZE (5):\n//   indicates the maximum size of a frame the receiver will allow.\n\ndefinedSettings[5] = {\n  name: 'SETTINGS_MAX_FRAME_SIZE',\n  flag: false\n}; // [PUSH_PROMISE](https://tools.ietf.org/html/rfc7540#section-6.6)\n// ---------------------------------------------------------------\n//\n// The PUSH_PROMISE frame (type=0x5) is used to notify the peer endpoint in advance of streams the\n// sender intends to initiate.\n//\n// The PUSH_PROMISE frame defines the following flags:\n//\n// * END_PUSH_PROMISE (0x4):\n//   The END_PUSH_PROMISE bit indicates that this frame contains the entire payload necessary to\n//   provide a complete set of headers.\n\nframeTypes[0x5] = 'PUSH_PROMISE';\nframeFlags.PUSH_PROMISE = ['RESERVED1', 'RESERVED2', 'END_PUSH_PROMISE', 'PADDED'];\ntypeSpecificAttributes.PUSH_PROMISE = ['promised_stream', 'headers', 'data']; //      0                   1                   2                   3\n//      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n//     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n//     |Pad Length? (8)|\n//     +-+-------------+-----------------------------------------------+\n//     |X|                Promised-Stream-ID (31)                      |\n//     +-+-------------------------------------------------------------+\n//     |                 Header Block Fragment (*)                   ...\n//     +---------------------------------------------------------------+\n//     |                         Padding (*)                         ...\n//     +---------------------------------------------------------------+\n//\n// The PUSH_PROMISE frame includes the unsigned 31-bit identifier of\n// the stream the endpoint plans to create along with a minimal set of headers that provide\n// additional context for the stream.\n\nSerializer.PUSH_PROMISE = function writePushPromise(frame, buffers) {\n  var buffer = new Buffer(4);\n  var promised_stream = frame.promised_stream;\n  assert(0 <= promised_stream && promised_stream <= 0x7fffffff, promised_stream);\n  buffer.writeUInt32BE(promised_stream, 0);\n  buffers.push(buffer);\n  buffers.push(frame.data);\n};\n\nDeserializer.PUSH_PROMISE = function readPushPromise(buffer, frame) {\n  if (buffer.length < 4) {\n    return 'FRAME_SIZE_ERROR';\n  }\n\n  var dataOffset = 0;\n  var paddingLength = 0;\n\n  if (frame.flags.PADDED) {\n    if (buffer.length < 5) {\n      return 'FRAME_SIZE_ERROR';\n    }\n\n    paddingLength = buffer.readUInt8(dataOffset) & 0xff;\n    dataOffset = 1;\n  }\n\n  frame.promised_stream = buffer.readUInt32BE(dataOffset) & 0x7fffffff;\n  dataOffset += 4;\n\n  if (paddingLength) {\n    if (buffer.length - dataOffset < paddingLength) {\n      return 'FRAME_SIZE_ERROR';\n    }\n\n    frame.data = buffer.slice(dataOffset, -1 * paddingLength);\n  } else {\n    frame.data = buffer.slice(dataOffset);\n  }\n}; // [PING](https://tools.ietf.org/html/rfc7540#section-6.7)\n// -----------------------------------------------\n//\n// The PING frame (type=0x6) is a mechanism for measuring a minimal round-trip time from the\n// sender, as well as determining whether an idle connection is still functional.\n//\n// The PING frame defines one type-specific flag:\n//\n// * ACK (0x1):\n//   Bit 1 being set indicates that this PING frame is a PING response.\n\n\nframeTypes[0x6] = 'PING';\nframeFlags.PING = ['ACK'];\ntypeSpecificAttributes.PING = ['data']; // In addition to the frame header, PING frames MUST contain 8 additional octets of opaque data.\n\nSerializer.PING = function writePing(frame, buffers) {\n  buffers.push(frame.data);\n};\n\nDeserializer.PING = function readPing(buffer, frame) {\n  if (buffer.length !== 8) {\n    return 'FRAME_SIZE_ERROR';\n  }\n\n  frame.data = buffer;\n}; // [GOAWAY](https://tools.ietf.org/html/rfc7540#section-6.8)\n// ---------------------------------------------------\n//\n// The GOAWAY frame (type=0x7) informs the remote peer to stop creating streams on this connection.\n//\n// The GOAWAY frame does not define any flags.\n\n\nframeTypes[0x7] = 'GOAWAY';\nframeFlags.GOAWAY = [];\ntypeSpecificAttributes.GOAWAY = ['last_stream', 'error']; //      0                   1                   2                   3\n//      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n//     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n//     |X|                  Last-Stream-ID (31)                        |\n//     +-+-------------------------------------------------------------+\n//     |                      Error Code (32)                          |\n//     +---------------------------------------------------------------+\n//\n// The last stream identifier in the GOAWAY frame contains the highest numbered stream identifier\n// for which the sender of the GOAWAY frame has received frames on and might have taken some action\n// on.\n//\n// The GOAWAY frame also contains a 32-bit error code (see Error Codes) that contains the reason for\n// closing the connection.\n\nSerializer.GOAWAY = function writeGoaway(frame, buffers) {\n  var buffer = new Buffer(8);\n  var last_stream = frame.last_stream;\n  assert(0 <= last_stream && last_stream <= 0x7fffffff, last_stream);\n  buffer.writeUInt32BE(last_stream, 0);\n  var code = errorCodes.indexOf(frame.error);\n  assert(0 <= code && code <= 0xffffffff, code);\n  buffer.writeUInt32BE(code, 4);\n  buffers.push(buffer);\n};\n\nDeserializer.GOAWAY = function readGoaway(buffer, frame) {\n  if (buffer.length !== 8) {\n    // GOAWAY must have 8 bytes\n    return 'FRAME_SIZE_ERROR';\n  }\n\n  frame.last_stream = buffer.readUInt32BE(0) & 0x7fffffff;\n  frame.error = errorCodes[buffer.readUInt32BE(4)];\n\n  if (!frame.error) {\n    // Unknown error types are to be considered equivalent to INTERNAL ERROR\n    frame.error = 'INTERNAL_ERROR';\n  }\n}; // [WINDOW_UPDATE](https://tools.ietf.org/html/rfc7540#section-6.9)\n// -----------------------------------------------------------------\n//\n// The WINDOW_UPDATE frame (type=0x8) is used to implement flow control.\n//\n// The WINDOW_UPDATE frame does not define any flags.\n\n\nframeTypes[0x8] = 'WINDOW_UPDATE';\nframeFlags.WINDOW_UPDATE = [];\ntypeSpecificAttributes.WINDOW_UPDATE = ['window_size']; // The payload of a WINDOW_UPDATE frame is a 32-bit value indicating the additional number of bytes\n// that the sender can transmit in addition to the existing flow control window. The legal range\n// for this field is 1 to 2^31 - 1 (0x7fffffff) bytes; the most significant bit of this value is\n// reserved.\n\nSerializer.WINDOW_UPDATE = function writeWindowUpdate(frame, buffers) {\n  var buffer = new Buffer(4);\n  var window_size = frame.window_size;\n  assert(0 < window_size && window_size <= 0x7fffffff, window_size);\n  buffer.writeUInt32BE(window_size, 0);\n  buffers.push(buffer);\n};\n\nDeserializer.WINDOW_UPDATE = function readWindowUpdate(buffer, frame) {\n  if (buffer.length !== WINDOW_UPDATE_PAYLOAD_SIZE) {\n    return 'FRAME_SIZE_ERROR';\n  }\n\n  frame.window_size = buffer.readUInt32BE(0) & 0x7fffffff;\n\n  if (frame.window_size === 0) {\n    return 'PROTOCOL_ERROR';\n  }\n}; // [CONTINUATION](https://tools.ietf.org/html/rfc7540#section-6.10)\n// ------------------------------------------------------------\n//\n// The CONTINUATION frame (type=0x9) is used to continue a sequence of header block fragments.\n//\n// The CONTINUATION frame defines the following flag:\n//\n// * END_HEADERS (0x4):\n//   The END_HEADERS bit indicates that this frame ends the sequence of header block fragments\n//   necessary to provide a complete set of headers.\n\n\nframeTypes[0x9] = 'CONTINUATION';\nframeFlags.CONTINUATION = ['RESERVED1', 'RESERVED2', 'END_HEADERS'];\ntypeSpecificAttributes.CONTINUATION = ['headers', 'data'];\n\nSerializer.CONTINUATION = function writeContinuation(frame, buffers) {\n  buffers.push(frame.data);\n};\n\nDeserializer.CONTINUATION = function readContinuation(buffer, frame) {\n  frame.data = buffer;\n}; // [ALTSVC](https://tools.ietf.org/html/rfc7838#section-4)\n// ------------------------------------------------------------\n//\n// The ALTSVC frame (type=0xA) advertises the availability of an alternative service to the client.\n//\n// The ALTSVC frame does not define any flags.\n\n\nframeTypes[0xA] = 'ALTSVC';\nframeFlags.ALTSVC = []; //     0                   1                   2                   3\n//     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n//    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n//    |         Origin-Len (16)       | Origin? (*)                 ...\n//    +-------------------------------+----------------+--------------+\n//    |                   Alt-Svc-Field-Value (*)                   ...\n//    +---------------------------------------------------------------+\n//\n// The ALTSVC frame contains the following fields:\n//\n// Origin-Len: An unsigned, 16-bit integer indicating the length, in\n//    octets, of the Origin field.\n//\n// Origin: An OPTIONAL sequence of characters containing ASCII\n//    serialisation of an origin ([RFC6454](https://tools.ietf.org/html/rfc6454),\n//    Section 6.2) that the alternate service is applicable to.\n//\n// Alt-Svc-Field-Value: A sequence of octets (length determined by\n//    subtracting the length of all preceding fields from the frame\n//    length) containing a value identical to the Alt-Svc field value\n//    defined in (Section 3)[https://tools.ietf.org/html/rfc7838#section-3]\n//    (ABNF production \"Alt-Svc\").\n\ntypeSpecificAttributes.ALTSVC = ['maxAge', 'port', 'protocolID', 'host', 'origin'];\n\nfunction istchar(c) {\n  return '!#$&\\'*+-.^_`|~1234567890ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'.indexOf(c) > -1;\n}\n\nfunction hexencode(s) {\n  var t = '';\n\n  for (var i = 0; i < s.length; i++) {\n    if (!istchar(s[i])) {\n      t += '%';\n      t += new Buffer(s[i]).toString('hex');\n    } else {\n      t += s[i];\n    }\n  }\n\n  return t;\n}\n\nSerializer.ALTSVC = function writeAltSvc(frame, buffers) {\n  var buffer = new Buffer(2);\n  buffer.writeUInt16BE(frame.origin.length, 0);\n  buffers.push(buffer);\n  buffers.push(new Buffer(frame.origin, 'ascii'));\n  var fieldValue = hexencode(frame.protocolID) + '=\"' + frame.host + ':' + frame.port + '\"';\n\n  if (frame.maxAge !== 86400) {\n    // 86400 is the default\n    fieldValue += \"; ma=\" + frame.maxAge;\n  }\n\n  buffers.push(new Buffer(fieldValue, 'ascii'));\n};\n\nfunction stripquotes(s) {\n  var start = 0;\n  var end = s.length;\n\n  while (start < end && s[start] === '\"') {\n    start++;\n  }\n\n  while (end > start && s[end - 1] === '\"') {\n    end--;\n  }\n\n  if (start >= end) {\n    return \"\";\n  }\n\n  return s.substring(start, end);\n}\n\nfunction splitNameValue(nvpair) {\n  var eq = -1;\n  var inQuotes = false;\n\n  for (var i = 0; i < nvpair.length; i++) {\n    if (nvpair[i] === '\"') {\n      inQuotes = !inQuotes;\n      continue;\n    }\n\n    if (inQuotes) {\n      continue;\n    }\n\n    if (nvpair[i] === '=') {\n      eq = i;\n      break;\n    }\n  }\n\n  if (eq === -1) {\n    return {\n      'name': nvpair,\n      'value': null\n    };\n  }\n\n  var name = stripquotes(nvpair.substring(0, eq).trim());\n  var value = stripquotes(nvpair.substring(eq + 1).trim());\n  return {\n    'name': name,\n    'value': value\n  };\n}\n\nfunction splitHeaderParameters(hv) {\n  return parseHeaderValue(hv, ';', splitNameValue);\n}\n\nfunction parseHeaderValue(hv, separator, callback) {\n  var start = 0;\n  var inQuotes = false;\n  var values = [];\n\n  for (var i = 0; i < hv.length; i++) {\n    if (hv[i] === '\"') {\n      inQuotes = !inQuotes;\n      continue;\n    }\n\n    if (inQuotes) {\n      // Just skip this\n      continue;\n    }\n\n    if (hv[i] === separator) {\n      var newValue = hv.substring(start, i).trim();\n\n      if (newValue.length > 0) {\n        newValue = callback(newValue);\n        values.push(newValue);\n      }\n\n      start = i + 1;\n    }\n  }\n\n  var newValue = hv.substring(start).trim();\n\n  if (newValue.length > 0) {\n    newValue = callback(newValue);\n    values.push(newValue);\n  }\n\n  return values;\n}\n\nfunction rsplit(s, delim, count) {\n  var nsplits = 0;\n  var end = s.length;\n  var rval = [];\n\n  for (var i = s.length - 1; i >= 0; i--) {\n    if (s[i] === delim) {\n      var t = s.substring(i + 1, end);\n      end = i;\n      rval.unshift(t);\n      nsplits++;\n\n      if (nsplits === count) {\n        break;\n      }\n    }\n  }\n\n  if (end !== 0) {\n    rval.unshift(s.substring(0, end));\n  }\n\n  return rval;\n}\n\nfunction ishex(c) {\n  return '0123456789ABCDEFabcdef'.indexOf(c) > -1;\n}\n\nfunction unescape(s) {\n  var i = 0;\n  var t = '';\n\n  while (i < s.length) {\n    if (s[i] != '%' || !ishex(s[i + 1]) || !ishex(s[i + 2])) {\n      t += s[i];\n    } else {\n      ++i;\n      var hexvalue = '';\n\n      if (i < s.length) {\n        hexvalue += s[i];\n        ++i;\n      }\n\n      if (i < s.length) {\n        hexvalue += s[i];\n      }\n\n      if (hexvalue.length > 0) {\n        t += new Buffer(hexvalue, 'hex').toString();\n      } else {\n        t += '%';\n      }\n    }\n\n    ++i;\n  }\n\n  return t;\n}\n\nDeserializer.ALTSVC = function readAltSvc(buffer, frame) {\n  if (buffer.length < 2) {\n    return 'FRAME_SIZE_ERROR';\n  }\n\n  var originLength = buffer.readUInt16BE(0);\n\n  if (buffer.length - 2 < originLength) {\n    return 'FRAME_SIZE_ERROR';\n  }\n\n  frame.origin = buffer.toString('ascii', 2, 2 + originLength);\n  var fieldValue = buffer.toString('ascii', 2 + originLength);\n  var values = parseHeaderValue(fieldValue, ',', splitHeaderParameters);\n\n  if (values.length > 1) {// TODO - warn that we only use one here\n  }\n\n  if (values.length === 0) {\n    // Well that's a malformed frame. Just ignore it.\n    return;\n  }\n\n  var chosenAltSvc = values[0];\n  frame.maxAge = 86400; // Default\n\n  for (var i = 0; i < chosenAltSvc.length; i++) {\n    if (i === 0) {\n      // This corresponds to the protocolID=\"<host>:<port>\" item\n      frame.protocolID = unescape(chosenAltSvc[i].name);\n      var hostport = rsplit(chosenAltSvc[i].value, ':', 1);\n      frame.host = hostport[0];\n      frame.port = parseInt(hostport[1], 10);\n    } else if (chosenAltSvc[i].name == 'ma') {\n      frame.maxAge = parseInt(chosenAltSvc[i].value, 10);\n    } // Otherwise, we just ignore this\n\n  }\n}; // BLOCKED\n// ------------------------------------------------------------\n//\n// The BLOCKED frame (type=0xB) indicates that the sender is unable to send data\n// due to a closed flow control window.\n//\n// The BLOCKED frame does not define any flags and contains no payload.\n\n\nframeTypes[0xB] = 'BLOCKED';\nframeFlags.BLOCKED = [];\ntypeSpecificAttributes.BLOCKED = [];\n\nSerializer.BLOCKED = function writeBlocked(frame, buffers) {};\n\nDeserializer.BLOCKED = function readBlocked(buffer, frame) {}; // [Error Codes](https://tools.ietf.org/html/rfc7540#section-7)\n// ------------------------------------------------------------\n\n\nvar errorCodes = ['NO_ERROR', 'PROTOCOL_ERROR', 'INTERNAL_ERROR', 'FLOW_CONTROL_ERROR', 'SETTINGS_TIMEOUT', 'STREAM_CLOSED', 'FRAME_SIZE_ERROR', 'REFUSED_STREAM', 'CANCEL', 'COMPRESSION_ERROR', 'CONNECT_ERROR', 'ENHANCE_YOUR_CALM', 'INADEQUATE_SECURITY', 'HTTP_1_1_REQUIRED']; // Logging\n// -------\n// [Bunyan serializers](https://github.com/trentm/node-bunyan#serializers) to improve logging output\n// for debug messages emitted in this component.\n\nexports.serializers = {}; // * `frame` serializer: it transforms data attributes from Buffers to hex strings and filters out\n//   flags that are not present.\n\nvar frameCounter = 0;\n\nexports.serializers.frame = function (frame) {\n  if (!frame) {\n    return null;\n  }\n\n  if ('id' in frame) {\n    return frame.id;\n  }\n\n  frame.id = frameCounter;\n  frameCounter += 1;\n  var logEntry = {\n    id: frame.id\n  };\n  genericAttributes.concat(typeSpecificAttributes[frame.type]).forEach(function (name) {\n    logEntry[name] = frame[name];\n  });\n\n  if (frame.data instanceof Buffer) {\n    if (logEntry.data.length > 50) {\n      logEntry.data = frame.data.slice(0, 47).toString('hex') + '...';\n    } else {\n      logEntry.data = frame.data.toString('hex');\n    }\n\n    if (!('length' in logEntry)) {\n      logEntry.length = frame.data.length;\n    }\n  }\n\n  if (frame.promised_stream instanceof Object) {\n    logEntry.promised_stream = 'stream-' + frame.promised_stream.id;\n  }\n\n  logEntry.flags = Object.keys(frame.flags || {}).filter(function (name) {\n    return frame.flags[name] === true;\n  });\n  return logEntry;\n}; // * `data` serializer: it simply transforms a buffer to a hex string.\n\n\nexports.serializers.data = function (data) {\n  return data.toString('hex');\n};","map":null,"metadata":{},"sourceType":"script"}