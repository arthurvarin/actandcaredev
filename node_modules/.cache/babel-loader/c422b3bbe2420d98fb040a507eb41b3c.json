{"ast":null,"code":"\"use strict\";\n\nmodule.exports = parse;\nparse.filename = null;\nparse.defaults = {\n  keepCase: false\n};\n\nvar tokenize = require(\"./tokenize\"),\n    Root = require(\"./root\"),\n    Type = require(\"./type\"),\n    Field = require(\"./field\"),\n    MapField = require(\"./mapfield\"),\n    OneOf = require(\"./oneof\"),\n    Enum = require(\"./enum\"),\n    Service = require(\"./service\"),\n    Method = require(\"./method\"),\n    types = require(\"./types\"),\n    util = require(\"./util\");\n\nvar base10Re = /^[1-9][0-9]*$/,\n    base10NegRe = /^-?[1-9][0-9]*$/,\n    base16Re = /^0[x][0-9a-fA-F]+$/,\n    base16NegRe = /^-?0[x][0-9a-fA-F]+$/,\n    base8Re = /^0[0-7]+$/,\n    base8NegRe = /^-?0[0-7]+$/,\n    numberRe = /^(?![eE])[0-9]*(?:\\.[0-9]*)?(?:[eE][+-]?[0-9]+)?$/,\n    nameRe = /^[a-zA-Z_][a-zA-Z_0-9]*$/,\n    typeRefRe = /^(?:\\.?[a-zA-Z_][a-zA-Z_0-9]*)(?:\\.[a-zA-Z_][a-zA-Z_0-9]*)*$/,\n    fqTypeRefRe = /^(?:\\.[a-zA-Z_][a-zA-Z_0-9]*)+$/;\n/**\r\n * Result object returned from {@link parse}.\r\n * @interface IParserResult\r\n * @property {string|undefined} package Package name, if declared\r\n * @property {string[]|undefined} imports Imports, if any\r\n * @property {string[]|undefined} weakImports Weak imports, if any\r\n * @property {string|undefined} syntax Syntax, if specified (either `\"proto2\"` or `\"proto3\"`)\r\n * @property {Root} root Populated root instance\r\n */\n\n/**\r\n * Options modifying the behavior of {@link parse}.\r\n * @interface IParseOptions\r\n * @property {boolean} [keepCase=false] Keeps field casing instead of converting to camel case\r\n * @property {boolean} [alternateCommentMode=false] Recognize double-slash comments in addition to doc-block comments.\r\n */\n\n/**\r\n * Options modifying the behavior of JSON serialization.\r\n * @interface IToJSONOptions\r\n * @property {boolean} [keepComments=false] Serializes comments.\r\n */\n\n/**\r\n * Parses the given .proto source and returns an object with the parsed contents.\r\n * @param {string} source Source contents\r\n * @param {Root} root Root to populate\r\n * @param {IParseOptions} [options] Parse options. Defaults to {@link parse.defaults} when omitted.\r\n * @returns {IParserResult} Parser result\r\n * @property {string} filename=null Currently processing file name for error reporting, if known\r\n * @property {IParseOptions} defaults Default {@link IParseOptions}\r\n */\n\nfunction parse(source, root, options) {\n  /* eslint-disable callback-return */\n  if (!(root instanceof Root)) {\n    options = root;\n    root = new Root();\n  }\n\n  if (!options) options = parse.defaults;\n  var tn = tokenize(source, options.alternateCommentMode || false),\n      next = tn.next,\n      push = tn.push,\n      peek = tn.peek,\n      skip = tn.skip,\n      cmnt = tn.cmnt;\n  var head = true,\n      pkg,\n      imports,\n      weakImports,\n      syntax,\n      isProto3 = false;\n  var ptr = root;\n  var applyCase = options.keepCase ? function (name) {\n    return name;\n  } : util.camelCase;\n  /* istanbul ignore next */\n\n  function illegal(token, name, insideTryCatch) {\n    var filename = parse.filename;\n    if (!insideTryCatch) parse.filename = null;\n    return Error(\"illegal \" + (name || \"token\") + \" '\" + token + \"' (\" + (filename ? filename + \", \" : \"\") + \"line \" + tn.line + \")\");\n  }\n\n  function readString() {\n    var values = [],\n        token;\n\n    do {\n      /* istanbul ignore if */\n      if ((token = next()) !== \"\\\"\" && token !== \"'\") throw illegal(token);\n      values.push(next());\n      skip(token);\n      token = peek();\n    } while (token === \"\\\"\" || token === \"'\");\n\n    return values.join(\"\");\n  }\n\n  function readValue(acceptTypeRef) {\n    var token = next();\n\n    switch (token) {\n      case \"'\":\n      case \"\\\"\":\n        push(token);\n        return readString();\n\n      case \"true\":\n      case \"TRUE\":\n        return true;\n\n      case \"false\":\n      case \"FALSE\":\n        return false;\n    }\n\n    try {\n      return parseNumber(token,\n      /* insideTryCatch */\n      true);\n    } catch (e) {\n      /* istanbul ignore else */\n      if (acceptTypeRef && typeRefRe.test(token)) return token;\n      /* istanbul ignore next */\n\n      throw illegal(token, \"value\");\n    }\n  }\n\n  function readRanges(target, acceptStrings) {\n    var token, start;\n\n    do {\n      if (acceptStrings && ((token = peek()) === \"\\\"\" || token === \"'\")) target.push(readString());else target.push([start = parseId(next()), skip(\"to\", true) ? parseId(next()) : start]);\n    } while (skip(\",\", true));\n\n    skip(\";\");\n  }\n\n  function parseNumber(token, insideTryCatch) {\n    var sign = 1;\n\n    if (token.charAt(0) === \"-\") {\n      sign = -1;\n      token = token.substring(1);\n    }\n\n    switch (token) {\n      case \"inf\":\n      case \"INF\":\n      case \"Inf\":\n        return sign * Infinity;\n\n      case \"nan\":\n      case \"NAN\":\n      case \"Nan\":\n      case \"NaN\":\n        return NaN;\n\n      case \"0\":\n        return 0;\n    }\n\n    if (base10Re.test(token)) return sign * parseInt(token, 10);\n    if (base16Re.test(token)) return sign * parseInt(token, 16);\n    if (base8Re.test(token)) return sign * parseInt(token, 8);\n    /* istanbul ignore else */\n\n    if (numberRe.test(token)) return sign * parseFloat(token);\n    /* istanbul ignore next */\n\n    throw illegal(token, \"number\", insideTryCatch);\n  }\n\n  function parseId(token, acceptNegative) {\n    switch (token) {\n      case \"max\":\n      case \"MAX\":\n      case \"Max\":\n        return 536870911;\n\n      case \"0\":\n        return 0;\n    }\n    /* istanbul ignore if */\n\n\n    if (!acceptNegative && token.charAt(0) === \"-\") throw illegal(token, \"id\");\n    if (base10NegRe.test(token)) return parseInt(token, 10);\n    if (base16NegRe.test(token)) return parseInt(token, 16);\n    /* istanbul ignore else */\n\n    if (base8NegRe.test(token)) return parseInt(token, 8);\n    /* istanbul ignore next */\n\n    throw illegal(token, \"id\");\n  }\n\n  function parsePackage() {\n    /* istanbul ignore if */\n    if (pkg !== undefined) throw illegal(\"package\");\n    pkg = next();\n    /* istanbul ignore if */\n\n    if (!typeRefRe.test(pkg)) throw illegal(pkg, \"name\");\n    ptr = ptr.define(pkg);\n    skip(\";\");\n  }\n\n  function parseImport() {\n    var token = peek();\n    var whichImports;\n\n    switch (token) {\n      case \"weak\":\n        whichImports = weakImports || (weakImports = []);\n        next();\n        break;\n\n      case \"public\":\n        next();\n      // eslint-disable-line no-fallthrough\n\n      default:\n        whichImports = imports || (imports = []);\n        break;\n    }\n\n    token = readString();\n    skip(\";\");\n    whichImports.push(token);\n  }\n\n  function parseSyntax() {\n    skip(\"=\");\n    syntax = readString();\n    isProto3 = syntax === \"proto3\";\n    /* istanbul ignore if */\n\n    if (!isProto3 && syntax !== \"proto2\") throw illegal(syntax, \"syntax\");\n    skip(\";\");\n  }\n\n  function parseCommon(parent, token) {\n    switch (token) {\n      case \"option\":\n        parseOption(parent, token);\n        skip(\";\");\n        return true;\n\n      case \"message\":\n        parseType(parent, token);\n        return true;\n\n      case \"enum\":\n        parseEnum(parent, token);\n        return true;\n\n      case \"service\":\n        parseService(parent, token);\n        return true;\n\n      case \"extend\":\n        parseExtension(parent, token);\n        return true;\n    }\n\n    return false;\n  }\n\n  function ifBlock(obj, fnIf, fnElse) {\n    var trailingLine = tn.line;\n\n    if (obj) {\n      obj.comment = cmnt(); // try block-type comment\n\n      obj.filename = parse.filename;\n    }\n\n    if (skip(\"{\", true)) {\n      var token;\n\n      while ((token = next()) !== \"}\") {\n        fnIf(token);\n      }\n\n      skip(\";\", true);\n    } else {\n      if (fnElse) fnElse();\n      skip(\";\");\n      if (obj && typeof obj.comment !== \"string\") obj.comment = cmnt(trailingLine); // try line-type comment if no block\n    }\n  }\n\n  function parseType(parent, token) {\n    /* istanbul ignore if */\n    if (!nameRe.test(token = next())) throw illegal(token, \"type name\");\n    var type = new Type(token);\n    ifBlock(type, function parseType_block(token) {\n      if (parseCommon(type, token)) return;\n\n      switch (token) {\n        case \"map\":\n          parseMapField(type, token);\n          break;\n\n        case \"required\":\n        case \"optional\":\n        case \"repeated\":\n          parseField(type, token);\n          break;\n\n        case \"oneof\":\n          parseOneOf(type, token);\n          break;\n\n        case \"extensions\":\n          readRanges(type.extensions || (type.extensions = []));\n          break;\n\n        case \"reserved\":\n          readRanges(type.reserved || (type.reserved = []), true);\n          break;\n\n        default:\n          /* istanbul ignore if */\n          if (!isProto3 || !typeRefRe.test(token)) throw illegal(token);\n          push(token);\n          parseField(type, \"optional\");\n          break;\n      }\n    });\n    parent.add(type);\n  }\n\n  function parseField(parent, rule, extend) {\n    var type = next();\n\n    if (type === \"group\") {\n      parseGroup(parent, rule);\n      return;\n    }\n    /* istanbul ignore if */\n\n\n    if (!typeRefRe.test(type)) throw illegal(type, \"type\");\n    var name = next();\n    /* istanbul ignore if */\n\n    if (!nameRe.test(name)) throw illegal(name, \"name\");\n    name = applyCase(name);\n    skip(\"=\");\n    var field = new Field(name, parseId(next()), type, rule, extend);\n    ifBlock(field, function parseField_block(token) {\n      /* istanbul ignore else */\n      if (token === \"option\") {\n        parseOption(field, token);\n        skip(\";\");\n      } else throw illegal(token);\n    }, function parseField_line() {\n      parseInlineOptions(field);\n    });\n    parent.add(field); // JSON defaults to packed=true if not set so we have to set packed=false explicity when\n    // parsing proto2 descriptors without the option, where applicable. This must be done for\n    // all known packable types and anything that could be an enum (= is not a basic type).\n\n    if (!isProto3 && field.repeated && (types.packed[type] !== undefined || types.basic[type] === undefined)) field.setOption(\"packed\", false,\n    /* ifNotSet */\n    true);\n  }\n\n  function parseGroup(parent, rule) {\n    var name = next();\n    /* istanbul ignore if */\n\n    if (!nameRe.test(name)) throw illegal(name, \"name\");\n    var fieldName = util.lcFirst(name);\n    if (name === fieldName) name = util.ucFirst(name);\n    skip(\"=\");\n    var id = parseId(next());\n    var type = new Type(name);\n    type.group = true;\n    var field = new Field(fieldName, id, name, rule);\n    field.filename = parse.filename;\n    ifBlock(type, function parseGroup_block(token) {\n      switch (token) {\n        case \"option\":\n          parseOption(type, token);\n          skip(\";\");\n          break;\n\n        case \"required\":\n        case \"optional\":\n        case \"repeated\":\n          parseField(type, token);\n          break;\n\n        /* istanbul ignore next */\n\n        default:\n          throw illegal(token);\n        // there are no groups with proto3 semantics\n      }\n    });\n    parent.add(type).add(field);\n  }\n\n  function parseMapField(parent) {\n    skip(\"<\");\n    var keyType = next();\n    /* istanbul ignore if */\n\n    if (types.mapKey[keyType] === undefined) throw illegal(keyType, \"type\");\n    skip(\",\");\n    var valueType = next();\n    /* istanbul ignore if */\n\n    if (!typeRefRe.test(valueType)) throw illegal(valueType, \"type\");\n    skip(\">\");\n    var name = next();\n    /* istanbul ignore if */\n\n    if (!nameRe.test(name)) throw illegal(name, \"name\");\n    skip(\"=\");\n    var field = new MapField(applyCase(name), parseId(next()), keyType, valueType);\n    ifBlock(field, function parseMapField_block(token) {\n      /* istanbul ignore else */\n      if (token === \"option\") {\n        parseOption(field, token);\n        skip(\";\");\n      } else throw illegal(token);\n    }, function parseMapField_line() {\n      parseInlineOptions(field);\n    });\n    parent.add(field);\n  }\n\n  function parseOneOf(parent, token) {\n    /* istanbul ignore if */\n    if (!nameRe.test(token = next())) throw illegal(token, \"name\");\n    var oneof = new OneOf(applyCase(token));\n    ifBlock(oneof, function parseOneOf_block(token) {\n      if (token === \"option\") {\n        parseOption(oneof, token);\n        skip(\";\");\n      } else {\n        push(token);\n        parseField(oneof, \"optional\");\n      }\n    });\n    parent.add(oneof);\n  }\n\n  function parseEnum(parent, token) {\n    /* istanbul ignore if */\n    if (!nameRe.test(token = next())) throw illegal(token, \"name\");\n    var enm = new Enum(token);\n    ifBlock(enm, function parseEnum_block(token) {\n      switch (token) {\n        case \"option\":\n          parseOption(enm, token);\n          skip(\";\");\n          break;\n\n        case \"reserved\":\n          readRanges(enm.reserved || (enm.reserved = []), true);\n          break;\n\n        default:\n          parseEnumValue(enm, token);\n      }\n    });\n    parent.add(enm);\n  }\n\n  function parseEnumValue(parent, token) {\n    /* istanbul ignore if */\n    if (!nameRe.test(token)) throw illegal(token, \"name\");\n    skip(\"=\");\n    var value = parseId(next(), true),\n        dummy = {};\n    ifBlock(dummy, function parseEnumValue_block(token) {\n      /* istanbul ignore else */\n      if (token === \"option\") {\n        parseOption(dummy, token); // skip\n\n        skip(\";\");\n      } else throw illegal(token);\n    }, function parseEnumValue_line() {\n      parseInlineOptions(dummy); // skip\n    });\n    parent.add(token, value, dummy.comment);\n  }\n\n  function parseOption(parent, token) {\n    var isCustom = skip(\"(\", true);\n    /* istanbul ignore if */\n\n    if (!typeRefRe.test(token = next())) throw illegal(token, \"name\");\n    var name = token;\n\n    if (isCustom) {\n      skip(\")\");\n      name = \"(\" + name + \")\";\n      token = peek();\n\n      if (fqTypeRefRe.test(token)) {\n        name += token;\n        next();\n      }\n    }\n\n    skip(\"=\");\n    parseOptionValue(parent, name);\n  }\n\n  function parseOptionValue(parent, name) {\n    if (skip(\"{\", true)) {\n      // { a: \"foo\" b { c: \"bar\" } }\n      do {\n        /* istanbul ignore if */\n        if (!nameRe.test(token = next())) throw illegal(token, \"name\");\n        if (peek() === \"{\") parseOptionValue(parent, name + \".\" + token);else {\n          skip(\":\");\n          if (peek() === \"{\") parseOptionValue(parent, name + \".\" + token);else setOption(parent, name + \".\" + token, readValue(true));\n        }\n        skip(\",\", true);\n      } while (!skip(\"}\", true));\n    } else setOption(parent, name, readValue(true)); // Does not enforce a delimiter to be universal\n\n  }\n\n  function setOption(parent, name, value) {\n    if (parent.setOption) parent.setOption(name, value);\n  }\n\n  function parseInlineOptions(parent) {\n    if (skip(\"[\", true)) {\n      do {\n        parseOption(parent, \"option\");\n      } while (skip(\",\", true));\n\n      skip(\"]\");\n    }\n\n    return parent;\n  }\n\n  function parseService(parent, token) {\n    /* istanbul ignore if */\n    if (!nameRe.test(token = next())) throw illegal(token, \"service name\");\n    var service = new Service(token);\n    ifBlock(service, function parseService_block(token) {\n      if (parseCommon(service, token)) return;\n      /* istanbul ignore else */\n\n      if (token === \"rpc\") parseMethod(service, token);else throw illegal(token);\n    });\n    parent.add(service);\n  }\n\n  function parseMethod(parent, token) {\n    var type = token;\n    /* istanbul ignore if */\n\n    if (!nameRe.test(token = next())) throw illegal(token, \"name\");\n    var name = token,\n        requestType,\n        requestStream,\n        responseType,\n        responseStream;\n    skip(\"(\");\n    if (skip(\"stream\", true)) requestStream = true;\n    /* istanbul ignore if */\n\n    if (!typeRefRe.test(token = next())) throw illegal(token);\n    requestType = token;\n    skip(\")\");\n    skip(\"returns\");\n    skip(\"(\");\n    if (skip(\"stream\", true)) responseStream = true;\n    /* istanbul ignore if */\n\n    if (!typeRefRe.test(token = next())) throw illegal(token);\n    responseType = token;\n    skip(\")\");\n    var method = new Method(name, type, requestType, responseType, requestStream, responseStream);\n    ifBlock(method, function parseMethod_block(token) {\n      /* istanbul ignore else */\n      if (token === \"option\") {\n        parseOption(method, token);\n        skip(\";\");\n      } else throw illegal(token);\n    });\n    parent.add(method);\n  }\n\n  function parseExtension(parent, token) {\n    /* istanbul ignore if */\n    if (!typeRefRe.test(token = next())) throw illegal(token, \"reference\");\n    var reference = token;\n    ifBlock(null, function parseExtension_block(token) {\n      switch (token) {\n        case \"required\":\n        case \"repeated\":\n        case \"optional\":\n          parseField(parent, token, reference);\n          break;\n\n        default:\n          /* istanbul ignore if */\n          if (!isProto3 || !typeRefRe.test(token)) throw illegal(token);\n          push(token);\n          parseField(parent, \"optional\", reference);\n          break;\n      }\n    });\n  }\n\n  var token;\n\n  while ((token = next()) !== null) {\n    switch (token) {\n      case \"package\":\n        /* istanbul ignore if */\n        if (!head) throw illegal(token);\n        parsePackage();\n        break;\n\n      case \"import\":\n        /* istanbul ignore if */\n        if (!head) throw illegal(token);\n        parseImport();\n        break;\n\n      case \"syntax\":\n        /* istanbul ignore if */\n        if (!head) throw illegal(token);\n        parseSyntax();\n        break;\n\n      case \"option\":\n        /* istanbul ignore if */\n        if (!head) throw illegal(token);\n        parseOption(ptr, token);\n        skip(\";\");\n        break;\n\n      default:\n        /* istanbul ignore else */\n        if (parseCommon(ptr, token)) {\n          head = false;\n          continue;\n        }\n        /* istanbul ignore next */\n\n\n        throw illegal(token);\n    }\n  }\n\n  parse.filename = null;\n  return {\n    \"package\": pkg,\n    \"imports\": imports,\n    weakImports: weakImports,\n    syntax: syntax,\n    root: root\n  };\n}\n/**\r\n * Parses the given .proto source and returns an object with the parsed contents.\r\n * @name parse\r\n * @function\r\n * @param {string} source Source contents\r\n * @param {IParseOptions} [options] Parse options. Defaults to {@link parse.defaults} when omitted.\r\n * @returns {IParserResult} Parser result\r\n * @property {string} filename=null Currently processing file name for error reporting, if known\r\n * @property {IParseOptions} defaults Default {@link IParseOptions}\r\n * @variation 2\r\n */","map":null,"metadata":{},"sourceType":"script"}