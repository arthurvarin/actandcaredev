{"ast":null,"code":"\"use strict\";\n/*!\n * Copyright 2017 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nvar _classCallCheck = require(\"/Users/cvoisin/Repos/actandcaredev/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/cvoisin/Repos/actandcaredev/node_modules/@babel/runtime/helpers/createClass\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar is = require(\"is\");\n/**\n * Formats the given word as plural conditionally given the preceding number.\n *\n * @private\n */\n\n\nfunction formatPlural(num, str) {\n  return \"\".concat(num, \" \").concat(str) + (num === 1 ? '' : 's');\n}\n/**\n * Provides argument validation for the Firestore Public API. Exposes validators\n * for strings, integers, numbers, objects and functions by default and can be\n * extended to provide custom validators.\n *\n * The exported validation functions follow the naming convention is{Type} and\n * isOptional{Type}, such as \"isString\" and \"isOptionalString\".\n *\n * To register custom validators, invoke the constructor with with a mapping\n * from type names to validation functions. Validation functions return 'true'\n * for valid inputs and may throw errors with custom validation messages for\n * easier diagnosis.\n *\n * @private\n */\n\n\nvar Validator =\n/*#__PURE__*/\nfunction () {\n  /**\n   * Create a new Validator, optionally registering the custom validators as\n   * provided.\n   *\n   * @param customValidators A list of custom validators to register.\n   */\n  function Validator(customValidators) {\n    var _this = this;\n\n    _classCallCheck(this, Validator);\n\n    var validators = Object.assign({\n      function: is.function,\n      integer: function integer(value, min, max) {\n        min = is.defined(min) ? min : -Infinity;\n        max = is.defined(max) ? max : Infinity;\n\n        if (!is.integer(value)) {\n          return false;\n        }\n\n        if (value < min || value > max) {\n          throw new Error(\"Value must be within [\".concat(min, \", \").concat(max, \"] inclusive, but was: \").concat(value));\n        }\n\n        return true;\n      },\n      number: function number(value, min, max) {\n        min = is.defined(min) ? min : -Infinity;\n        max = is.defined(max) ? max : Infinity;\n\n        if (!is.number(value) || is.nan(value)) {\n          return false;\n        }\n\n        if (value < min || value > max) {\n          throw new Error(\"Value must be within [\".concat(min, \", \").concat(max, \"] inclusive, but was: \").concat(value));\n        }\n\n        return true;\n      },\n      object: is.object,\n      string: is.string,\n      boolean: is.boolean\n    }, customValidators);\n\n    var register = function register(type) {\n      var camelCase = type.substring(0, 1).toUpperCase() + type.substring(1);\n\n      _this[\"is\".concat(camelCase)] = function (argumentName) {\n        var valid = false;\n        var message = is.number(argumentName) ? \"Argument at index \".concat(argumentName, \" is not a valid \").concat(type, \".\") : \"Argument \\\"\".concat(argumentName, \"\\\" is not a valid \").concat(type, \".\");\n\n        try {\n          var _validators$type;\n\n          for (var _len = arguments.length, values = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n            values[_key - 1] = arguments[_key];\n          }\n\n          valid = (_validators$type = validators[type]).call.apply(_validators$type, [null].concat(values));\n        } catch (err) {\n          message += \" \".concat(err.message);\n        }\n\n        if (valid !== true) {\n          throw new Error(message);\n        }\n      };\n\n      _this[\"isOptional\".concat(camelCase)] = function (argumentName, value) {\n        if (is.defined(value)) {\n          this[\"is\".concat(camelCase)].apply(null, arguments);\n        }\n      };\n    };\n\n    for (var type in validators) {\n      if (validators.hasOwnProperty(type)) {\n        register(type);\n      }\n    }\n  }\n  /**\n   * Verifies that 'args' has at least 'minSize' elements.\n   *\n   * @param {string} funcName The function name to use in the error message.\n   * @param {Array.<*>} args The array (or array-like structure) to verify.\n   * @param {number} minSize The minimum number of elements to enforce.\n   * @throws if the expectation is not met.\n   * @returns {boolean} 'true' when the minimum number of elements is available.\n   */\n\n\n  _createClass(Validator, [{\n    key: \"minNumberOfArguments\",\n    value: function minNumberOfArguments(funcName, args, minSize) {\n      if (args.length < minSize) {\n        throw new Error(\"Function \\\"\".concat(funcName, \"()\\\" requires at least \") + \"\".concat(formatPlural(minSize, 'argument'), \".\"));\n      }\n\n      return true;\n    }\n    /**\n     * Verifies that 'args' has at most 'maxSize' elements.\n     *\n     * @param {string} funcName The function name to use in the error message.\n     * @param {Array.<*>} args The array (or array-like structure) to verify.\n     * @param {number} maxSize The maximum number of elements to enforce.\n     * @throws if the expectation is not met.\n     * @returns {boolean} 'true' when only the maximum number of elements is\n     * specified.\n     */\n\n  }, {\n    key: \"maxNumberOfArguments\",\n    value: function maxNumberOfArguments(funcName, args, maxSize) {\n      if (args.length > maxSize) {\n        throw new Error(\"Function \\\"\".concat(funcName, \"()\\\" accepts at most \") + \"\".concat(formatPlural(maxSize, 'argument'), \".\"));\n      }\n\n      return true;\n    }\n  }]);\n\n  return Validator;\n}();\n\nexports.Validator = Validator;\n\nfunction customObjectError(val, path) {\n  var fieldPathMessage = path ? \" (found in field \".concat(path.toString(), \")\") : '';\n\n  if (is.object(val) && val.constructor.name !== 'Object') {\n    var typeName = val.constructor.name;\n\n    switch (typeName) {\n      case 'DocumentReference':\n      case 'FieldPath':\n      case 'FieldValue':\n      case 'GeoPoint':\n      case 'Timestamp':\n        return new Error(\"Detected an object of type \\\"\".concat(typeName, \"\\\" that doesn't match the \") + \"expected instance\".concat(fieldPathMessage, \". Please ensure that the \") + 'Firestore types you are using are from the same NPM package.');\n\n      default:\n        return new Error(\"Couldn't serialize object of type \\\"\".concat(typeName, \"\\\"\").concat(fieldPathMessage, \". Firestore doesn't support JavaScript \") + 'objects with custom prototypes (i.e. objects that were created ' + 'via the \"new\" operator).');\n    }\n  } else if (!is.object(val)) {\n    throw new Error(\"Input is not a plain JavaScript object\".concat(fieldPathMessage, \".\"));\n  } else {\n    return new Error(\"Invalid use of type \\\"\".concat(typeof val, \"\\\" as a Firestore argument\").concat(fieldPathMessage, \".\"));\n  }\n}\n\nexports.customObjectError = customObjectError;\n/**\n * Create a new Validator, optionally registering the custom validators as\n * provided.\n *\n * @private\n * @param customValidators A list of custom validators to register.\n */\n\nfunction createValidator(customValidators) {\n  // This function exists to change the type of `Validator` to `any` so that\n  // consumers can call the custom validator functions.\n  return new Validator(customValidators);\n}\n\nexports.createValidator = createValidator;","map":null,"metadata":{},"sourceType":"script"}