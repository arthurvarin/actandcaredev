{"ast":null,"code":"'use strict';\n\nexports.__esModule = true;\n\nvar _getIterator2 = require('babel-runtime/core-js/get-iterator');\n\nvar _getIterator3 = _interopRequireDefault(_getIterator2);\n\nvar _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');\n\nvar _classCallCheck3 = _interopRequireDefault(_classCallCheck2);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n/**\n * A TextRenderer renders text layout objects to a graphics context.\n */\n\n\nexports.default = function (_ref) {\n  var Rect = _ref.Rect;\n  return function () {\n    function PDFRenderer(ctx) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      (0, _classCallCheck3.default)(this, PDFRenderer);\n      this.ctx = ctx;\n      this.outlineBlocks = options.outlineBlocks || false;\n      this.outlineLines = options.outlineLines || false;\n      this.outlineRuns = options.outlineRuns || false;\n      this.outlineAttachments = options.outlineAttachments || false;\n    }\n\n    PDFRenderer.prototype.render = function render(container) {\n      for (var _iterator = container.blocks, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : (0, _getIterator3.default)(_iterator);;) {\n        var _ref2;\n\n        if (_isArray) {\n          if (_i >= _iterator.length) break;\n          _ref2 = _iterator[_i++];\n        } else {\n          _i = _iterator.next();\n          if (_i.done) break;\n          _ref2 = _i.value;\n        }\n\n        var block = _ref2;\n        this.renderBlock(block);\n      }\n    };\n\n    PDFRenderer.prototype.renderBlock = function renderBlock(block) {\n      if (this.outlineBlocks) {\n        var _block$bbox = block.bbox,\n            minX = _block$bbox.minX,\n            minY = _block$bbox.minY,\n            width = _block$bbox.width,\n            height = _block$bbox.height;\n        this.ctx.rect(minX, minY, width, height).stroke();\n      }\n\n      for (var _iterator2 = block.lines, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : (0, _getIterator3.default)(_iterator2);;) {\n        var _ref3;\n\n        if (_isArray2) {\n          if (_i2 >= _iterator2.length) break;\n          _ref3 = _iterator2[_i2++];\n        } else {\n          _i2 = _iterator2.next();\n          if (_i2.done) break;\n          _ref3 = _i2.value;\n        }\n\n        var line = _ref3;\n        this.renderLine(line);\n      }\n    };\n\n    PDFRenderer.prototype.renderLine = function renderLine(line) {\n      if (this.outlineLines) {\n        this.ctx.rect(line.rect.x, line.rect.y, line.rect.width, line.rect.height).stroke();\n      }\n\n      this.ctx.save();\n      this.ctx.translate(line.rect.x, line.rect.y + line.ascent);\n\n      for (var _iterator3 = line.glyphRuns, _isArray3 = Array.isArray(_iterator3), _i3 = 0, _iterator3 = _isArray3 ? _iterator3 : (0, _getIterator3.default)(_iterator3);;) {\n        var _ref4;\n\n        if (_isArray3) {\n          if (_i3 >= _iterator3.length) break;\n          _ref4 = _iterator3[_i3++];\n        } else {\n          _i3 = _iterator3.next();\n          if (_i3.done) break;\n          _ref4 = _i3.value;\n        }\n\n        var run = _ref4;\n\n        if (run.attributes.backgroundColor) {\n          var backgroundRect = new Rect(0, -line.ascent, run.advanceWidth, line.rect.height);\n          this.renderBackground(backgroundRect, run.attributes.backgroundColor);\n        }\n\n        this.renderRun(run);\n      }\n\n      this.ctx.restore();\n      this.ctx.save();\n      this.ctx.translate(line.rect.x, line.rect.y);\n\n      for (var _iterator4 = line.decorationLines, _isArray4 = Array.isArray(_iterator4), _i4 = 0, _iterator4 = _isArray4 ? _iterator4 : (0, _getIterator3.default)(_iterator4);;) {\n        var _ref5;\n\n        if (_isArray4) {\n          if (_i4 >= _iterator4.length) break;\n          _ref5 = _iterator4[_i4++];\n        } else {\n          _i4 = _iterator4.next();\n          if (_i4.done) break;\n          _ref5 = _i4.value;\n        }\n\n        var decorationLine = _ref5;\n        this.renderDecorationLine(decorationLine);\n      }\n\n      this.ctx.restore();\n    };\n\n    PDFRenderer.prototype.renderRun = function renderRun(run) {\n      var _run$attributes = run.attributes,\n          font = _run$attributes.font,\n          fontSize = _run$attributes.fontSize,\n          color = _run$attributes.color,\n          link = _run$attributes.link;\n\n      if (this.outlineRuns) {\n        this.ctx.rect(0, 0, run.advanceWidth, run.height).stroke();\n      }\n\n      this.ctx.fillColor(color);\n\n      if (link) {\n        this.ctx.link(0, -run.height - run.descent, run.advanceWidth, run.height, link);\n      }\n\n      this.renderAttachments(run);\n\n      if (font.sbix || font.COLR && font.CPAL) {\n        this.ctx.save();\n        this.ctx.translate(0, -run.ascent);\n\n        for (var i = 0; i < run.glyphs.length; i++) {\n          var position = run.positions[i];\n          var glyph = run.glyphs[i];\n          this.ctx.save();\n          this.ctx.translate(position.xOffset, position.yOffset);\n          glyph.render(this.ctx, fontSize);\n          this.ctx.restore();\n          this.ctx.translate(position.xAdvance, position.yAdvance);\n        }\n\n        this.ctx.restore();\n      } else {\n        this.ctx.font(typeof font.name === 'string' ? font.name : font, fontSize);\n\n        this.ctx._addGlyphs(run.glyphs, run.positions, 0, 0);\n      }\n\n      this.ctx.translate(run.advanceWidth, 0);\n    };\n\n    PDFRenderer.prototype.renderBackground = function renderBackground(rect, backgroundColor) {\n      this.ctx.rect(rect.x, rect.y, rect.width, rect.height);\n      this.ctx.fill(backgroundColor);\n    };\n\n    PDFRenderer.prototype.renderAttachments = function renderAttachments(run) {\n      this.ctx.save();\n      var font = run.attributes.font;\n      var space = font.glyphForCodePoint(0x20);\n      var objectReplacement = font.glyphForCodePoint(0xfffc);\n\n      for (var i = 0; i < run.glyphs.length; i++) {\n        var position = run.positions[i];\n        var glyph = run.glyphs[i];\n        this.ctx.translate(position.xAdvance, position.yOffset);\n\n        if (glyph === objectReplacement && run.attributes.attachment) {\n          this.renderAttachment(run.attributes.attachment);\n          run.glyphs[i] = space;\n        }\n      }\n\n      this.ctx.restore();\n    };\n\n    PDFRenderer.prototype.renderAttachment = function renderAttachment(attachment) {\n      var _attachment$xOffset = attachment.xOffset,\n          xOffset = _attachment$xOffset === undefined ? 0 : _attachment$xOffset,\n          _attachment$yOffset = attachment.yOffset,\n          yOffset = _attachment$yOffset === undefined ? 0 : _attachment$yOffset;\n      this.ctx.translate(-attachment.width + xOffset, -attachment.height + yOffset);\n\n      if (this.outlineAttachments) {\n        this.ctx.rect(0, 0, attachment.width, attachment.height).stroke();\n      }\n\n      if (typeof attachment.render === 'function') {\n        this.ctx.rect(0, 0, attachment.width, attachment.height);\n        this.ctx.clip();\n        attachment.render(this.ctx);\n      } else if (attachment.image) {\n        this.ctx.image(attachment.image, 0, 0, {\n          fit: [attachment.width, attachment.height],\n          align: 'center',\n          valign: 'bottom'\n        });\n      }\n    };\n\n    PDFRenderer.prototype.renderDecorationLine = function renderDecorationLine(line) {\n      this.ctx.lineWidth(line.rect.height);\n\n      if (/dashed/.test(line.style)) {\n        this.ctx.dash(3 * line.rect.height);\n      } else if (/dotted/.test(line.style)) {\n        this.ctx.dash(line.rect.height);\n      }\n\n      if (/wavy/.test(line.style)) {\n        var dist = Math.max(2, line.rect.height);\n        var step = 1.1 * dist;\n        var stepCount = Math.floor(line.rect.width / (2 * step)); // Adjust step to fill entire width\n\n        var remainingWidth = line.rect.width - stepCount * 2 * step;\n        var adjustment = remainingWidth / stepCount / 2;\n        step += adjustment;\n        var cp1y = line.rect.y + dist;\n        var cp2y = line.rect.y - dist;\n        var x = line.rect.x;\n        this.ctx.moveTo(line.rect.x, line.rect.y);\n\n        for (var i = 0; i < stepCount; i++) {\n          this.ctx.bezierCurveTo(x + step, cp1y, x + step, cp2y, x + 2 * step, line.rect.y);\n          x += 2 * step;\n        }\n      } else {\n        this.ctx.moveTo(line.rect.x, line.rect.y);\n        this.ctx.lineTo(line.rect.maxX, line.rect.y);\n\n        if (/double/.test(line.style)) {\n          this.ctx.moveTo(line.rect.x, line.rect.y + line.rect.height * 2);\n          this.ctx.lineTo(line.rect.maxX, line.rect.y + line.rect.height * 2);\n        }\n      }\n\n      this.ctx.stroke(line.color);\n    };\n\n    return PDFRenderer;\n  }();\n};","map":null,"metadata":{},"sourceType":"script"}