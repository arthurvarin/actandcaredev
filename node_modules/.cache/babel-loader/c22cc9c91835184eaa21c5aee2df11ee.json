{"ast":null,"code":"'use strict';\n\nvar _classCallCheck = require(\"/Users/cvoisin/Repos/actandcaredev/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/cvoisin/Repos/actandcaredev/node_modules/@babel/runtime/helpers/createClass\");\n\nvar async = require('async');\n\nvar crypto = require('crypto');\n\nvar fs = require('fs');\n\nvar GoogleAuth = require('google-auth-library').GoogleAuth;\n\nvar gcpMetadata = require('gcp-metadata');\n\nvar path = require('path');\n\nvar request = require('request');\n\nvar Auth =\n/*#__PURE__*/\nfunction () {\n  function Auth(config) {\n    _classCallCheck(this, Auth);\n\n    this.authClientPromise = null;\n    this.authClient = null;\n    this.googleAuthClient = null;\n    this.config = config || {};\n    this.credentials = null;\n    this.environment = {};\n    this.jwtClient = null;\n    this.projectId = this.config.projectId;\n    this.token = this.config.token;\n  }\n\n  _createClass(Auth, [{\n    key: \"authorizeRequest\",\n    value: function authorizeRequest(reqOpts, callback) {\n      this.getToken(function (err, token) {\n        if (err) {\n          callback(err);\n          return;\n        }\n\n        var authorizedReqOpts = Object.assign({}, reqOpts, {\n          headers: Object.assign({}, reqOpts.headers, {\n            Authorization: \"Bearer \".concat(token)\n          })\n        });\n        callback(null, authorizedReqOpts);\n      });\n    }\n  }, {\n    key: \"getAuthClient\",\n    value: function getAuthClient(callback) {\n      var _this = this;\n\n      if (this.authClient) {\n        // This code works around an issue with context loss with async-listener.\n        // Strictly speaking, this should not be necessary as the call to\n        // authClientPromise.then(..) below would resolve to the same value.\n        // However, async-listener defaults to resuming the `then` callbacks with\n        // the context at the point of resolution rather than the context from the\n        // point where the `then` callback was added. In this case, the promise\n        // will be resolved on the very first incoming http request, and that\n        // context will become sticky (will be restored by async-listener) around\n        // the `then` callbacks for all subsequent requests.\n        //\n        // This breaks APM tools like Stackdriver Trace & others and tools like\n        // long stack traces (they will provide an incorrect stack trace).\n        //\n        // NOTE: this doesn't solve the problem generally. Any request concurrent\n        // to the first call to this function, before the promise resolves, will\n        // still lose context. We don't have a better solution at the moment :(.\n        return setImmediate(callback.bind(null, null, this.authClient));\n      }\n\n      var createAuthClientPromise = function createAuthClientPromise(resolve, reject) {\n        var config = _this.config;\n        var keyFile = config.keyFilename || config.keyFile;\n        _this.googleAuthClient = new GoogleAuth();\n\n        var addScope = function addScope(err, authClient, projectId) {\n          if (err) {\n            reject(err);\n            return;\n          }\n\n          if (authClient.createScopedRequired && authClient.createScopedRequired()) {\n            if (!config.scopes || config.scopes.length === 0) {\n              var scopeError = new Error('Scopes are required for this request.');\n              scopeError.code = 'MISSING_SCOPE';\n              reject(scopeError);\n              return;\n            }\n          }\n\n          authClient.scopes = config.scopes;\n          _this.authClient = authClient;\n          _this.projectId = config.projectId || projectId || authClient.projectId;\n\n          if (!_this.projectId) {\n            _this.googleAuthClient.getDefaultProjectId(function (err, projectId) {\n              // Ignore error, since the user might not require a project ID.\n              if (projectId) {\n                _this.projectId = projectId;\n              }\n\n              resolve(authClient);\n            });\n\n            return;\n          }\n\n          resolve(authClient);\n        };\n\n        if (config.credentials) {\n          try {\n            var client = _this.googleAuthClient.fromJSON(config.credentials);\n\n            addScope(null, client);\n          } catch (e) {\n            addScope(e);\n          }\n        } else if (keyFile) {\n          keyFile = path.resolve(process.cwd(), keyFile);\n          fs.readFile(keyFile, function (err, contents) {\n            if (err) {\n              reject(err);\n              return;\n            }\n\n            try {\n              var client = _this.googleAuthClient.fromJSON(JSON.parse(contents));\n\n              addScope(null, client);\n            } catch (e) {\n              // @TODO Find a better way to do this.\n              // Ref: https://github.com/googleapis/nodejs-storage/issues/147\n              // Ref: https://github.com/google/google-auth-library-nodejs/issues/313\n              var client = _this.googleAuthClient.fromJSON({\n                type: 'jwt-pem-p12',\n                client_email: config.email,\n                private_key: keyFile\n              });\n\n              delete client.key;\n              client.keyFile = keyFile;\n              _this.jwtClient = client;\n              addScope(null, client);\n            }\n          });\n        } else {\n          _this.googleAuthClient.getApplicationDefault(addScope);\n        }\n      };\n\n      if (!this.authClientPromise) {\n        this.authClientPromise = new Promise(createAuthClientPromise);\n      }\n\n      this.authClientPromise.then(function (authClient) {\n        callback(null, authClient); // The return null is needed to avoid a spurious warning if the user is\n        // using bluebird.\n        // See: https://github.com/stephenplusplus/google-auto-auth/issues/28\n\n        return null;\n      }).catch(callback);\n    }\n  }, {\n    key: \"getCredentials\",\n    value: function getCredentials(callback) {\n      var _this2 = this;\n\n      if (this.credentials) {\n        setImmediate(function () {\n          callback(null, _this2.credentials);\n        });\n        return;\n      }\n\n      this.getAuthClient(function (err) {\n        if (err) {\n          callback(err);\n          return;\n        }\n\n        _this2.googleAuthClient.getCredentials(function (err, credentials) {\n          if (err) {\n            callback(err);\n            return;\n          }\n\n          _this2.credentials = credentials;\n\n          if (_this2.jwtClient) {\n            _this2.jwtClient.authorize(function (err) {\n              if (err) {\n                callback(err);\n                return;\n              }\n\n              _this2.credentials.private_key = _this2.jwtClient.key;\n              callback(null, _this2.credentials);\n            });\n\n            return;\n          }\n\n          callback(null, _this2.credentials);\n        });\n      });\n    }\n  }, {\n    key: \"getEnvironment\",\n    value: function getEnvironment(callback) {\n      var _this3 = this;\n\n      async.parallel([function (cb) {\n        return _this3.isAppEngine(cb);\n      }, function (cb) {\n        return _this3.isCloudFunction(cb);\n      }, function (cb) {\n        return _this3.isComputeEngine(cb);\n      }, function (cb) {\n        return _this3.isContainerEngine(cb);\n      }], function () {\n        callback(null, _this3.environment);\n      });\n    }\n  }, {\n    key: \"getProjectId\",\n    value: function getProjectId(callback) {\n      var _this4 = this;\n\n      if (this.projectId) {\n        setImmediate(function () {\n          callback(null, _this4.projectId);\n        });\n        return;\n      }\n\n      this.getAuthClient(function (err) {\n        if (err) {\n          callback(err);\n          return;\n        }\n\n        callback(null, _this4.projectId);\n      });\n    }\n  }, {\n    key: \"getToken\",\n    value: function getToken(callback) {\n      if (this.token) {\n        setImmediate(callback, null, this.token);\n        return;\n      }\n\n      this.getAuthClient(function (err, client) {\n        if (err) {\n          callback(err);\n          return;\n        }\n\n        client.getAccessToken(callback);\n      });\n    }\n  }, {\n    key: \"isAppEngine\",\n    value: function isAppEngine(callback) {\n      var _this5 = this;\n\n      setImmediate(function () {\n        var env = _this5.environment;\n\n        if (typeof env.IS_APP_ENGINE === 'undefined') {\n          env.IS_APP_ENGINE = !!(process.env.GAE_SERVICE || process.env.GAE_MODULE_NAME);\n        }\n\n        callback(null, env.IS_APP_ENGINE);\n      });\n    }\n  }, {\n    key: \"isCloudFunction\",\n    value: function isCloudFunction(callback) {\n      var _this6 = this;\n\n      setImmediate(function () {\n        var env = _this6.environment;\n\n        if (typeof env.IS_CLOUD_FUNCTION === 'undefined') {\n          env.IS_CLOUD_FUNCTION = !!process.env.FUNCTION_NAME;\n        }\n\n        callback(null, env.IS_CLOUD_FUNCTION);\n      });\n    }\n  }, {\n    key: \"isComputeEngine\",\n    value: function isComputeEngine(callback) {\n      var env = this.environment;\n\n      if (typeof env.IS_COMPUTE_ENGINE !== 'undefined') {\n        setImmediate(function () {\n          callback(null, env.IS_COMPUTE_ENGINE);\n        });\n        return;\n      }\n\n      request('http://metadata.google.internal', function (err, res) {\n        env.IS_COMPUTE_ENGINE = !err && res.headers['metadata-flavor'] === 'Google';\n        callback(null, env.IS_COMPUTE_ENGINE);\n      });\n    }\n  }, {\n    key: \"isContainerEngine\",\n    value: function isContainerEngine(callback) {\n      var env = this.environment;\n\n      if (typeof env.IS_CONTAINER_ENGINE !== 'undefined') {\n        setImmediate(function () {\n          callback(null, env.IS_CONTAINER_ENGINE);\n        });\n        return;\n      }\n\n      gcpMetadata.instance('/attributes/cluster-name').then(function () {\n        env.IS_CONTAINER_ENGINE = true;\n        callback(null, env.IS_CONTAINER_ENGINE);\n      }).catch(function () {\n        env.IS_CONTAINER_ENGINE = false;\n        callback(null, env.IS_CONTAINER_ENGINE);\n      });\n    }\n  }, {\n    key: \"sign\",\n    value: function sign(data, callback) {\n      var _this7 = this;\n\n      this.getCredentials(function (err, credentials) {\n        if (err) {\n          callback(err);\n          return;\n        }\n\n        if (credentials.private_key) {\n          _this7._signWithPrivateKey(data, callback);\n        } else {\n          _this7._signWithApi(data, callback);\n        }\n      });\n    } // `this.getCredentials()` will always have been run by this time\n\n  }, {\n    key: \"_signWithApi\",\n    value: function _signWithApi(data, callback) {\n      if (!this.projectId) {\n        callback(new Error('Cannot sign data without a project ID.'));\n        return;\n      }\n\n      var client_email = this.credentials.client_email;\n\n      if (!client_email) {\n        callback(new Error('Cannot sign data without `client_email`.'));\n        return;\n      }\n\n      var idString = \"projects/\".concat(this.projectId, \"/serviceAccounts/\").concat(client_email);\n      var reqOpts = {\n        method: 'POST',\n        uri: \"https://iam.googleapis.com/v1/\".concat(idString, \":signBlob\"),\n        json: {\n          bytesToSign: Buffer.from(data).toString('base64')\n        }\n      };\n      this.authorizeRequest(reqOpts, function (err, authorizedReqOpts) {\n        if (err) {\n          callback(err);\n          return;\n        }\n\n        request(authorizedReqOpts, function (err, resp, body) {\n          var response = resp.toJSON();\n\n          if (!err && response.statusCode < 200 || response.statusCode >= 400) {\n            if (typeof response.body === 'object') {\n              var apiError = response.body.error;\n              err = new Error(apiError.message);\n              Object.assign(err, apiError);\n            } else {\n              err = new Error(response.body);\n              err.code = response.statusCode;\n            }\n          }\n\n          callback(err, body && body.signature);\n        });\n      });\n    } // `this.getCredentials()` will always have been run by this time\n\n  }, {\n    key: \"_signWithPrivateKey\",\n    value: function _signWithPrivateKey(data, callback) {\n      var sign = crypto.createSign('RSA-SHA256');\n      sign.update(data);\n      callback(null, sign.sign(this.credentials.private_key, 'base64'));\n    }\n  }]);\n\n  return Auth;\n}();\n\nmodule.exports = function (config) {\n  return new Auth(config);\n};","map":null,"metadata":{},"sourceType":"script"}