{"ast":null,"code":"/**\n * Copyright 2014 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/*!\n * @module common/util\n */\n'use strict';\n\nvar createErrorClass = require('create-error-class');\n\nvar duplexify = require('duplexify');\n\nvar ent = require('ent');\n\nvar extend = require('extend');\n\nvar googleAuth = require('google-auto-auth');\n\nvar is = require('is');\n\nvar request = require('request').defaults({\n  timeout: 60000,\n  gzip: true,\n  forever: true,\n  pool: {\n    maxSockets: Infinity\n  }\n});\n\nvar retryRequest = require('retry-request');\n\nvar streamEvents = require('stream-events');\n\nvar through = require('through2');\n\nvar uniq = require('array-uniq');\n\nvar util = module.exports;\n/**\n * Custom error type for missing project ID errors.\n */\n\nutil.MissingProjectIdError = createErrorClass('MissingProjectIdError', function () {\n  this.message = \"Sorry, we cannot connect to Cloud Services without a project\\n    ID. You may specify one with an environment variable named\\n    \\\"GOOGLE_CLOUD_PROJECT\\\".\".replace(/ +/g, ' ');\n});\n/**\n * No op.\n *\n * @example\n * function doSomething(callback) {\n *   callback = callback || noop;\n * }\n */\n\nfunction noop() {}\n\nutil.noop = noop;\n/**\n * Custom error type for API errors.\n *\n * @param {object} errorBody - Error object.\n */\n\nutil.ApiError = createErrorClass('ApiError', function (errorBody) {\n  this.code = errorBody.code;\n  this.errors = errorBody.errors;\n  this.response = errorBody.response;\n\n  try {\n    this.errors = JSON.parse(this.response.body).error.errors;\n  } catch (e) {\n    this.errors = errorBody.errors;\n  }\n\n  var messages = [];\n\n  if (errorBody.message) {\n    messages.push(errorBody.message);\n  }\n\n  if (this.errors && this.errors.length === 1) {\n    messages.push(this.errors[0].message);\n  } else if (this.response && this.response.body) {\n    messages.push(ent.decode(errorBody.response.body.toString()));\n  } else if (!errorBody.message) {\n    messages.push('Error during request.');\n  }\n\n  this.message = uniq(messages).join(' - ');\n});\n/**\n * Custom error type for partial errors returned from the API.\n *\n * @param {object} b - Error object.\n */\n\nutil.PartialFailureError = createErrorClass('PartialFailureError', function (b) {\n  var errorObject = b;\n  this.errors = errorObject.errors;\n  this.response = errorObject.response;\n  var defaultErrorMessage = 'A failure occurred during this request.';\n  this.message = errorObject.message || defaultErrorMessage;\n});\n/**\n * Uniformly process an API response.\n *\n * @param {*} err - Error value.\n * @param {*} resp - Response value.\n * @param {*} body - Body value.\n * @param {function} callback - The callback function.\n */\n\nfunction handleResp(err, resp, body, callback) {\n  callback = callback || util.noop;\n  var parsedResp = extend(true, {\n    err: err || null\n  }, resp && util.parseHttpRespMessage(resp), body && util.parseHttpRespBody(body));\n  callback(parsedResp.err, parsedResp.body, parsedResp.resp);\n}\n\nutil.handleResp = handleResp;\n/**\n * Sniff an incoming HTTP response message for errors.\n *\n * @param {object} httpRespMessage - An incoming HTTP response message from\n *     `request`.\n * @return {object} parsedHttpRespMessage - The parsed response.\n * @param {?error} parsedHttpRespMessage.err - An error detected.\n * @param {object} parsedHttpRespMessage.resp - The original response object.\n */\n\nfunction parseHttpRespMessage(httpRespMessage) {\n  var parsedHttpRespMessage = {\n    resp: httpRespMessage\n  };\n\n  if (httpRespMessage.statusCode < 200 || httpRespMessage.statusCode > 299) {\n    // Unknown error. Format according to ApiError standard.\n    parsedHttpRespMessage.err = new util.ApiError({\n      errors: [],\n      code: httpRespMessage.statusCode,\n      message: httpRespMessage.statusMessage,\n      response: httpRespMessage\n    });\n  }\n\n  return parsedHttpRespMessage;\n}\n\nutil.parseHttpRespMessage = parseHttpRespMessage;\n/**\n * Parse the response body from an HTTP request.\n *\n * @param {object} body - The response body.\n * @return {object} parsedHttpRespMessage - The parsed response.\n * @param {?error} parsedHttpRespMessage.err - An error detected.\n * @param {object} parsedHttpRespMessage.body - The original body value provided\n *     will try to be JSON.parse'd. If it's successful, the parsed value will be\n *     returned here, otherwise the original value.\n */\n\nfunction parseHttpRespBody(body) {\n  var parsedHttpRespBody = {\n    body: body\n  };\n\n  if (is.string(body)) {\n    try {\n      parsedHttpRespBody.body = JSON.parse(body);\n    } catch (err) {\n      parsedHttpRespBody.err = new util.ApiError('Cannot parse JSON response');\n    }\n  }\n\n  if (parsedHttpRespBody.body && parsedHttpRespBody.body.error) {\n    // Error from JSON API.\n    parsedHttpRespBody.err = new util.ApiError(parsedHttpRespBody.body.error);\n  }\n\n  return parsedHttpRespBody;\n}\n\nutil.parseHttpRespBody = parseHttpRespBody;\n/**\n * Take a Duplexify stream, fetch an authenticated connection header, and create\n * an outgoing writable stream.\n *\n * @param {Duplexify} dup - Duplexify stream.\n * @param {object} options - Configuration object.\n * @param {module:common/connection} options.connection - A connection instance,\n *     used to get a token with and send the request through.\n * @param {object} options.metadata - Metadata to send at the head of the\n *     request.\n * @param {object} options.request - Request object, in the format of a standard\n *     Node.js http.request() object.\n * @param {string=} options.request.method - Default: \"POST\".\n * @param {string=} options.request.qs.uploadType - Default: \"multipart\".\n * @param {string=} options.streamContentType - Default:\n *     \"application/octet-stream\".\n * @param {function} onComplete - Callback, executed after the writable Request\n *     stream has completed.\n */\n\nfunction makeWritableStream(dup, options, onComplete) {\n  onComplete = onComplete || util.noop;\n  var writeStream = through();\n  dup.setWritable(writeStream);\n  var defaultReqOpts = {\n    method: 'POST',\n    qs: {\n      uploadType: 'multipart'\n    }\n  };\n  var metadata = options.metadata || {};\n  var reqOpts = extend(true, defaultReqOpts, options.request, {\n    multipart: [{\n      'Content-Type': 'application/json',\n      body: JSON.stringify(metadata)\n    }, {\n      'Content-Type': metadata.contentType || 'application/octet-stream',\n      body: writeStream\n    }]\n  });\n  options.makeAuthenticatedRequest(reqOpts, {\n    onAuthenticated: function onAuthenticated(err, authenticatedReqOpts) {\n      if (err) {\n        dup.destroy(err);\n        return;\n      }\n\n      request(authenticatedReqOpts, function (err, resp, body) {\n        util.handleResp(err, resp, body, function (err, data) {\n          if (err) {\n            dup.destroy(err);\n            return;\n          }\n\n          dup.emit('response', resp);\n          onComplete(data);\n        });\n      });\n    }\n  });\n}\n\nutil.makeWritableStream = makeWritableStream;\n/**\n * Returns true if the API request should be retried, given the error that was\n * given the first time the request was attempted. This is used for rate limit\n * related errors as well as intermittent server errors.\n *\n * @param {error} err - The API error to check if it is appropriate to retry.\n * @return {boolean} True if the API request should be retried, false otherwise.\n */\n\nfunction shouldRetryRequest(err) {\n  if (err) {\n    if ([429, 500, 502, 503].indexOf(err.code) !== -1) {\n      return true;\n    }\n\n    if (err.errors) {\n      for (var i in err.errors) {\n        var reason = err.errors[i].reason;\n\n        if (reason === 'rateLimitExceeded') {\n          return true;\n        }\n\n        if (reason === 'userRateLimitExceeded') {\n          return true;\n        }\n      }\n    }\n  }\n\n  return false;\n}\n\nutil.shouldRetryRequest = shouldRetryRequest;\n/**\n * Get a function for making authenticated requests.\n *\n * @throws {Error} If a projectId is requested, but not able to be detected.\n *\n * @param {object} config - Configuration object.\n * @param {boolean=} config.autoRetry - Automatically retry requests if the\n *     response is related to rate limits or certain intermittent server errors.\n *     We will exponentially backoff subsequent requests by default. (default:\n *     true)\n * @param {object=} config.credentials - Credentials object.\n * @param {boolean=} config.customEndpoint - If true, just return the provided\n *     request options. Default: false.\n * @param {string=} config.email - Account email address, required for PEM/P12\n *     usage.\n * @param {number=} config.maxRetries - Maximum number of automatic retries\n *     attempted before returning the error. (default: 3)\n * @param {string=} config.keyFile - Path to a .json, .pem, or .p12 keyfile.\n * @param {array} config.scopes - Array of scopes required for the API.\n */\n\nfunction makeAuthenticatedRequestFactory(config) {\n  config = config || {};\n  var googleAutoAuthConfig = extend({}, config);\n\n  if (googleAutoAuthConfig.projectId === '{{projectId}}') {\n    delete googleAutoAuthConfig.projectId;\n  }\n\n  var authClient = googleAuth(googleAutoAuthConfig);\n  /**\n   * The returned function that will make an authenticated request.\n   *\n   * @param {type} reqOpts - Request options in the format `request` expects.\n   * @param {object|function} options - Configuration object or callback\n   *     function.\n   * @param {function=} options.onAuthenticated - If provided, a request will\n   *     not be made. Instead, this function is passed the error & authenticated\n   *     request options.\n   */\n\n  function makeAuthenticatedRequest(reqOpts, options) {\n    var stream;\n    var reqConfig = extend({}, config);\n    var activeRequest_;\n\n    if (!options) {\n      stream = duplexify();\n      reqConfig.stream = stream;\n    }\n\n    function onAuthenticated(err, authenticatedReqOpts) {\n      var autoAuthFailed = err && err.message.indexOf('Could not load the default credentials') > -1;\n\n      if (autoAuthFailed) {\n        // Even though authentication failed, the API might not actually care.\n        authenticatedReqOpts = reqOpts;\n      }\n\n      if (!err || autoAuthFailed) {\n        var projectId = authClient.projectId;\n\n        if (config.projectId && config.projectId !== '{{projectId}}') {\n          projectId = config.projectId;\n        }\n\n        try {\n          authenticatedReqOpts = util.decorateRequest(authenticatedReqOpts, projectId);\n          err = null;\n        } catch (e) {\n          // A projectId was required, but we don't have one.\n          // Re-use the \"Could not load the default credentials error\" if auto\n          // auth failed.\n          err = err || e;\n        }\n      }\n\n      if (err) {\n        if (stream) {\n          stream.destroy(err);\n        } else {\n          (options.onAuthenticated || options)(err);\n        }\n\n        return;\n      }\n\n      if (options && options.onAuthenticated) {\n        options.onAuthenticated(null, authenticatedReqOpts);\n      } else {\n        activeRequest_ = util.makeRequest(authenticatedReqOpts, reqConfig, options);\n      }\n    }\n\n    if (reqConfig.customEndpoint) {\n      // Using a custom API override. Do not use `google-auto-auth` for\n      // authentication. (ex: connecting to a local Datastore server)\n      onAuthenticated(null, reqOpts);\n    } else {\n      authClient.authorizeRequest(reqOpts, onAuthenticated);\n    }\n\n    if (stream) {\n      return stream;\n    }\n\n    return {\n      abort: function abort() {\n        if (activeRequest_) {\n          activeRequest_.abort();\n          activeRequest_ = null;\n        }\n      }\n    };\n  }\n\n  makeAuthenticatedRequest.getCredentials = authClient.getCredentials.bind(authClient);\n  makeAuthenticatedRequest.authClient = authClient;\n  return makeAuthenticatedRequest;\n}\n\nutil.makeAuthenticatedRequestFactory = makeAuthenticatedRequestFactory;\n/**\n * Make a request through the `retryRequest` module with built-in error handling\n * and exponential back off.\n *\n * @param {object} reqOpts - Request options in the format `request` expects.\n * @param {object=} config - Configuration object.\n * @param {boolean=} config.autoRetry - Automatically retry requests if the\n *     response is related to rate limits or certain intermittent server errors.\n *     We will exponentially backoff subsequent requests by default. (default:\n *     true)\n * @param {number=} config.maxRetries - Maximum number of automatic retries\n *     attempted before returning the error. (default: 3)\n * @param {function} callback - The callback function.\n */\n\nfunction makeRequest(reqOpts, config, callback) {\n  if (is.fn(config)) {\n    callback = config;\n    config = {};\n  }\n\n  config = config || {};\n  var options = {\n    request: request,\n    retries: config.autoRetry !== false ? config.maxRetries || 3 : 0,\n    shouldRetryFn: function shouldRetryFn(httpRespMessage) {\n      var err = util.parseHttpRespMessage(httpRespMessage).err;\n      return err && util.shouldRetryRequest(err);\n    }\n  };\n\n  if (config.stream) {\n    var dup = config.stream;\n    var requestStream;\n    var isGetRequest = (reqOpts.method || 'GET').toUpperCase() === 'GET';\n\n    if (isGetRequest) {\n      requestStream = retryRequest(reqOpts, options);\n      dup.setReadable(requestStream);\n    } else {\n      // Streaming writable HTTP requests cannot be retried.\n      requestStream = request(reqOpts);\n      dup.setWritable(requestStream);\n    } // Replay the Request events back to the stream.\n\n\n    requestStream.on('error', dup.destroy.bind(dup)).on('response', dup.emit.bind(dup, 'response')).on('complete', dup.emit.bind(dup, 'complete'));\n    dup.abort = requestStream.abort;\n  } else {\n    return retryRequest(reqOpts, options, function (err, response, body) {\n      util.handleResp(err, response, body, callback);\n    });\n  }\n}\n\nutil.makeRequest = makeRequest;\n/**\n * Decorate the options about to be made in a request.\n *\n * @param {object} reqOpts - The options to be passed to `request`.\n * @param {string} projectId - The project ID.\n * @return {object} reqOpts - The decorated reqOpts.\n */\n\nfunction decorateRequest(reqOpts, projectId) {\n  delete reqOpts.autoPaginate;\n  delete reqOpts.autoPaginateVal;\n  delete reqOpts.objectMode;\n\n  if (is.object(reqOpts.qs)) {\n    delete reqOpts.qs.autoPaginate;\n    delete reqOpts.qs.autoPaginateVal;\n    reqOpts.qs = util.replaceProjectIdToken(reqOpts.qs, projectId);\n  }\n\n  if (is.object(reqOpts.json)) {\n    delete reqOpts.json.autoPaginate;\n    delete reqOpts.json.autoPaginateVal;\n    reqOpts.json = util.replaceProjectIdToken(reqOpts.json, projectId);\n  }\n\n  reqOpts.uri = util.replaceProjectIdToken(reqOpts.uri, projectId);\n  return reqOpts;\n}\n\nutil.decorateRequest = decorateRequest;\n/**\n * Populate the `{{projectId}}` placeholder.\n *\n * @throws {Error} If a projectId is required, but one is not provided.\n *\n * @param {*} - Any input value that may contain a placeholder. Arrays and\n *     objects will be looped.\n * @param {string} projectId - A projectId. If not provided\n * @return {*} - The original argument with all placeholders populated.\n */\n\nfunction replaceProjectIdToken(value, projectId) {\n  if (is.array(value)) {\n    value = value.map(function (val) {\n      return replaceProjectIdToken(val, projectId);\n    });\n  }\n\n  if (is.object(value) && is.fn(value.hasOwnProperty)) {\n    for (var opt in value) {\n      if (value.hasOwnProperty(opt)) {\n        value[opt] = replaceProjectIdToken(value[opt], projectId);\n      }\n    }\n  }\n\n  if (is.string(value) && value.indexOf('{{projectId}}') > -1) {\n    if (!projectId || projectId === '{{projectId}}') {\n      throw new util.MissingProjectIdError();\n    }\n\n    value = value.replace(/{{projectId}}/g, projectId);\n  }\n\n  return value;\n}\n\nutil.replaceProjectIdToken = replaceProjectIdToken;\n/**\n * Extend a global configuration object with user options provided at the time\n * of sub-module instantiation.\n *\n * Connection details currently come in two ways: `credentials` or\n * `keyFilename`. Because of this, we have a special exception when overriding a\n * global configuration object. If a user provides either to the global\n * configuration, then provides another at submodule instantiation-time, the\n * latter is preferred.\n *\n * @param  {object} globalConfig - The global configuration object.\n * @param  {object=} overrides - The instantiation-time configuration object.\n * @return {object}\n */\n\nfunction extendGlobalConfig(globalConfig, overrides) {\n  globalConfig = globalConfig || {};\n  overrides = overrides || {};\n  var defaultConfig = {};\n\n  if (process.env.GCLOUD_PROJECT) {\n    defaultConfig.projectId = process.env.GCLOUD_PROJECT;\n  }\n\n  var options = extend({}, globalConfig);\n  var hasGlobalConnection = options.credentials || options.keyFilename;\n  var isOverridingConnection = overrides.credentials || overrides.keyFilename;\n\n  if (hasGlobalConnection && isOverridingConnection) {\n    delete options.credentials;\n    delete options.keyFilename;\n  }\n\n  var extendedConfig = extend(true, defaultConfig, options, overrides); // Preserve the original (not cloned) interceptors.\n\n  extendedConfig.interceptors_ = globalConfig.interceptors_;\n  return extendedConfig;\n}\n\nutil.extendGlobalConfig = extendGlobalConfig;\n/**\n * Merge and validate API configurations.\n *\n * @param {object} globalContext - gcloud-level context.\n * @param {object} globalContext.config_ - gcloud-level configuration.\n * @param {object} localConfig - Service-level configurations.\n * @return {object} config - Merged and validated configuration.\n */\n\nfunction normalizeArguments(globalContext, localConfig) {\n  var globalConfig = globalContext && globalContext.config_;\n  return util.extendGlobalConfig(globalConfig, localConfig);\n}\n\nutil.normalizeArguments = normalizeArguments;\n/**\n * Limit requests according to a `maxApiCalls` limit.\n *\n * @param {function} makeRequestFn - The function that will be called.\n * @param {object=} options - Configuration object.\n * @param {number} options.maxApiCalls - The maximum number of API calls to\n *     make.\n * @param {object} options.streamOptions - Options to pass to the Stream\n *     constructor.\n */\n\nfunction createLimiter(makeRequestFn, options) {\n  options = options || {};\n  var stream = streamEvents(through.obj(options.streamOptions));\n  var requestsMade = 0;\n  var requestsToMake = -1;\n\n  if (is.number(options.maxApiCalls)) {\n    requestsToMake = options.maxApiCalls;\n  }\n\n  return {\n    makeRequest: function makeRequest() {\n      requestsMade++;\n\n      if (requestsToMake >= 0 && requestsMade > requestsToMake) {\n        stream.push(null);\n        return;\n      }\n\n      makeRequestFn.apply(null, arguments);\n      return stream;\n    },\n    stream: stream\n  };\n}\n\nutil.createLimiter = createLimiter;\n\nfunction isCustomType(unknown, module) {\n  function getConstructorName(obj) {\n    return obj.constructor && obj.constructor.name.toLowerCase();\n  }\n\n  var moduleNameParts = module.split('/');\n  var parentModuleName = moduleNameParts[0] && moduleNameParts[0].toLowerCase();\n  var subModuleName = moduleNameParts[1] && moduleNameParts[1].toLowerCase();\n\n  if (subModuleName && getConstructorName(unknown) !== subModuleName) {\n    return false;\n  }\n\n  var walkingModule = unknown;\n\n  do {\n    if (getConstructorName(walkingModule) === parentModuleName) {\n      return true;\n    }\n  } while (walkingModule = walkingModule.parent);\n\n  return false;\n}\n\nutil.isCustomType = isCustomType;\n/**\n * Create a properly-formatted User-Agent string from a package.json file.\n *\n * @param {object} packageJson - A module's package.json file.\n * @return {string} userAgent - The formatted User-Agent string.\n */\n\nfunction getUserAgentFromPackageJson(packageJson) {\n  var hyphenatedPackageName = packageJson.name.replace('@google-cloud', 'gcloud-node') // For legacy purposes.\n  .replace('/', '-'); // For UA spec-compliance purposes.\n\n  return hyphenatedPackageName + '/' + packageJson.version;\n}\n\nutil.getUserAgentFromPackageJson = getUserAgentFromPackageJson;\n/**\n * Wraps a callback style function to conditionally return a promise.\n *\n * @param {function} originalMethod - The method to promisify.\n * @param {object=} options - Promise options.\n * @param {boolean} options.singular - Resolve the promise with single arg\n *     instead of an array.\n * @return {function} wrapped\n */\n\nfunction promisify(originalMethod, options) {\n  if (originalMethod.promisified_) {\n    return originalMethod;\n  }\n\n  options = options || {};\n  var slice = Array.prototype.slice;\n\n  var wrapper = function wrapper() {\n    var context = this;\n    var last;\n\n    for (last = arguments.length - 1; last >= 0; last--) {\n      var arg = arguments[last];\n\n      if (is.undefined(arg)) {\n        continue; // skip trailing undefined.\n      }\n\n      if (!is.fn(arg)) {\n        break; // non-callback last argument found.\n      }\n\n      return originalMethod.apply(context, arguments);\n    } // peel trailing undefined.\n\n\n    var args = slice.call(arguments, 0, last + 1);\n    var PromiseCtor = Promise; // Because dedupe will likely create a single install of\n    // @google-cloud/common to be shared amongst all modules, we need to\n    // localize it at the Service level.\n\n    if (context && context.Promise) {\n      PromiseCtor = context.Promise;\n    }\n\n    return new PromiseCtor(function (resolve, reject) {\n      args.push(function () {\n        var callbackArgs = slice.call(arguments);\n        var err = callbackArgs.shift();\n\n        if (err) {\n          return reject(err);\n        }\n\n        if (options.singular && callbackArgs.length === 1) {\n          resolve(callbackArgs[0]);\n        } else {\n          resolve(callbackArgs);\n        }\n      });\n      originalMethod.apply(context, args);\n    });\n  };\n\n  wrapper.promisified_ = true;\n  return wrapper;\n}\n\nutil.promisify = promisify;\n/**\n * Promisifies certain Class methods. This will not promisify private or\n * streaming methods.\n *\n * @param {module:common/service} Class - Service class.\n * @param {object=} options - Configuration object.\n */\n\nfunction promisifyAll(Class, options) {\n  var exclude = options && options.exclude || [];\n  var methods = Object.keys(Class.prototype).filter(function (methodName) {\n    return is.fn(Class.prototype[methodName]) && // is it a function?\n    !/(^_|(Stream|_)|promise$)/.test(methodName) && // is it promisable?\n    exclude.indexOf(methodName) === -1; // is it blacklisted?\n  });\n  methods.forEach(function (methodName) {\n    var originalMethod = Class.prototype[methodName];\n\n    if (!originalMethod.promisified_) {\n      Class.prototype[methodName] = util.promisify(originalMethod, options);\n    }\n  });\n}\n\nutil.promisifyAll = promisifyAll;\n/**\n * This will mask properties of an object from console.log.\n *\n * @param {object} object - The object to assign the property to.\n * @param {string} propName - Property name.\n * @param {*} value - Value.\n */\n\nfunction privatize(object, propName, value) {\n  Object.defineProperty(object, propName, {\n    value: value,\n    writable: true\n  });\n}\n\nutil.privatize = privatize;","map":null,"metadata":{},"sourceType":"script"}