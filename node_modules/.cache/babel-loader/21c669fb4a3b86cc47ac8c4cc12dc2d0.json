{"ast":null,"code":"\"use strict\";\n\nvar _regeneratorRuntime = require(\"/Users/cvoisin/Repos/actandcaredev/node_modules/@babel/runtime/regenerator\");\n\nvar _classCallCheck = require(\"/Users/cvoisin/Repos/actandcaredev/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/cvoisin/Repos/actandcaredev/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _possibleConstructorReturn = require(\"/Users/cvoisin/Repos/actandcaredev/node_modules/@babel/runtime/helpers/possibleConstructorReturn\");\n\nvar _getPrototypeOf = require(\"/Users/cvoisin/Repos/actandcaredev/node_modules/@babel/runtime/helpers/getPrototypeOf\");\n\nvar _inherits = require(\"/Users/cvoisin/Repos/actandcaredev/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _assertThisInitialized = require(\"/Users/cvoisin/Repos/actandcaredev/node_modules/@babel/runtime/helpers/assertThisInitialized\");\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : new P(function (resolve) {\n        resolve(result.value);\n      }).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar http2 = require(\"http2\");\n\nvar stream_1 = require(\"stream\");\n\nvar call_credentials_1 = require(\"./call-credentials\");\n\nvar constants_1 = require(\"./constants\");\n\nvar metadata_1 = require(\"./metadata\");\n\nvar _http2$constants = http2.constants,\n    HTTP2_HEADER_STATUS = _http2$constants.HTTP2_HEADER_STATUS,\n    HTTP2_HEADER_CONTENT_TYPE = _http2$constants.HTTP2_HEADER_CONTENT_TYPE,\n    NGHTTP2_CANCEL = _http2$constants.NGHTTP2_CANCEL;\nvar ReadState;\n\n(function (ReadState) {\n  ReadState[ReadState[\"NO_DATA\"] = 0] = \"NO_DATA\";\n  ReadState[ReadState[\"READING_SIZE\"] = 1] = \"READING_SIZE\";\n  ReadState[ReadState[\"READING_MESSAGE\"] = 2] = \"READING_MESSAGE\";\n})(ReadState || (ReadState = {}));\n\nvar Http2CallStream =\n/*#__PURE__*/\nfunction (_stream_1$Duplex) {\n  _inherits(Http2CallStream, _stream_1$Duplex);\n\n  function Http2CallStream(methodName, channel, options, filterStackFactory) {\n    var _this;\n\n    _classCallCheck(this, Http2CallStream);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(Http2CallStream).call(this, {\n      objectMode: true\n    }));\n    _this.methodName = methodName;\n    _this.channel = channel;\n    _this.options = options;\n    _this.credentials = call_credentials_1.CallCredentials.createEmpty();\n    _this.http2Stream = null;\n    _this.pendingRead = false;\n    _this.pendingWrite = null;\n    _this.pendingWriteCallback = null;\n    _this.pendingFinalCallback = null;\n    _this.readState = ReadState.NO_DATA;\n    _this.readCompressFlag = Buffer.alloc(1);\n    _this.readPartialSize = Buffer.alloc(4);\n    _this.readSizeRemaining = 4;\n    _this.readMessageSize = 0;\n    _this.readPartialMessage = [];\n    _this.readMessageRemaining = 0;\n    _this.isReadFilterPending = false;\n    _this.canPush = false;\n    _this.unpushedReadMessages = [];\n    _this.unfilteredReadMessages = []; // Status code mapped from :status. To be used if grpc-status is not received\n\n    _this.mappedStatusCode = constants_1.Status.UNKNOWN; // Promise objects that are re-assigned to resolving promises when headers\n    // or trailers received. Processing headers/trailers is asynchronous, so we\n    // can use these objects to await their completion. This helps us establish\n    // order of precedence when obtaining the status of the call.\n\n    _this.handlingHeaders = Promise.resolve();\n    _this.handlingTrailers = Promise.resolve(); // This is populated (non-null) if and only if the call has ended\n\n    _this.finalStatus = null;\n    _this.filterStack = filterStackFactory.createFilter(_assertThisInitialized(_assertThisInitialized(_this)));\n    return _this;\n  }\n  /**\n   * On first call, emits a 'status' event with the given StatusObject.\n   * Subsequent calls are no-ops.\n   * @param status The status of the call.\n   */\n\n\n  _createClass(Http2CallStream, [{\n    key: \"endCall\",\n    value: function endCall(status) {\n      if (this.finalStatus === null) {\n        this.finalStatus = status;\n        this.emit('status', status);\n      }\n    }\n  }, {\n    key: \"handleFilterError\",\n    value: function handleFilterError(error) {\n      this.cancelWithStatus(constants_1.Status.INTERNAL, error.message);\n    }\n  }, {\n    key: \"handleFilteredRead\",\n    value: function handleFilteredRead(message) {\n      this.isReadFilterPending = false;\n\n      if (this.canPush) {\n        if (!this.push(message)) {\n          this.canPush = false;\n          this.http2Stream.pause();\n        }\n      } else {\n        this.unpushedReadMessages.push(message);\n      }\n\n      if (this.unfilteredReadMessages.length > 0) {\n        /* nextMessage is guaranteed not to be undefined because\n           unfilteredReadMessages is non-empty */\n        var nextMessage = this.unfilteredReadMessages.shift();\n        this.filterReceivedMessage(nextMessage);\n      }\n    }\n  }, {\n    key: \"filterReceivedMessage\",\n    value: function filterReceivedMessage(framedMessage) {\n      if (framedMessage === null) {\n        if (this.canPush) {\n          this.push(null);\n        } else {\n          this.unpushedReadMessages.push(null);\n        }\n\n        return;\n      }\n\n      this.isReadFilterPending = true;\n      this.filterStack.receiveMessage(Promise.resolve(framedMessage)).then(this.handleFilteredRead.bind(this), this.handleFilterError.bind(this));\n    }\n  }, {\n    key: \"tryPush\",\n    value: function tryPush(messageBytes) {\n      if (this.isReadFilterPending) {\n        this.unfilteredReadMessages.push(messageBytes);\n      } else {\n        this.filterReceivedMessage(messageBytes);\n      }\n    }\n  }, {\n    key: \"handleTrailers\",\n    value: function handleTrailers(headers) {\n      var _this2 = this;\n\n      var code = this.mappedStatusCode;\n      var details = '';\n      var metadata;\n\n      try {\n        metadata = metadata_1.Metadata.fromHttp2Headers(headers);\n      } catch (e) {\n        metadata = new metadata_1.Metadata();\n      }\n\n      var status = {\n        code: code,\n        details: details,\n        metadata: metadata\n      };\n\n      this.handlingTrailers = function () {\n        return __awaiter(_this2, void 0, void 0,\n        /*#__PURE__*/\n        _regeneratorRuntime.mark(function _callee() {\n          var finalStatus;\n          return _regeneratorRuntime.wrap(function _callee$(_context) {\n            while (1) {\n              switch (_context.prev = _context.next) {\n                case 0:\n                  _context.prev = 0;\n                  _context.next = 3;\n                  return this.filterStack.receiveTrailers(Promise.resolve(status));\n\n                case 3:\n                  finalStatus = _context.sent;\n                  _context.next = 12;\n                  break;\n\n                case 6:\n                  _context.prev = 6;\n                  _context.t0 = _context[\"catch\"](0);\n                  _context.next = 10;\n                  return this.handlingHeaders;\n\n                case 10:\n                  // This is a no-op if the call was already ended when handling headers.\n                  this.endCall({\n                    code: constants_1.Status.INTERNAL,\n                    details: 'Failed to process received status',\n                    metadata: new metadata_1.Metadata()\n                  });\n                  return _context.abrupt(\"return\");\n\n                case 12:\n                  _context.next = 14;\n                  return this.handlingHeaders;\n\n                case 14:\n                  // This is a no-op if the call was already ended when handling headers.\n                  this.endCall(finalStatus);\n\n                case 15:\n                case \"end\":\n                  return _context.stop();\n              }\n            }\n          }, _callee, this, [[0, 6]]);\n        }));\n      }();\n    }\n  }, {\n    key: \"attachHttp2Stream\",\n    value: function attachHttp2Stream(stream) {\n      var _this3 = this;\n\n      if (this.finalStatus !== null) {\n        stream.close(NGHTTP2_CANCEL);\n      } else {\n        this.http2Stream = stream;\n        stream.on('response', function (headers, flags) {\n          switch (headers[HTTP2_HEADER_STATUS]) {\n            // TODO(murgatroid99): handle 100 and 101\n            case '400':\n              _this3.mappedStatusCode = constants_1.Status.INTERNAL;\n              break;\n\n            case '401':\n              _this3.mappedStatusCode = constants_1.Status.UNAUTHENTICATED;\n              break;\n\n            case '403':\n              _this3.mappedStatusCode = constants_1.Status.PERMISSION_DENIED;\n              break;\n\n            case '404':\n              _this3.mappedStatusCode = constants_1.Status.UNIMPLEMENTED;\n              break;\n\n            case '429':\n            case '502':\n            case '503':\n            case '504':\n              _this3.mappedStatusCode = constants_1.Status.UNAVAILABLE;\n              break;\n\n            default:\n              _this3.mappedStatusCode = constants_1.Status.UNKNOWN;\n          }\n\n          if (flags & http2.constants.NGHTTP2_FLAG_END_STREAM) {\n            _this3.handleTrailers(headers);\n          } else {\n            var metadata;\n\n            try {\n              metadata = metadata_1.Metadata.fromHttp2Headers(headers);\n            } catch (error) {\n              _this3.endCall({\n                code: constants_1.Status.UNKNOWN,\n                details: error.message,\n                metadata: new metadata_1.Metadata()\n              });\n\n              return;\n            }\n\n            _this3.handlingHeaders = _this3.filterStack.receiveMetadata(Promise.resolve(metadata)).then(function (finalMetadata) {\n              _this3.emit('metadata', finalMetadata);\n            }).catch(function (error) {\n              _this3.destroyHttp2Stream();\n\n              _this3.endCall({\n                code: constants_1.Status.UNKNOWN,\n                details: error.message,\n                metadata: new metadata_1.Metadata()\n              });\n            });\n          }\n        });\n        stream.on('trailers', this.handleTrailers.bind(this));\n        stream.on('data', function (data) {\n          var readHead = 0;\n          var toRead;\n\n          while (readHead < data.length) {\n            switch (_this3.readState) {\n              case ReadState.NO_DATA:\n                _this3.readCompressFlag = data.slice(readHead, readHead + 1);\n                readHead += 1;\n                _this3.readState = ReadState.READING_SIZE;\n\n                _this3.readPartialSize.fill(0);\n\n                _this3.readSizeRemaining = 4;\n                _this3.readMessageSize = 0;\n                _this3.readMessageRemaining = 0;\n                _this3.readPartialMessage = [];\n                break;\n\n              case ReadState.READING_SIZE:\n                toRead = Math.min(data.length - readHead, _this3.readSizeRemaining);\n                data.copy(_this3.readPartialSize, 4 - _this3.readSizeRemaining, readHead, readHead + toRead);\n                _this3.readSizeRemaining -= toRead;\n                readHead += toRead; // readSizeRemaining >=0 here\n\n                if (_this3.readSizeRemaining === 0) {\n                  _this3.readMessageSize = _this3.readPartialSize.readUInt32BE(0);\n                  _this3.readMessageRemaining = _this3.readMessageSize;\n\n                  if (_this3.readMessageRemaining > 0) {\n                    _this3.readState = ReadState.READING_MESSAGE;\n                  } else {\n                    _this3.tryPush(Buffer.concat([_this3.readCompressFlag, _this3.readPartialSize]));\n\n                    _this3.readState = ReadState.NO_DATA;\n                  }\n                }\n\n                break;\n\n              case ReadState.READING_MESSAGE:\n                toRead = Math.min(data.length - readHead, _this3.readMessageRemaining);\n\n                _this3.readPartialMessage.push(data.slice(readHead, readHead + toRead));\n\n                _this3.readMessageRemaining -= toRead;\n                readHead += toRead; // readMessageRemaining >=0 here\n\n                if (_this3.readMessageRemaining === 0) {\n                  // At this point, we have read a full message\n                  var framedMessageBuffers = [_this3.readCompressFlag, _this3.readPartialSize].concat(_this3.readPartialMessage);\n                  var framedMessage = Buffer.concat(framedMessageBuffers, _this3.readMessageSize + 5);\n\n                  _this3.tryPush(framedMessage);\n\n                  _this3.readState = ReadState.NO_DATA;\n                }\n\n                break;\n\n              default:\n                throw new Error('This should never happen');\n            }\n          }\n        });\n        stream.on('end', function () {\n          _this3.tryPush(null);\n        });\n        stream.on('close', function (errorCode) {\n          return __awaiter(_this3, void 0, void 0,\n          /*#__PURE__*/\n          _regeneratorRuntime.mark(function _callee2() {\n            var code, details;\n            return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n              while (1) {\n                switch (_context2.prev = _context2.next) {\n                  case 0:\n                    details = '';\n                    _context2.t0 = errorCode;\n                    _context2.next = _context2.t0 === http2.constants.NGHTTP2_REFUSED_STREAM ? 4 : _context2.t0 === http2.constants.NGHTTP2_CANCEL ? 6 : _context2.t0 === http2.constants.NGHTTP2_ENHANCE_YOUR_CALM ? 8 : _context2.t0 === http2.constants.NGHTTP2_INADEQUATE_SECURITY ? 11 : 14;\n                    break;\n\n                  case 4:\n                    code = constants_1.Status.UNAVAILABLE;\n                    return _context2.abrupt(\"break\", 15);\n\n                  case 6:\n                    code = constants_1.Status.CANCELLED;\n                    return _context2.abrupt(\"break\", 15);\n\n                  case 8:\n                    code = constants_1.Status.RESOURCE_EXHAUSTED;\n                    details = 'Bandwidth exhausted';\n                    return _context2.abrupt(\"break\", 15);\n\n                  case 11:\n                    code = constants_1.Status.PERMISSION_DENIED;\n                    details = 'Protocol not secure enough';\n                    return _context2.abrupt(\"break\", 15);\n\n                  case 14:\n                    code = constants_1.Status.INTERNAL;\n\n                  case 15:\n                    _context2.next = 17;\n                    return this.handlingTrailers;\n\n                  case 17:\n                    // This is a no-op if trailers were received at all.\n                    // This is OK, because status codes emitted here correspond to more\n                    // catastrophic issues that prevent us from receiving trailers in the\n                    // first place.\n                    this.endCall({\n                      code: code,\n                      details: details,\n                      metadata: new metadata_1.Metadata()\n                    });\n\n                  case 18:\n                  case \"end\":\n                    return _context2.stop();\n                }\n              }\n            }, _callee2, this);\n          }));\n        });\n        stream.on('error', function (err) {\n          _this3.endCall({\n            code: constants_1.Status.INTERNAL,\n            details: 'Internal HTTP2 error',\n            metadata: new metadata_1.Metadata()\n          });\n        });\n\n        if (!this.pendingRead) {\n          stream.pause();\n        }\n\n        if (this.pendingWrite) {\n          if (!this.pendingWriteCallback) {\n            throw new Error('Invalid state in write handling code');\n          }\n\n          stream.write(this.pendingWrite, this.pendingWriteCallback);\n        }\n\n        if (this.pendingFinalCallback) {\n          stream.end(this.pendingFinalCallback);\n        }\n      }\n    }\n  }, {\n    key: \"sendMetadata\",\n    value: function sendMetadata(metadata) {\n      this.channel._startHttp2Stream(this.options.host, this.methodName, this, metadata);\n    }\n  }, {\n    key: \"destroyHttp2Stream\",\n    value: function destroyHttp2Stream() {\n      // The http2 stream could already have been destroyed if cancelWithStatus\n      // is called in response to an internal http2 error.\n      if (this.http2Stream !== null && !this.http2Stream.destroyed) {\n        /* TODO(murgatroid99): Determine if we want to send different RST_STREAM\n         * codes based on the status code */\n        this.http2Stream.close(NGHTTP2_CANCEL);\n      }\n    }\n  }, {\n    key: \"cancelWithStatus\",\n    value: function cancelWithStatus(status, details) {\n      var _this4 = this;\n\n      this.destroyHttp2Stream();\n\n      (function () {\n        return __awaiter(_this4, void 0, void 0,\n        /*#__PURE__*/\n        _regeneratorRuntime.mark(function _callee3() {\n          return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n            while (1) {\n              switch (_context3.prev = _context3.next) {\n                case 0:\n                  _context3.next = 2;\n                  return this.handlingTrailers;\n\n                case 2:\n                  this.endCall({\n                    code: status,\n                    details: details,\n                    metadata: new metadata_1.Metadata()\n                  });\n\n                case 3:\n                case \"end\":\n                  return _context3.stop();\n              }\n            }\n          }, _callee3, this);\n        }));\n      })();\n    }\n  }, {\n    key: \"getDeadline\",\n    value: function getDeadline() {\n      return this.options.deadline;\n    }\n  }, {\n    key: \"getCredentials\",\n    value: function getCredentials() {\n      return this.credentials;\n    }\n  }, {\n    key: \"setCredentials\",\n    value: function setCredentials(credentials) {\n      this.credentials = credentials;\n    }\n  }, {\n    key: \"getStatus\",\n    value: function getStatus() {\n      return this.finalStatus;\n    }\n  }, {\n    key: \"getPeer\",\n    value: function getPeer() {\n      throw new Error('Not yet implemented');\n    }\n  }, {\n    key: \"getMethod\",\n    value: function getMethod() {\n      return this.methodName;\n    }\n  }, {\n    key: \"getHost\",\n    value: function getHost() {\n      return this.options.host;\n    }\n  }, {\n    key: \"_read\",\n    value: function _read(size) {\n      this.canPush = true;\n\n      if (this.http2Stream === null) {\n        this.pendingRead = true;\n      } else {\n        while (this.unpushedReadMessages.length > 0) {\n          var nextMessage = this.unpushedReadMessages.shift();\n          this.canPush = this.push(nextMessage);\n\n          if (nextMessage === null || !this.canPush) {\n            this.canPush = false;\n            return;\n          }\n        }\n        /* Only resume reading from the http2Stream if we don't have any pending\n         * messages to emit, and we haven't gotten the signal to stop pushing\n         * messages */\n\n\n        this.http2Stream.resume();\n      }\n    }\n  }, {\n    key: \"_write\",\n    value: function _write(chunk, encoding, cb) {\n      var _this5 = this;\n\n      this.filterStack.sendMessage(Promise.resolve(chunk)).then(function (message) {\n        if (_this5.http2Stream === null) {\n          _this5.pendingWrite = message.message;\n          _this5.pendingWriteCallback = cb;\n        } else {\n          _this5.http2Stream.write(message.message, cb);\n        }\n      }, this.handleFilterError.bind(this));\n    }\n  }, {\n    key: \"_final\",\n    value: function _final(cb) {\n      if (this.http2Stream === null) {\n        this.pendingFinalCallback = cb;\n      } else {\n        this.http2Stream.end(cb);\n      }\n    }\n  }]);\n\n  return Http2CallStream;\n}(stream_1.Duplex);\n\nexports.Http2CallStream = Http2CallStream;","map":null,"metadata":{},"sourceType":"script"}