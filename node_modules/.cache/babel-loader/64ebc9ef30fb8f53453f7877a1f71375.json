{"ast":null,"code":"'use strict';\n\nfunction Point(x, y) {\n  this.x = x;\n  this.y = y;\n}\n\nPoint.prototype.add = function (point) {\n  return new Point(this.x + point.x, this.y + point.y);\n};\n\nPoint.prototype.sub = function (point) {\n  return new Point(this.x - point.x, this.y - point.y);\n};\n\nPoint.prototype.mul = function (value) {\n  return new Point(this.x * value, this.y * value);\n};\n\nPoint.prototype.div = function (value) {\n  return new Point(this.x / value, this.y / value);\n};\n\nPoint.prototype.dist = function () {\n  return Math.sqrt(this.x * this.x + this.y * this.y);\n};\n\nPoint.prototype.sqr = function () {\n  return this.x * this.x + this.y * this.y;\n};\n\nPoint.prototype.dot = function (point) {\n  return this.x * point.x + this.y * point.y;\n};\n\nfunction calcPowerCoefficients(p1, c1, c2, p2) {\n  // point(t) = p1*(1-t)^3 + c1*t*(1-t)^2 + c2*t^2*(1-t) + p2*t^3 = a*t^3 + b*t^2 + c*t + d\n  // for each t value, so\n  // a = (p2 - p1) + 3 * (c1 - c2)\n  // b = 3 * (p1 + c2) - 6 * c1\n  // c = 3 * (c1 - p1)\n  // d = p1\n  var a = p2.sub(p1).add(c1.sub(c2).mul(3));\n  var b = p1.add(c2).mul(3).sub(c1.mul(6));\n  var c = c1.sub(p1).mul(3);\n  var d = p1;\n  return [a, b, c, d];\n}\n\nfunction calcPoint(a, b, c, d, t) {\n  // a*t^3 + b*t^2 + c*t + d = ((a*t + b)*t + c)*t + d\n  return a.mul(t).add(b).mul(t).add(c).mul(t).add(d);\n}\n\nfunction calcPointQuad(a, b, c, t) {\n  // a*t^2 + b*t + c = (a*t + b)*t + c\n  return a.mul(t).add(b).mul(t).add(c);\n}\n\nfunction calcPointDerivative(a, b, c, d, t) {\n  // d/dt[a*t^3 + b*t^2 + c*t + d] = 3*a*t^2 + 2*b*t + c = (3*a*t + 2*b)*t + c\n  return a.mul(3 * t).add(b.mul(2)).mul(t).add(c);\n}\n\nfunction quadSolve(a, b, c) {\n  // a*x^2 + b*x + c = 0\n  if (a === 0) {\n    return b === 0 ? [] : [-c / b];\n  }\n\n  var D = b * b - 4 * a * c;\n\n  if (D < 0) {\n    return [];\n  } else if (D === 0) {\n    return [-b / (2 * a)];\n  }\n\n  var DSqrt = Math.sqrt(D);\n  return [(-b - DSqrt) / (2 * a), (-b + DSqrt) / (2 * a)];\n}\n\nfunction cubicRoot(x) {\n  return x < 0 ? -Math.pow(-x, 1 / 3) : Math.pow(x, 1 / 3);\n}\n\nfunction cubicSolve(a, b, c, d) {\n  // a*x^3 + b*x^2 + c*x + d = 0\n  if (a === 0) {\n    return quadSolve(b, c, d);\n  } // solve using Cardan's method, which is described in paper of R.W.D. Nickals\n  // http://www.nickalls.org/dick/papers/maths/cubic1993.pdf (doi:10.2307/3619777)\n\n\n  var xn = -b / (3 * a); // point of symmetry x coordinate\n\n  var yn = ((a * xn + b) * xn + c) * xn + d; // point of symmetry y coordinate\n\n  var deltaSq = (b * b - 3 * a * c) / (9 * a * a); // delta^2\n\n  var hSq = 4 * a * a * Math.pow(deltaSq, 3); // h^2\n\n  var D3 = yn * yn - hSq;\n\n  if (D3 > 0) {\n    // 1 real root\n    var D3Sqrt = Math.sqrt(D3);\n    return [xn + cubicRoot((-yn + D3Sqrt) / (2 * a)) + cubicRoot((-yn - D3Sqrt) / (2 * a))];\n  } else if (D3 === 0) {\n    // 2 real roots\n    var delta1 = cubicRoot(yn / (2 * a));\n    return [xn - 2 * delta1, xn + delta1];\n  } // 3 real roots\n\n\n  var theta = Math.acos(-yn / Math.sqrt(hSq)) / 3;\n  var delta = Math.sqrt(deltaSq);\n  return [xn + 2 * delta * Math.cos(theta), xn + 2 * delta * Math.cos(theta + Math.PI * 2 / 3), xn + 2 * delta * Math.cos(theta + Math.PI * 4 / 3)];\n}\n\nfunction minDistanceToQuad(point, p1, c1, p2) {\n  // f(t) = (1-t)^2 * p1 + 2*t*(1 - t) * c1 + t^2 * p2 = a*t^2 + b*t + c, t in [0, 1],\n  // a = p1 + p2 - 2 * c1\n  // b = 2 * (c1 - p1)\n  // c = p1; a, b, c are vectors because p1, c1, p2 are vectors too\n  // The distance between given point and quadratic curve is equal to\n  // sqrt((f(t) - point)^2), so these expression has zero derivative by t at points where\n  // (f'(t), (f(t) - point)) = 0.\n  // Substituting quadratic curve as f(t) one could obtain a cubic equation\n  // e3*t^3 + e2*t^2 + e1*t + e0 = 0 with following coefficients:\n  // e3 = 2 * a^2\n  // e2 = 3 * a*b\n  // e1 = (b^2 + 2 * a*(c - point))\n  // e0 = (c - point)*b\n  // One of the roots of the equation from [0, 1], or t = 0 or t = 1 is a value of t\n  // at which the distance between given point and quadratic Bezier curve has minimum.\n  // So to find the minimal distance one have to just pick the minimum value of\n  // the distance on set {t = 0 | t = 1 | t is root of the equation from [0, 1] }.\n  var a = p1.add(p2).sub(c1.mul(2));\n  var b = c1.sub(p1).mul(2);\n  var c = p1;\n  var e3 = 2 * a.sqr();\n  var e2 = 3 * a.dot(b);\n  var e1 = b.sqr() + 2 * a.dot(c.sub(point));\n  var e0 = c.sub(point).dot(b);\n  var candidates = cubicSolve(e3, e2, e1, e0).filter(function (t) {\n    return t > 0 && t < 1;\n  }).concat([0, 1]);\n  var minDistance = 1e9;\n\n  for (var i = 0; i < candidates.length; i++) {\n    var distance = calcPointQuad(a, b, c, candidates[i]).sub(point).dist();\n\n    if (distance < minDistance) {\n      minDistance = distance;\n    }\n  }\n\n  return minDistance;\n}\n\nfunction processSegment(a, b, c, d, t1, t2) {\n  // Find a single control point for given segment of cubic Bezier curve\n  // These control point is an interception of tangent lines to the boundary points\n  // Let's denote that f(t) is a vector function of parameter t that defines the cubic Bezier curve,\n  // f(t1) + f'(t1)*z1 is a parametric equation of tangent line to f(t1) with parameter z1\n  // f(t2) + f'(t2)*z2 is the same for point f(t2) and the vector equation\n  // f(t1) + f'(t1)*z1 = f(t2) + f'(t2)*z2 defines the values of parameters z1 and z2.\n  // Defining fx(t) and fy(t) as the x and y components of vector function f(t) respectively\n  // and solving the given system for z1 one could obtain that\n  //\n  //      -(fx(t2) - fx(t1))*fy'(t2) + (fy(t2) - fy(t1))*fx'(t2)\n  // z1 = ------------------------------------------------------.\n  //            -fx'(t1)*fy'(t2) + fx'(t2)*fy'(t1)\n  //\n  // Let's assign letter D to the denominator and note that if D = 0 it means that the curve actually\n  // is a line. Substituting z1 to the equation of tangent line to the point f(t1), one could obtain that\n  // cx = [fx'(t1)*(fy(t2)*fx'(t2) - fx(t2)*fy'(t2)) + fx'(t2)*(fx(t1)*fy'(t1) - fy(t1)*fx'(t1))]/D\n  // cy = [fy'(t1)*(fy(t2)*fx'(t2) - fx(t2)*fy'(t2)) + fy'(t2)*(fx(t1)*fy'(t1) - fy(t1)*fx'(t1))]/D\n  // where c = (cx, cy) is the control point of quadratic Bezier curve.\n  var f1 = calcPoint(a, b, c, d, t1);\n  var f2 = calcPoint(a, b, c, d, t2);\n  var f1_ = calcPointDerivative(a, b, c, d, t1);\n  var f2_ = calcPointDerivative(a, b, c, d, t2);\n  var D = -f1_.x * f2_.y + f2_.x * f1_.y;\n\n  if (Math.abs(D) < 1e-8) {\n    return [f1, f1.add(f2).div(2), f2]; // straight line segment\n  }\n\n  var cx = (f1_.x * (f2.y * f2_.x - f2.x * f2_.y) + f2_.x * (f1.x * f1_.y - f1.y * f1_.x)) / D;\n  var cy = (f1_.y * (f2.y * f2_.x - f2.x * f2_.y) + f2_.y * (f1.x * f1_.y - f1.y * f1_.x)) / D;\n  return [f1, new Point(cx, cy), f2];\n}\n\nfunction isSegmentApproximationClose(a, b, c, d, tmin, tmax, p1, c1, p2, errorBound) {\n  // a,b,c,d define cubic curve\n  // tmin, tmax are boundary points on cubic curve\n  // p1, c1, p2 define quadratic curve\n  // errorBound is maximum allowed distance\n  // Try to find maximum distance between one of N points segment of given cubic\n  // and corresponding quadratic curve that estimates the cubic one, assuming\n  // that the boundary points of cubic and quadratic points are equal.\n  //\n  // The distance calculation method comes from Hausdorff distance defenition\n  // (https://en.wikipedia.org/wiki/Hausdorff_distance), but with following simplifications\n  // * it looks for maximum distance only for finite number of points of cubic curve\n  // * it doesn't perform reverse check that means selecting set of fixed points on\n  //   the quadratic curve and looking for the closest points on the cubic curve\n  // But this method allows easy estimation of approximation error, so it is enough\n  // for practical purposes.\n  var n = 10; // number of points + 1\n\n  var dt = (tmax - tmin) / n;\n\n  for (var t = tmin + dt; t < tmax - dt; t += dt) {\n    // don't check distance on boundary points\n    // because they should be the same\n    var point = calcPoint(a, b, c, d, t);\n\n    if (minDistanceToQuad(point, p1, c1, p2) > errorBound) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nfunction _isApproximationClose(a, b, c, d, quadCurves, errorBound) {\n  var dt = 1 / quadCurves.length;\n\n  for (var i = 0; i < quadCurves.length; i++) {\n    var p1 = quadCurves[i][0];\n    var c1 = quadCurves[i][1];\n    var p2 = quadCurves[i][2];\n\n    if (!isSegmentApproximationClose(a, b, c, d, i * dt, (i + 1) * dt, p1, c1, p2, errorBound)) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nfunction fromFlatArray(points) {\n  var result = [];\n  var segmentsNumber = (points.length - 2) / 4;\n\n  for (var i = 0; i < segmentsNumber; i++) {\n    result.push([new Point(points[4 * i], points[4 * i + 1]), new Point(points[4 * i + 2], points[4 * i + 3]), new Point(points[4 * i + 4], points[4 * i + 5])]);\n  }\n\n  return result;\n}\n\nfunction toFlatArray(quadsList) {\n  var result = [];\n  result.push(quadsList[0][0].x);\n  result.push(quadsList[0][0].y);\n\n  for (var i = 0; i < quadsList.length; i++) {\n    result.push(quadsList[i][1].x);\n    result.push(quadsList[i][1].y);\n    result.push(quadsList[i][2].x);\n    result.push(quadsList[i][2].y);\n  }\n\n  return result;\n}\n\nfunction isApproximationClose(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, quads, errorBound) {\n  // TODO: rewrite it in C-style and remove _isApproximationClose\n  var pc = calcPowerCoefficients(new Point(p1x, p1y), new Point(c1x, c1y), new Point(c2x, c2y), new Point(p2x, p2y));\n  return _isApproximationClose(pc[0], pc[1], pc[2], pc[3], fromFlatArray(quads), errorBound);\n}\n/*\n * Split cubic bÃ©zier curve into two cubic curves, see details here:\n * https://math.stackexchange.com/questions/877725\n */\n\n\nfunction subdivideCubic(x1, y1, x2, y2, x3, y3, x4, y4, t) {\n  var u = 1 - t,\n      v = t;\n  var bx = x1 * u + x2 * v;\n  var sx = x2 * u + x3 * v;\n  var fx = x3 * u + x4 * v;\n  var cx = bx * u + sx * v;\n  var ex = sx * u + fx * v;\n  var dx = cx * u + ex * v;\n  var by = y1 * u + y2 * v;\n  var sy = y2 * u + y3 * v;\n  var fy = y3 * u + y4 * v;\n  var cy = by * u + sy * v;\n  var ey = sy * u + fy * v;\n  var dy = cy * u + ey * v;\n  return [[x1, y1, bx, by, cx, cy, dx, dy], [dx, dy, ex, ey, fx, fy, x4, y4]];\n}\n\nfunction byNumber(x, y) {\n  return x - y;\n}\n/*\n * Find inflection points on a cubic curve, algorithm is similar to this one:\n * http://www.caffeineowl.com/graphics/2d/vectorial/cubic-inflexion.html\n */\n\n\nfunction solveInflections(x1, y1, x2, y2, x3, y3, x4, y4) {\n  var p = -(x4 * (y1 - 2 * y2 + y3)) + x3 * (2 * y1 - 3 * y2 + y4) + x1 * (y2 - 2 * y3 + y4) - x2 * (y1 - 3 * y3 + 2 * y4);\n  var q = x4 * (y1 - y2) + 3 * x3 * (-y1 + y2) + x2 * (2 * y1 - 3 * y3 + y4) - x1 * (2 * y2 - 3 * y3 + y4);\n  var r = x3 * (y1 - y2) + x1 * (y2 - y3) + x2 * (-y1 + y3);\n  return quadSolve(p, q, r).filter(function (t) {\n    return t > 1e-8 && t < 1 - 1e-8;\n  }).sort(byNumber);\n}\n/*\n * Approximate cubic Bezier curve defined with base points p1, p2 and control points c1, c2 with\n * with a few quadratic Bezier curves.\n * The function uses tangent method to find quadratic approximation of cubic curve segment and\n * simplified Hausdorff distance to determine number of segments that is enough to make error small.\n * In general the method is the same as described here: https://fontforge.github.io/bezier.html.\n */\n\n\nfunction _cubicToQuad(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, errorBound) {\n  var p1 = new Point(p1x, p1y);\n  var c1 = new Point(c1x, c1y);\n  var c2 = new Point(c2x, c2y);\n  var p2 = new Point(p2x, p2y);\n  var pc = calcPowerCoefficients(p1, c1, c2, p2);\n  var a = pc[0],\n      b = pc[1],\n      c = pc[2],\n      d = pc[3];\n  var approximation;\n\n  for (var segmentsCount = 1; segmentsCount <= 8; segmentsCount++) {\n    approximation = [];\n\n    for (var t = 0; t < 1; t += 1 / segmentsCount) {\n      approximation.push(processSegment(a, b, c, d, t, t + 1 / segmentsCount));\n    }\n\n    if (segmentsCount === 1 && (approximation[0][1].sub(p1).dot(c1.sub(p1)) < 0 || approximation[0][1].sub(p2).dot(c2.sub(p2)) < 0)) {\n      // approximation concave, while the curve is convex (or vice versa)\n      continue;\n    }\n\n    if (_isApproximationClose(a, b, c, d, approximation, errorBound)) {\n      break;\n    }\n  }\n\n  return toFlatArray(approximation);\n}\n/*\n * If this curve has any inflection points, split the curve and call\n * _cubicToQuad function on each resulting curve.\n */\n\n\nfunction cubicToQuad(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, errorBound) {\n  var inflections = solveInflections(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y);\n\n  if (!inflections.length) {\n    return _cubicToQuad(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, errorBound);\n  }\n\n  var result = [];\n  var curve = [p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y];\n  var prevPoint = 0;\n  var quad, split;\n\n  for (var inflectionIdx = 0; inflectionIdx < inflections.length; inflectionIdx++) {\n    split = subdivideCubic(curve[0], curve[1], curve[2], curve[3], curve[4], curve[5], curve[6], curve[7], // we make a new curve, so adjust inflection point accordingly\n    1 - (1 - inflections[inflectionIdx]) / (1 - prevPoint));\n    quad = _cubicToQuad(split[0][0], split[0][1], split[0][2], split[0][3], split[0][4], split[0][5], split[0][6], split[0][7], errorBound);\n    result = result.concat(quad.slice(0, -2));\n    curve = split[1];\n    prevPoint = inflections[inflectionIdx];\n  }\n\n  quad = _cubicToQuad(curve[0], curve[1], curve[2], curve[3], curve[4], curve[5], curve[6], curve[7], errorBound);\n  return result.concat(quad);\n}\n\nmodule.exports = cubicToQuad; // following exports are for testing purposes\n\nmodule.exports.isApproximationClose = isApproximationClose;\nmodule.exports.cubicSolve = cubicSolve;","map":null,"metadata":{},"sourceType":"script"}