{"ast":null,"code":"/**\n * Copyright 2014-2017 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n'use strict';\n\nvar arrify = require('arrify');\n\nvar async = require('async');\n\nvar common = require('@google-cloud/common');\n\nvar extend = require('extend');\n\nvar fs = require('fs');\n\nvar is = require('is');\n\nvar mime = require('mime-types');\n\nvar path = require('path');\n\nvar snakeize = require('snakeize');\n\nvar util = require('util');\n\nvar request = require('request');\n\nvar Acl = require('./acl.js');\n\nvar File = require('./file.js');\n\nvar Iam = require('./iam.js');\n\nvar Notification = require('./notification.js');\n/**\n * The size of a file (in bytes) must be greater than this number to\n * automatically trigger a resumable upload.\n *\n * @const {number}\n * @private\n */\n\n\nvar RESUMABLE_THRESHOLD = 5000000;\n/**\n * Create a Bucket object to interact with a Cloud Storage bucket.\n *\n * @class\n * @hideconstructor\n *\n * @param {Storage} storage A {@link Storage} instance.\n * @param {string} name The name of the bucket.\n * @param {object} [options] Configuration object.\n * @param {string} [options.userProject] User project.\n *\n * @example\n * const storage = require('@google-cloud/storage')();\n * const bucket = storage.bucket('albums');\n */\n\nfunction Bucket(storage, name, options) {\n  options = options || {};\n  name = name.replace(/^gs:\\/\\//, '');\n  var methods = {\n    /**\n     * Create a bucket.\n     *\n     * @method Bucket#create\n     * @param {CreateBucketRequest} [metadata] Metadata to set for the bucket.\n     * @param {CreateBucketCallback} [callback] Callback function.\n     * @returns {Promise<CreateBucketResponse>}\n     *\n     * @example\n     * const storage = require('@google-cloud/storage')();\n     * const bucket = storage.bucket('albums');\n     * bucket.create(function(err, bucket, apiResponse) {\n     *   if (!err) {\n     *     // The bucket was created successfully.\n     *   }\n     * });\n     *\n     * //-\n     * // If the callback is omitted, we'll return a Promise.\n     * //-\n     * bucket.create().then(function(data) {\n     *   const bucket = data[0];\n     *   const apiResponse = data[1];\n     * });\n     */\n    create: true\n  };\n  common.ServiceObject.call(this, {\n    parent: storage,\n    baseUrl: '/b',\n    id: name,\n    createMethod: storage.createBucket.bind(storage),\n    methods: methods\n  });\n  /**\n   * The bucket's name.\n   * @name Bucket#name\n   * @type {string}\n   */\n\n  this.name = name;\n  /**\n   * A reference to the {@link Storage} associated with this {@link Bucket}\n   * instance.\n   * @name Bucket#storage\n   * @type {string}\n   */\n\n  this.storage = storage;\n  /**\n   * A user project to apply to each request from this bucket.\n   * @name Bucket#userProject\n   * @type {string}\n   */\n\n  this.userProject = options.userProject;\n  /**\n   * Cloud Storage uses access control lists (ACLs) to manage object and\n   * bucket access. ACLs are the mechanism you use to share objects with other\n   * users and allow other users to access your buckets and objects.\n   *\n   * An ACL consists of one or more entries, where each entry grants permissions\n   * to an entity. Permissions define the actions that can be performed against\n   * an object or bucket (for example, `READ` or `WRITE`); the entity defines\n   * who the permission applies to (for example, a specific user or group of\n   * users).\n   *\n   * The `acl` object on a Bucket instance provides methods to get you a list of\n   * the ACLs defined on your bucket, as well as set, update, and delete them.\n   *\n   * Buckets also have\n   * [default ACLs](https://cloud.google.com/storage/docs/access-control/lists#default)\n   * for all created files. Default ACLs specify permissions that all new\n   * objects added to the bucket will inherit by default. You can add, delete,\n   * get, and update entities and permissions for these as well with\n   * {@link Bucket#acl.default}.\n   *\n   * @see [About Access Control Lists]{@link http://goo.gl/6qBBPO}\n   * @see [Default ACLs]{@link https://cloud.google.com/storage/docs/access-control/lists#default}\n   *\n   * @name Bucket#acl\n   * @mixes Acl\n   * @property {Acl} default Cloud Storage Buckets have\n   * [default ACLs](https://cloud.google.com/storage/docs/access-control/lists#default)\n   * for all created files. You can add, delete, get, and update entities and\n   * permissions for these as well. The method signatures and examples are all\n   * the same, after only prefixing the method call with `default`.\n   *\n   * @example\n   * const storage = require('@google-cloud/storage')();\n   *\n   * //-\n   * // Make a bucket's contents publicly readable.\n   * //-\n   * const myBucket = storage.bucket('my-bucket');\n   *\n   * const options = {\n   *   entity: 'allUsers',\n   *   role: storage.acl.READER_ROLE\n   * };\n   *\n   * myBucket.acl.add(options, function(err, aclObject) {});\n   *\n   * //-\n   * // If the callback is omitted, we'll return a Promise.\n   * //-\n   * myBucket.acl.add(options).then(function(data) {\n   *   const aclObject = data[0];\n   *   const apiResponse = data[1];\n   * });\n   *\n   * @example <caption>include:samples/acl.js</caption>\n   * region_tag:storage_print_bucket_acl\n   * Example of printing a bucket's ACL:\n   *\n   * @example <caption>include:samples/acl.js</caption>\n   * region_tag:storage_print_bucket_acl_for_user\n   * Example of printing a bucket's ACL for a specific user:\n   *\n   * @example <caption>include:samples/acl.js</caption>\n   * region_tag:storage_add_bucket_owner\n   * Example of adding an owner to a bucket:\n   *\n   * @example <caption>include:samples/acl.js</caption>\n   * region_tag:storage_remove_bucket_owner\n   * Example of removing an owner from a bucket:\n   *\n   * @example <caption>include:samples/acl.js</caption>\n   * region_tag:storage_add_bucket_default_owner\n   * Example of adding a default owner to a bucket:\n   *\n   * @example <caption>include:samples/acl.js</caption>\n   * region_tag:storage_remove_bucket_default_owner\n   * Example of removing a default owner from a bucket:\n   */\n\n  this.acl = new Acl({\n    request: this.request.bind(this),\n    pathPrefix: '/acl'\n  });\n  this.acl.default = new Acl({\n    request: this.request.bind(this),\n    pathPrefix: '/defaultObjectAcl'\n  });\n  /**\n   * Get and set IAM policies for your bucket.\n   *\n   * @name Bucket#iam\n   * @mixes Iam\n   *\n   * @see [Cloud Storage IAM Management](https://cloud.google.com/storage/docs/access-control/iam#short_title_iam_management)\n   * @see [Granting, Changing, and Revoking Access](https://cloud.google.com/iam/docs/granting-changing-revoking-access)\n   * @see [IAM Roles](https://cloud.google.com/iam/docs/understanding-roles)\n   *\n   * @example\n   * const storage = require('@google-cloud/storage')();\n   * const bucket = storage.bucket('albums');\n   *\n   * //-\n   * // Get the IAM policy for your bucket.\n   * //-\n   * bucket.iam.getPolicy(function(err, policy) {\n   *   console.log(policy);\n   * });\n   *\n   * //-\n   * // If the callback is omitted, we'll return a Promise.\n   * //-\n   * bucket.iam.getPolicy().then(function(data) {\n   *   const policy = data[0];\n   *   const apiResponse = data[1];\n   * });\n   *\n   * @example <caption>include:samples/iam.js</caption>\n   * region_tag:storage_view_bucket_iam_members\n   * Example of retrieving a bucket's IAM policy:\n   *\n   * @example <caption>include:samples/iam.js</caption>\n   * region_tag:storage_add_bucket_iam_member\n   * Example of adding to a bucket's IAM policy:\n   *\n   * @example <caption>include:samples/iam.js</caption>\n   * region_tag:storage_remove_bucket_iam_member\n   * Example of removing from a bucket's IAM policy:\n   */\n\n  this.iam = new Iam(this);\n}\n\nutil.inherits(Bucket, common.ServiceObject);\n/**\n * @typedef {array} CombineResponse\n * @property {File} 0 The new {@link File}.\n * @property {object} 1 The full API response.\n */\n\n/**\n * @callback CombineCallback\n * @param {?Error} err Request error, if any.\n * @param {File} newFile The new {@link File}.\n * @param {object} apiResponse The full API response.\n */\n\n/**\n * Combine multiple files into one new file.\n *\n * @see [Objects: compose API Documentation]{@link https://cloud.google.com/storage/docs/json_api/v1/objects/compose}\n *\n * @throws {Error} if a non-array is provided as sources argument.\n * @throws {Error} if less than two sources are provided.\n * @throws {Error} if no destination is provided.\n *\n * @param {string[]|File[]} sources The source files that will be\n *     combined.\n * @param {string|File} destination The file you would like the\n *     source files combined into.\n * @param {object} [options] Configuration options.\n * @param {string} [options.kmsKeyName] Resource name of the Cloud KMS key, of\n *     the form\n *     `projects/my-project/locations/location/keyRings/my-kr/cryptoKeys/my-key`,\n *     that will be used to encrypt the object. Overwrites the object metadata's\n *     `kms_key_name` value, if any.\n * @param {string} [options.userProject] The ID of the project which will be\n *     billed for the request.\n * @param {CombineCallback} [callback] Callback function.\n * @returns {Promise<CombineResponse>}\n *\n * @example\n * const storage = require('@google-cloud/storage')();\n * const logBucket = storage.bucket('log-bucket');\n *\n * const sources = [\n *   logBucket.file('2013-logs.txt'),\n *   logBucket.file('2014-logs.txt')\n * ];\n *\n * const allLogs = logBucket.file('all-logs.txt');\n *\n * logBucket.combine(sources, allLogs, function(err, newFile, apiResponse) {\n *   // newFile === allLogs\n * });\n *\n * //-\n * // If the callback is omitted, we'll return a Promise.\n * //-\n * logBucket.combine(sources, allLogs).then(function(data) {\n *   const newFile = data[0];\n *   const apiResponse = data[1];\n * });\n */\n\nBucket.prototype.combine = function (sources, destination, options, callback) {\n  if (!is.array(sources) || sources.length < 2) {\n    throw new Error('You must provide at least two source files.');\n  }\n\n  if (!destination) {\n    throw new Error('A destination file must be specified.');\n  }\n\n  var self = this;\n\n  if (is.fn(options)) {\n    callback = options;\n    options = {};\n  }\n\n  sources = sources.map(convertToFile);\n  destination = convertToFile(destination);\n  callback = callback || common.util.noop;\n\n  if (!destination.metadata.contentType) {\n    var destinationContentType = mime.contentType(destination.name);\n\n    if (destinationContentType) {\n      destination.metadata.contentType = destinationContentType;\n    }\n  } // Make the request from the destination File object.\n\n\n  destination.request({\n    method: 'POST',\n    uri: '/compose',\n    json: {\n      destination: {\n        contentType: destination.metadata.contentType\n      },\n      sourceObjects: sources.map(function (source) {\n        var sourceObject = {\n          name: source.name\n        };\n\n        if (source.metadata && source.metadata.generation) {\n          sourceObject.generation = source.metadata.generation;\n        }\n\n        return sourceObject;\n      })\n    },\n    qs: options\n  }, function (err, resp) {\n    if (err) {\n      callback(err, null, resp);\n      return;\n    }\n\n    callback(null, destination, resp);\n  });\n\n  function convertToFile(file) {\n    if (file instanceof File) {\n      return file;\n    }\n\n    return self.file(file);\n  }\n};\n/**\n * @typedef {array} CreateChannelResponse\n * @property {Channel} 0 The new {@link Channel}.\n * @property {object} 1 The full API response.\n */\n\n/**\n * @callback CreateChannelCallback\n * @param {?Error} err Request error, if any.\n * @param {Channel} channel The new {@link Channel}.\n * @param {object} apiResponse The full API response.\n */\n\n/**\n * Create a channel that will be notified when objects in this bucket changes.\n *\n * @throws {Error} If an ID is not provided.\n * @throws {Error} If an address is not provided.\n *\n * @see [Objects: watchAll API Documentation]{@link https://cloud.google.com/storage/docs/json_api/v1/objects/watchAll}\n *\n * @param {string} id The ID of the channel to create.\n * @param {object} config See a\n *     [Objects: watchAll request body](https://cloud.google.com/storage/docs/json_api/v1/objects/watchAll).\n * @param {string} config.address The address where notifications are\n *     delivered for this channel.\n * @param {object} [options] Configuration options.\n * @param {string} [options.userProject] The ID of the project which will be\n *     billed for the request.\n * @param {CreateChannelCallback} [callback] Callback function.\n * @returns {Promise<CreateChannelResponse>}\n *\n * @example\n * const storage = require('@google-cloud/storage')();\n * const bucket = storage.bucket('albums');\n * const id = 'new-channel-id';\n *\n * const config = {\n *   address: 'https://...'\n * };\n *\n * bucket.createChannel(id, config, function(err, channel, apiResponse) {\n *   if (!err) {\n *     // Channel created successfully.\n *   }\n * });\n *\n * //-\n * // If the callback is omitted, we'll return a Promise.\n * //-\n * bucket.createChannel(id, config).then(function(data) {\n *   const channel = data[0];\n *   const apiResponse = data[1];\n * });\n */\n\n\nBucket.prototype.createChannel = function (id, config, options, callback) {\n  var self = this;\n\n  if (!is.string(id)) {\n    throw new Error('An ID is required to create a channel.');\n  }\n\n  if (!is.string(config.address)) {\n    throw new Error('An address is required to create a channel.');\n  }\n\n  if (is.fn(options)) {\n    callback = options;\n    options = {};\n  }\n\n  this.request({\n    method: 'POST',\n    uri: '/o/watch',\n    json: extend({\n      id: id,\n      type: 'web_hook'\n    }, config),\n    qs: options\n  }, function (err, apiResponse) {\n    if (err) {\n      callback(err, null, apiResponse);\n      return;\n    }\n\n    var resourceId = apiResponse.resourceId;\n    var channel = self.storage.channel(id, resourceId);\n    channel.metadata = apiResponse;\n    callback(null, channel, apiResponse);\n  });\n};\n/**\n * Metadata to set for the Notification.\n *\n * @typedef {object} CreateNotificationRequest\n * @property {object} [customAttributes] An optional list of additional\n *     attributes to attach to each Cloud PubSub message published for this\n *     notification subscription.\n * @property {string[]} [eventTypes] If present, only send notifications about\n *     listed event types. If empty, sent notifications for all event types.\n * @property {string} [objectNamePrefix] If present, only apply this\n *     notification configuration to object names that begin with this prefix.\n * @property {string} [payloadFormat] The desired content of the Payload.\n *     Defaults to `JSON_API_V1`.\n *\n *     Acceptable values are:\n *     - `JSON_API_V1`\n *\n *     - `NONE`\n * @property {string} [options.userProject] The ID of the project which will be\n *     billed for the request.\n */\n\n/**\n * @typedef {array} CreateNotificationResponse\n * @property {Notification} 0 The new {@link Notification}.\n * @property {object} 1 The full API response.\n */\n\n/**\n * @callback CreateNotificationCallback\n * @param {?Error} err Request error, if any.\n * @param {Notification} notification The new {@link Notification}.\n * @param {object} apiResponse The full API response.\n */\n\n/**\n * Creates a notification subscription for the bucket.\n *\n * @see [Notifications: insert]{@link https://cloud.google.com/storage/docs/json_api/v1/notifications/insert}\n *\n * @param {Topic|string} topic The Cloud PubSub topic to which this\n *     subscription publishes. If the project ID is omitted, the current project\n *     ID will be used.\n *\n *     Acceptable formats are:\n *     - `projects/grape-spaceship-123/topics/my-topic`\n *\n *     - `my-topic`\n * @param {CreateNotificationRequest} [options] Metadata to set for the\n *     notification.\n * @param {CreateNotificationCallback} [callback] Callback function.\n * @returns {Promise<CreateNotificationResponse>}\n * @throws {Error} If a valid topic is not provided.\n * @see Notification#create\n *\n * @example\n * const storage = require('@google-cloud/storage')();\n * const myBucket = storage.bucket('my-bucket');\n *\n * const callback = function(err, notification, apiResponse) {\n *   if (!err) {\n *     // The notification was created successfully.\n *   }\n * };\n *\n * myBucket.createNotification('my-topic', callback);\n *\n * //-\n * // Configure the nofiication by providing Notification metadata.\n * //-\n * const metadata = {\n *   objectNamePrefix: 'prefix-'\n * };\n *\n * myBucket.createNotification('my-topic', metadata, callback);\n *\n * //-\n * // If the callback is omitted, we'll return a Promise.\n * //-\n * myBucket.createNotification('my-topic').then(function(data) {\n *   const notification = data[0];\n *   const apiResponse = data[1];\n * });\n *\n * @example <caption>include:samples/notifications.js</caption>\n * region_tag:storage_create_notification\n * Another example:\n */\n\n\nBucket.prototype.createNotification = function (topic, options, callback) {\n  var self = this;\n\n  if (is.fn(options)) {\n    callback = options;\n    options = {};\n  }\n\n  if (is.object(topic) && common.util.isCustomType(topic, 'pubsub/topic')) {\n    topic = topic.name;\n  }\n\n  if (!is.string(topic)) {\n    throw new Error('A valid topic name is required.');\n  }\n\n  var body = extend({\n    topic: topic\n  }, options);\n\n  if (body.topic.indexOf('projects') !== 0) {\n    body.topic = 'projects/{{projectId}}/topics/' + body.topic;\n  }\n\n  body.topic = '//pubsub.googleapis.com/' + body.topic;\n\n  if (!body.payloadFormat) {\n    body.payloadFormat = 'JSON_API_V1';\n  }\n\n  var query = {};\n\n  if (body.userProject) {\n    query.userProject = body.userProject;\n    delete body.userProject;\n  }\n\n  this.request({\n    method: 'POST',\n    uri: '/notificationConfigs',\n    json: snakeize(body),\n    qs: query\n  }, function (err, apiResponse) {\n    if (err) {\n      callback(err, null, apiResponse);\n      return;\n    }\n\n    var notification = self.notification(apiResponse.id);\n    notification.metadata = apiResponse;\n    callback(null, notification, apiResponse);\n  });\n};\n/**\n * @typedef {array} DeleteBucketResponse\n * @property {object} 0 The full API response.\n */\n\n/**\n * @callback DeleteBucketCallback\n * @param {?Error} err Request error, if any.\n * @param {object} apiResponse The full API response.\n */\n\n/**\n * Delete the bucket.\n *\n * @see [Buckets: delete API Documentation]{@link https://cloud.google.com/storage/docs/json_api/v1/buckets/delete}\n *\n * @param {object} [options] Configuration options.\n * @param {string} [options.userProject] The ID of the project which will be\n *     billed for the request.\n * @param {DeleteBucketCallback} [callback] Callback function.\n * @returns {Promise<DeleteBucketResponse>}\n *\n * @example\n * const storage = require('@google-cloud/storage')();\n * const bucket = storage.bucket('albums');\n * bucket.delete(function(err, apiResponse) {});\n *\n * //-\n * // If the callback is omitted, we'll return a Promise.\n * //-\n * bucket.delete().then(function(data) {\n *   const apiResponse = data[0];\n * });\n *\n * @example <caption>include:samples/buckets.js</caption>\n * region_tag:storage_delete_bucket\n * Another example:\n */\n\n\nBucket.prototype.delete = function (options, callback) {\n  if (is.fn(options)) {\n    callback = options;\n    options = {};\n  }\n\n  this.request({\n    method: 'DELETE',\n    uri: '',\n    qs: options\n  }, callback || common.util.noop);\n};\n/**\n * @callback DeleteFilesCallback\n * @param {?Error|?Error[]} err Request error, if any, or array of errors from\n *     files that were not able to be deleted.\n * @param {object} apiResponse The full API response.\n */\n\n/**\n * Iterate over the bucket's files, calling `file.delete()` on each.\n *\n * <strong>This is not an atomic request.</strong> A delete attempt will be made\n * for each file individually. Any one can fail, in which case only a portion of\n * the files you intended to be deleted would have.\n *\n * Operations are performed in parallel, up to 10 at once. The first error\n * breaks the loop and will execute the provided callback with it. Specify\n * `{ force: true }` to suppress the errors until all files have had a chance to\n * be processed.\n *\n * The `query` object passed as the first argument will also be passed to\n * {@link Bucket#getFiles}.\n *\n * @see [Objects: delete API Documentation]{@link https://cloud.google.com/storage/docs/json_api/v1/objects/delete}\n *\n * @param {object} [query] Query object. See {@link Bucket#getFiles}\n *     for all of the supported properties.\n * @param {boolean} [query.force] Suppress errors until all files have been\n *     processed.\n * @param {string} [query.userProject] The ID of the project which will be\n *     billed for the request.\n * @param {DeleteFilesCallback} [callback] Callback function.\n * @returns {Promise}\n *\n * @example\n * const storage = require('@google-cloud/storage')();\n * const bucket = storage.bucket('albums');\n *\n * //-\n * // Delete all of the files in the bucket.\n * //-\n * bucket.deleteFiles(function(err) {});\n *\n * //-\n * // By default, if a file cannot be deleted, this method will stop deleting\n * // files from your bucket. You can override this setting with `force: true`.\n * //-\n * bucket.deleteFiles({\n *   force: true\n * }, function(errors) {\n *   // `errors`:\n *   //    Array of errors if any occurred, otherwise null.\n * });\n *\n * //-\n * // The first argument to this method acts as a query to\n * // {@link Bucket#getFiles}. As an example, you can delete files\n * // which match a prefix.\n * //-\n * bucket.deleteFiles({\n *   prefix: 'images/'\n * }, function(err) {\n *   if (!err) {\n *     // All files in the `images` directory have been deleted.\n *   }\n * });\n *\n * //-\n * // If the callback is omitted, we'll return a Promise.\n * //-\n * bucket.deleteFiles().then(function() {});\n */\n\n\nBucket.prototype.deleteFiles = function (query, callback) {\n  if (is.fn(query)) {\n    callback = query;\n    query = {};\n  }\n\n  query = query || {};\n  var MAX_PARALLEL_LIMIT = 10;\n  var errors = [];\n  this.getFiles(query, function (err, files) {\n    if (err) {\n      callback(err);\n      return;\n    }\n\n    function deleteFile(file, callback) {\n      file.delete(query, function (err) {\n        if (err) {\n          if (query.force) {\n            errors.push(err);\n            callback();\n            return;\n          }\n\n          callback(err);\n          return;\n        }\n\n        callback();\n      });\n    } // Iterate through each file and attempt to delete it.\n\n\n    async.eachLimit(files, MAX_PARALLEL_LIMIT, deleteFile, function (err) {\n      if (err || errors.length > 0) {\n        callback(err || errors);\n        return;\n      }\n\n      callback();\n    });\n  });\n};\n/**\n * @typedef {array} DeleteLabelsResponse\n * @property {object} 0 The full API response.\n */\n\n/**\n * @callback DeleteLabelsCallback\n * @param {?Error} err Request error, if any.\n * @param {object} apiResponse The full API response.\n */\n\n/**\n * Delete one or more labels from this bucket.\n *\n * @param {string|string[]} labels The labels to delete. If no labels are\n *     provided, all of the labels are removed.\n * @param {DeleteLabelsCallback} [callback] Callback function.\n * @returns {Promise<DeleteLabelsResponse>}\n *\n * @example\n * const storage = require('@google-cloud/storage')();\n * const bucket = storage.bucket('albums');\n *\n * //-\n * // Delete all of the labels from this bucket.\n * //-\n * bucket.deleteLabels(function(err, apiResponse) {});\n *\n * //-\n * // Delete a single label.\n * //-\n * bucket.deleteLabels('labelone', function(err, apiResponse) {});\n *\n * //-\n * // Delete a specific set of labels.\n * //-\n * bucket.deleteLabels([\n *   'labelone',\n *   'labeltwo'\n * ], function(err, apiResponse) {});\n *\n * //-\n * // If the callback is omitted, we'll return a Promise.\n * //-\n * bucket.deleteLabels().then(function(data) {\n *   const apiResponse = data[0];\n * });\n */\n\n\nBucket.prototype.deleteLabels = function (labels, callback) {\n  var self = this;\n\n  if (is.fn(labels)) {\n    callback = labels;\n    labels = [];\n  }\n\n  labels = arrify(labels);\n\n  if (labels.length === 0) {\n    this.getLabels(function (err, labels) {\n      if (err) {\n        callback(err);\n        return;\n      }\n\n      deleteLabels(Object.keys(labels));\n    });\n  } else {\n    deleteLabels(labels);\n  }\n\n  function deleteLabels(labels) {\n    var nullLabelMap = labels.reduce(function (nullLabelMap, labelKey) {\n      nullLabelMap[labelKey] = null;\n      return nullLabelMap;\n    }, {});\n    self.setLabels(nullLabelMap, callback);\n  }\n};\n/**\n * @typedef {array} DisableRequesterPaysResponse\n * @property {object} 0 The full API response.\n */\n\n/**\n * @callback DisableRequesterPaysCallback\n * @param {?Error} err Request error, if any.\n * @param {object} apiResponse The full API response.\n */\n\n/**\n * <div class=\"notice\">\n *   <strong>Early Access Testers Only</strong>\n *   <p>\n *     This feature is not yet widely-available.\n *   </p>\n * </div>\n *\n * Disable `requesterPays` functionality from this bucket.\n *\n * @param {DisableRequesterPaysCallback} [callback] Callback function.\n * @returns {Promise<DisableRequesterPaysCallback>}\n *\n * @example\n * const storage = require('@google-cloud/storage')();\n * const bucket = storage.bucket('albums');\n *\n * bucket.disableRequesterPays(function(err, apiResponse) {\n *   if (!err) {\n *     // requesterPays functionality disabled successfully.\n *   }\n * });\n *\n * //-\n * // If the callback is omitted, we'll return a Promise.\n * //-\n * bucket.disableRequesterPays().then(function(data) {\n *   const apiResponse = data[0];\n * });\n *\n * @example <caption>include:samples/requesterPays.js</caption>\n * region_tag:storage_disable_requester_pays\n * Example of disabling requester pays:\n */\n\n\nBucket.prototype.disableRequesterPays = function (callback) {\n  this.setMetadata({\n    billing: {\n      requesterPays: false\n    }\n  }, callback || common.util.noop);\n};\n/**\n * @typedef {array} EnableRequesterPaysResponse\n * @property {object} 0 The full API response.\n */\n\n/**\n * @callback EnableRequesterPaysCallback\n * @param {?Error} err Request error, if any.\n * @param {object} apiResponse The full API response.\n */\n\n/**\n * <div class=\"notice\">\n *   <strong>Early Access Testers Only</strong>\n *   <p>\n *     This feature is not yet widely-available.\n *   </p>\n * </div>\n *\n * Enable `requesterPays` functionality for this bucket. This enables you, the\n * bucket owner, to have the requesting user assume the charges for the access\n * to your bucket and its contents.\n *\n * @param {EnableRequesterPaysCallback} [callback] Callback function.\n * @returns {Promise<EnableRequesterPaysResponse>}\n *\n * @example\n * const storage = require('@google-cloud/storage')();\n * const bucket = storage.bucket('albums');\n *\n * bucket.enableRequesterPays(function(err, apiResponse) {\n *   if (!err) {\n *     // requesterPays functionality enabled successfully.\n *   }\n * });\n *\n * //-\n * // If the callback is omitted, we'll return a Promise.\n * //-\n * bucket.enableRequesterPays().then(function(data) {\n *   const apiResponse = data[0];\n * });\n *\n * @example <caption>include:samples/requesterPays.js</caption>\n * region_tag:storage_enable_requester_pays\n * Example of enabling requester pays:\n */\n\n\nBucket.prototype.enableRequesterPays = function (callback) {\n  this.setMetadata({\n    billing: {\n      requesterPays: true\n    }\n  }, callback || common.util.noop);\n};\n/**\n * @typedef {array} BucketExistsResponse\n * @property {boolean} 0 Whether the {@link Bucket} exists.\n */\n\n/**\n * @callback BucketExistsCallback\n * @param {?Error} err Request error, if any.\n * @param {boolean} exists Whether the {@link Bucket} exists.\n */\n\n/**\n * Check if the bucket exists.\n *\n * @param {object} [options] Configuration options.\n * @param {string} [options.userProject] The ID of the project which will be\n *     billed for the request.\n * @param {BucketExistsCallback} [callback] Callback function.\n * @returns {Promise<BucketExistsResponse>}\n *\n * @example\n * const storage = require('@google-cloud/storage')();\n * const bucket = storage.bucket('albums');\n *\n * bucket.exists(function(err, exists) {});\n *\n * //-\n * // If the callback is omitted, we'll return a Promise.\n * //-\n * bucket.exists().then(function(data) {\n *   const exists = data[0];\n * });\n */\n\n\nBucket.prototype.exists = function (options, callback) {\n  if (is.fn(options)) {\n    callback = options;\n    options = {};\n  }\n\n  options = options || {};\n  this.get(options, function (err) {\n    if (err) {\n      if (err.code === 404) {\n        callback(null, false);\n      } else {\n        callback(err);\n      }\n\n      return;\n    }\n\n    callback(null, true);\n  });\n};\n/**\n * Create a {@link File} object. See {@link File} to see how to handle\n * the different use cases you may have.\n *\n * @param {string} name The name of the file in this bucket.\n * @param {object} [options] Configuration options.\n * @param {string|number} [options.generation] Only use a specific revision of\n *     this file.\n * @param {string} [options.encryptionKey] A custom encryption key. See\n *     [Customer-supplied Encryption Keys](https://cloud.google.com/storage/docs/encryption#customer-supplied).\n * @param {string} [options.kmsKeyName] The name of the Cloud KMS key that will\n *     be used to encrypt the object. Must be in the format:\n *     `projects/my-project/locations/location/keyRings/my-kr/cryptoKeys/my-key`.\n *     KMS key ring must use the same location as the bucket.\n * @returns {File}\n *\n * @example\n * const storage = require('@google-cloud/storage')();\n * const bucket = storage.bucket('albums');\n * const file = bucket.file('my-existing-file.png');\n */\n\n\nBucket.prototype.file = function (name, options) {\n  if (!name) {\n    throw Error('A file name must be specified.');\n  }\n\n  return new File(this, name, options);\n};\n/**\n * @typedef {array} GetBucketResponse\n * @property {Bucket} 0 The {@link Bucket}.\n * @property {object} 1 The full API response.\n */\n\n/**\n * @callback GetBucketCallback\n * @param {?Error} err Request error, if any.\n * @param {Bucket} bucket The {@link Bucket}.\n * @param {object} apiResponse The full API response.\n */\n\n/**\n * Get a bucket if it exists.\n *\n * You may optionally use this to \"get or create\" an object by providing an\n * object with `autoCreate` set to `true`. Any extra configuration that is\n * normally required for the `create` method must be contained within this\n * object as well.\n *\n * @param {object} [options] Configuration options.\n * @param {boolean} [options.autoCreate] Automatically create the object if\n *     it does not exist. Default: `false`\n * @param {string} [options.userProject] The ID of the project which will be\n *     billed for the request.\n * @param {GetBucketCallback} [callback] Callback function.\n * @returns {Promise<GetBucketResponse>}\n *\n * @example\n * const storage = require('@google-cloud/storage')();\n * const bucket = storage.bucket('albums');\n *\n * bucket.get(function(err, bucket, apiResponse) {\n *   // `bucket.metadata` has been populated.\n * });\n *\n * //-\n * // If the callback is omitted, we'll return a Promise.\n * //-\n * bucket.get().then(function(data) {\n *   const bucket = data[0];\n *   const apiResponse = data[1];\n * });\n */\n\n\nBucket.prototype.get = function (options, callback) {\n  var self = this;\n\n  if (is.fn(options)) {\n    callback = options;\n    options = {};\n  }\n\n  options = options || {};\n  var autoCreate = options.autoCreate;\n  delete options.autoCreate;\n\n  function onCreate(err, bucket, apiResponse) {\n    if (err) {\n      if (err.code === 409) {\n        self.get(options, callback);\n        return;\n      }\n\n      callback(err, null, apiResponse);\n      return;\n    }\n\n    callback(null, bucket, apiResponse);\n  }\n\n  this.getMetadata(options, function (err, metadata) {\n    if (err) {\n      if (err.code === 404 && autoCreate) {\n        var args = [];\n\n        if (!is.empty(options)) {\n          args.push(options);\n        }\n\n        args.push(onCreate);\n        self.create.apply(self, args);\n        return;\n      }\n\n      callback(err, null, metadata);\n      return;\n    }\n\n    callback(null, self, metadata);\n  });\n};\n/**\n * Query object for listing files.\n *\n * @typedef {object} GetFilesRequest\n * @property {boolean} [autoPaginate=true] Have pagination handled\n *     automatically.\n * @property {string} [delimiter] Results will contain only objects whose\n *     names, aside from the prefix, do not contain delimiter. Objects whose\n *     names, aside from the prefix, contain delimiter will have their name\n *     truncated after the delimiter, returned in `apiResponse.prefixes`.\n *     Duplicate prefixes are omitted.\n * @property {string} [directory] Filter results based on a directory name, or\n *     more technically, a \"prefix\".\n * @property {string} [prefix] Filter results to objects whose names begin\n *     with this prefix.\n * @property {number} [maxApiCalls] Maximum number of API calls to make.\n * @property {number} [maxResults] Maximum number of items plus prefixes to\n *     return.\n * @property {string} [pageToken] A previously-returned page token\n *     representing part of the larger set of results to view.\n * @property {string} [userProject] The ID of the project which will be\n *     billed for the request.\n * @property {boolean} [versions] If true, returns File objects scoped to\n *     their versions.\n */\n\n/**\n * @typedef {array} GetFilesResponse\n * @property {File[]} 0 Array of {@link File} instances.\n */\n\n/**\n * @callback GetFilesCallback\n * @param {?Error} err Request error, if any.\n * @param {File[]} files Array of {@link File} instances.\n */\n\n/**\n * Get {@link File} objects for the files currently in the bucket.\n *\n * @see [Objects: list API Documentation]{@link https://cloud.google.com/storage/docs/json_api/v1/objects/list}\n *\n * @param {GetFilesRequest} [query] Query object for listing files.\n * @param {GetFilesCallback} [callback] Callback function.\n * @returns {Promise<GetFilesResponse>}\n *\n * @example\n * const storage = require('@google-cloud/storage')();\n * const bucket = storage.bucket('albums');\n *\n * bucket.getFiles(function(err, files) {\n *   if (!err) {\n *     // files is an array of File objects.\n *   }\n * });\n *\n * //-\n * // If your bucket has versioning enabled, you can get all of your files\n * // scoped to their generation.\n * //-\n * bucket.getFiles({\n *   versions: true\n * }, function(err, files) {\n *   // Each file is scoped to its generation.\n * });\n *\n * //-\n * // To control how many API requests are made and page through the results\n * // manually, set `autoPaginate` to `false`.\n * //-\n * const callback = function(err, files, nextQuery, apiResponse) {\n *   if (nextQuery) {\n *     // More results exist.\n *     bucket.getFiles(nextQuery, callback);\n *   }\n *\n *   // The `metadata` property is populated for you with the metadata at the\n *   // time of fetching.\n *   files[0].metadata;\n *\n *   // However, in cases where you are concerned the metadata could have\n *   // changed, use the `getMetadata` method.\n *   files[0].getMetadata(function(err, metadata) {});\n * };\n *\n * bucket.getFiles({\n *   autoPaginate: false\n * }, callback);\n *\n * //-\n * // If the callback is omitted, we'll return a Promise.\n * //-\n * bucket.getFiles().then(function(data) {\n *   const files = data[0];\n * });\n *\n * @example <caption>include:samples/files.js</caption>\n * region_tag:storage_list_files\n * Another example:\n *\n * @example <caption>include:samples/files.js</caption>\n * region_tag:storage_list_files_with_prefix\n * Example of listing files, filtered by a prefix:\n */\n\n\nBucket.prototype.getFiles = function (query, callback) {\n  var self = this;\n\n  if (!callback) {\n    callback = query;\n    query = {};\n  }\n\n  query = extend({}, query);\n\n  if (query.directory) {\n    query.prefix = \"\".concat(query.directory, \"/\").replace(/\\/*$/, '/');\n    delete query.directory;\n  }\n\n  this.request({\n    uri: '/o',\n    qs: query\n  }, function (err, resp) {\n    if (err) {\n      callback(err, null, null, resp);\n      return;\n    }\n\n    var files = arrify(resp.items).map(function (file) {\n      var options = {};\n\n      if (query.versions) {\n        options.generation = file.generation;\n      }\n\n      if (file.kmsKeyName) {\n        options.kmsKeyName = file.kmsKeyName;\n      }\n\n      var fileInstance = self.file(file.name, options);\n      fileInstance.metadata = file;\n      return fileInstance;\n    });\n    var nextQuery = null;\n\n    if (resp.nextPageToken) {\n      nextQuery = extend({}, query, {\n        pageToken: resp.nextPageToken\n      });\n    }\n\n    callback(null, files, nextQuery, resp);\n  });\n};\n/**\n * Get {@link File} objects for the files currently in the bucket as a\n * readable object stream.\n *\n * @method Bucket#getFilesStream\n * @param {GetFilesRequest} [query] Query object for listing files.\n * @returns {ReadableStream} A readable stream that emits {@link File} instances.\n *\n * @example\n * const storage = require('@google-cloud/storage')();\n * const bucket = storage.bucket('albums');\n *\n * bucket.getFilesStream()\n *   .on('error', console.error)\n *   .on('data', function(file) {\n *     // file is a File object.\n *   })\n *   .on('end', function() {\n *     // All files retrieved.\n *   });\n *\n * //-\n * // If you anticipate many results, you can end a stream early to prevent\n * // unnecessary processing and API requests.\n * //-\n * bucket.getFilesStream()\n *   .on('data', function(file) {\n *     this.end();\n *   });\n */\n\n\nBucket.prototype.getFilesStream = common.paginator.streamify('getFiles');\n/**\n * @typedef {array} GetLabelsResponse\n * @property {object} 0 Object of labels currently set on this bucket.\n */\n\n/**\n * @callback GetLabelsCallback\n * @param {?Error} err Request error, if any.\n * @param {object} labels Object of labels currently set on this bucket.\n */\n\n/**\n * Get the labels currently set on this bucket.\n *\n * @param {object} [options] Configuration options.\n * @param {string} [options.userProject] The ID of the project which will be\n *     billed for the request.\n * @param {GetLabelsCallback} [callback] Callback function.\n * @returns {Promise<GetLabelsCallback>}\n *\n * @example\n * const storage = require('@google-cloud/storage')();\n * const bucket = storage.bucket('albums');\n *\n * bucket.getLabels(function(err, labels) {\n *   if (err) {\n *     // Error handling omitted.\n *   }\n *\n *   // labels = {\n *   //   label: 'labelValue',\n *   //   ...\n *   // }\n * });\n *\n * //-\n * // If the callback is omitted, we'll return a Promise.\n * //-\n * bucket.getLabels().then(function(data) {\n *   const labels = data[0];\n * });\n */\n\nBucket.prototype.getLabels = function (options, callback) {\n  if (is.fn(options)) {\n    callback = options;\n    options = {};\n  }\n\n  this.getMetadata(options, function (err, metadata) {\n    if (err) {\n      callback(err);\n      return;\n    }\n\n    callback(null, metadata.labels || {});\n  });\n};\n/**\n * @typedef {array} GetBucketMetadataResponse\n * @property {object} 0 The bucket metadata.\n * @property {object} 1 The full API response.\n */\n\n/**\n * @callback GetBucketMetadataCallback\n * @param {?Error} err Request error, if any.\n * @param {object} files The bucket metadata.\n * @param {object} apiResponse The full API response.\n */\n\n/**\n * Get the bucket's metadata.\n *\n * To set metadata, see {@link Bucket#setMetadata}.\n *\n * @see [Buckets: get API Documentation]{@link https://cloud.google.com/storage/docs/json_api/v1/buckets/get}\n *\n * @param {object} [options] Configuration options.\n * @param {string} [options.userProject] The ID of the project which will be\n *     billed for the request.\n * @param {GetBucketMetadataCallback} [callback] Callback function.\n * @returns {Promise<GetBucketMetadataResponse>}\n *\n * @example\n * const storage = require('@google-cloud/storage')();\n * const bucket = storage.bucket('albums');\n *\n * bucket.getMetadata(function(err, metadata, apiResponse) {});\n *\n * //-\n * // If the callback is omitted, we'll return a Promise.\n * //-\n * bucket.getMetadata().then(function(data) {\n *   const metadata = data[0];\n *   const apiResponse = data[1];\n * });\n *\n * @example <caption>include:samples/requesterPays.js</caption>\n * region_tag:storage_get_requester_pays_status\n * Example of retrieving the requester pays status of a bucket:\n */\n\n\nBucket.prototype.getMetadata = function (options, callback) {\n  var self = this;\n\n  if (is.fn(options)) {\n    callback = options;\n    options = {};\n  }\n\n  this.request({\n    uri: '',\n    qs: options\n  }, function (err, resp) {\n    if (err) {\n      callback(err, null, resp);\n      return;\n    }\n\n    self.metadata = resp;\n    callback(null, self.metadata, resp);\n  });\n};\n/**\n * @typedef {array} GetNotificationsResponse\n * @property {Notification[]} 0 Array of {@link Notification} instances.\n * @property {object} 1 The full API response.\n */\n\n/**\n * @callback GetNotificationsCallback\n * @param {?Error} err Request error, if any.\n * @param {Notification[]} notifications Array of {@link Notification}\n *     instances.\n * @param {object} apiResponse The full API response.\n */\n\n/**\n * Retrieves a list of notification subscriptions for a given bucket.\n *\n * @see [Notifications: list]{@link https://cloud.google.com/storage/docs/json_api/v1/notifications/list}\n *\n * @param {object} [options] Configuration options.\n * @param {string} [options.userProject] The ID of the project which will be\n *     billed for the request.\n * @param {GetNotificationsCallback} [callback] Callback function.\n * @returns {Promise<GetNotificationsResponse>}\n *\n * @example\n * const storage = require('@google-cloud/storage')();\n * const bucket = storage.bucket('my-bucket');\n *\n * bucket.getNotifications(function(err, notifications, apiResponse) {\n *   if (!err) {\n *     // notifications is an array of Notification objects.\n *   }\n * });\n *\n * //-\n * // If the callback is omitted, we'll return a Promise.\n * //-\n * bucket.getNotifications().then(function(data) {\n *   const notifications = data[0];\n *   const apiResponse = data[1];\n * });\n *\n * @example <caption>include:samples/notifications.js</caption>\n * region_tag:storage_list_notifications\n * Another example:\n */\n\n\nBucket.prototype.getNotifications = function (options, callback) {\n  var self = this;\n\n  if (is.fn(options)) {\n    callback = options;\n    options = {};\n  }\n\n  this.request({\n    uri: '/notificationConfigs',\n    qs: options\n  }, function (err, resp) {\n    if (err) {\n      callback(err, null, resp);\n      return;\n    }\n\n    var notifications = arrify(resp.items).map(function (notification) {\n      var notificationInstance = self.notification(notification.id);\n      notificationInstance.metadata = notification;\n      return notificationInstance;\n    });\n    callback(null, notifications, resp);\n  });\n};\n/**\n * @typedef {array} MakeBucketPrivateResponse\n * @property {File[]} 0 List of files made private.\n */\n\n/**\n * @callback MakeBucketPrivateCallback\n * @param {?Error} err Request error, if any.\n * @param {File[]} files List of files made private.\n */\n\n/**\n * Make the bucket listing private.\n *\n * You may also choose to make the contents of the bucket private by specifying\n * `includeFiles: true`. This will automatically run\n * {@link File#makePrivate} for every file in the bucket.\n *\n * When specifying `includeFiles: true`, use `force: true` to delay execution of\n * your callback until all files have been processed. By default, the callback\n * is executed after the first error. Use `force` to queue such errors until all\n * files have been processed, after which they will be returned as an array as\n * the first argument to your callback.\n *\n * NOTE: This may cause the process to be long-running and use a high number of\n * requests. Use with caution.\n *\n * @see [Buckets: patch API Documentation]{@link https://cloud.google.com/storage/docs/json_api/v1/buckets/patch}\n *\n * @param {object} [options] Configuration options.\n * @param {boolean} [options.includeFiles=false] Make each file in the bucket\n *     private.\n * @param {boolean} [options.force] Queue errors occurred while making files\n *     private until all files have been processed.\n * @param {string} [options.userProject] The ID of the project which will be\n *     billed for the request.\n * @param {MakeBucketPrivateCallback} [callback] Callback function.\n * @returns {Promise<MakeBucketPrivateResponse>}\n *\n * @example\n * const storage = require('@google-cloud/storage')();\n * const bucket = storage.bucket('albums');\n *\n * //-\n * // Make the bucket private.\n * //-\n * bucket.makePrivate(function(err) {});\n *\n * //-\n * // Make the bucket and its contents private.\n * //-\n * const opts = {\n *   includeFiles: true\n * };\n *\n * bucket.makePrivate(opts, function(err, files) {\n *   // `err`:\n *   //    The first error to occur, otherwise null.\n *   //\n *   // `files`:\n *   //    Array of files successfully made private in the bucket.\n * });\n *\n * //-\n * // Make the bucket and its contents private, using force to suppress errors\n * // until all files have been processed.\n * //-\n * const opts = {\n *   includeFiles: true,\n *   force: true\n * };\n *\n * bucket.makePrivate(opts, function(errors, files) {\n *   // `errors`:\n *   //    Array of errors if any occurred, otherwise null.\n *   //\n *   // `files`:\n *   //    Array of files successfully made private in the bucket.\n * });\n *\n * //-\n * // If the callback is omitted, we'll return a Promise.\n * //-\n * bucket.makePrivate(opts).then(function(data) {\n *   const files = data[0];\n * });\n */\n\n\nBucket.prototype.makePrivate = function (options, callback) {\n  var self = this;\n\n  if (is.fn(options)) {\n    callback = options;\n    options = {};\n  }\n\n  options = options || {};\n  options.private = true;\n  async.series([setPredefinedAcl, makeFilesPrivate], callback);\n\n  function setPredefinedAcl(done) {\n    var query = {\n      predefinedAcl: 'projectPrivate'\n    };\n\n    if (options.userProject) {\n      query.userProject = options.userProject;\n    }\n\n    self.setMetadata({\n      // You aren't allowed to set both predefinedAcl & acl properties on a\n      // bucket so acl must explicitly be nullified.\n      acl: null\n    }, query, done);\n  }\n\n  function makeFilesPrivate(done) {\n    if (!options.includeFiles) {\n      done();\n      return;\n    }\n\n    self.makeAllFilesPublicPrivate_(options, done);\n  }\n};\n/**\n * @typedef {array} MakeBucketPublicResponse\n * @property {File[]} 0 List of files made public.\n */\n\n/**\n * @callback MakeBucketPublicCallback\n * @param {?Error} err Request error, if any.\n * @param {File[]} files List of files made public.\n */\n\n/**\n * Make the bucket publicly readable.\n *\n * You may also choose to make the contents of the bucket publicly readable by\n * specifying `includeFiles: true`. This will automatically run\n * {@link File#makePublic} for every file in the bucket.\n *\n * When specifying `includeFiles: true`, use `force: true` to delay execution of\n * your callback until all files have been processed. By default, the callback\n * is executed after the first error. Use `force` to queue such errors until all\n * files have been processed, after which they will be returned as an array as\n * the first argument to your callback.\n *\n * NOTE: This may cause the process to be long-running and use a high number of\n * requests. Use with caution.\n *\n * @see [Buckets: patch API Documentation]{@link https://cloud.google.com/storage/docs/json_api/v1/buckets/patch}\n *\n * @param {object} [options] Configuration options.\n * @param {boolean} [options.includeFiles=false] Make each file in the bucket\n *     publicly readable.\n * @param {boolean} [options.force] Queue errors occurred while making files\n *     public until all files have been processed.\n * @param {MakeBucketPublicCallback} [callback] Callback function.\n * @returns {Promise<MakeBucketPublicResponse>}\n *\n * @example\n * const storage = require('@google-cloud/storage')();\n * const bucket = storage.bucket('albums');\n *\n * //-\n * // Make the bucket publicly readable.\n * //-\n * bucket.makePublic(function(err) {});\n *\n * //-\n * // Make the bucket and its contents publicly readable.\n * //-\n * const opts = {\n *   includeFiles: true\n * };\n *\n * bucket.makePublic(opts, function(err, files) {\n *   // `err`:\n *   //    The first error to occur, otherwise null.\n *   //\n *   // `files`:\n *   //    Array of files successfully made public in the bucket.\n * });\n *\n * //-\n * // Make the bucket and its contents publicly readable, using force to\n * // suppress errors until all files have been processed.\n * //-\n * const opts = {\n *   includeFiles: true,\n *   force: true\n * };\n *\n * bucket.makePublic(opts, function(errors, files) {\n *   // `errors`:\n *   //    Array of errors if any occurred, otherwise null.\n *   //\n *   // `files`:\n *   //    Array of files successfully made public in the bucket.\n * });\n *\n * //-\n * // If the callback is omitted, we'll return a Promise.\n * //-\n * bucket.makePublic(opts).then(function(data) {\n *   const files = data[0];\n * });\n */\n\n\nBucket.prototype.makePublic = function (options, callback) {\n  var self = this;\n\n  if (is.fn(options)) {\n    callback = options;\n    options = {};\n  }\n\n  options = options || {};\n  options.public = true;\n  async.series([addAclPermissions, addDefaultAclPermissions, makeFilesPublic], callback);\n\n  function addAclPermissions(done) {\n    // Allow reading bucket contents while preserving original permissions.\n    self.acl.add({\n      entity: 'allUsers',\n      role: 'READER'\n    }, done);\n  }\n\n  function addDefaultAclPermissions(done) {\n    self.acl.default.add({\n      entity: 'allUsers',\n      role: 'READER'\n    }, done);\n  }\n\n  function makeFilesPublic(done) {\n    if (!options.includeFiles) {\n      done();\n      return;\n    }\n\n    self.makeAllFilesPublicPrivate_(options, done);\n  }\n};\n/**\n * Get a reference to a Cloud Pub/Sub Notification.\n *\n * @param {string} id ID of notification.\n * @returns {Notification}\n * @see Notification\n *\n * @example\n * const storage = require('@google-cloud/storage')();\n * const bucket = storage.bucket('my-bucket');\n * const notification = bucket.notification('1');\n */\n\n\nBucket.prototype.notification = function (id) {\n  if (!id) {\n    throw new Error('You must supply a notification ID.');\n  }\n\n  return new Notification(this, id);\n};\n/**\n * Makes request and applies userProject query parameter if necessary.\n *\n * @private\n *\n * @param {object} reqOpts - The request options.\n * @param {function} callback - The callback function.\n */\n\n\nBucket.prototype.request = function (reqOpts, callback) {\n  if (this.userProject && (!reqOpts.qs || !reqOpts.qs.userProject)) {\n    reqOpts.qs = extend(reqOpts.qs, {\n      userProject: this.userProject\n    });\n  }\n\n  return common.ServiceObject.prototype.request.call(this, reqOpts, callback);\n};\n/**\n * @typedef {array} SetLabelsResponse\n * @property {object} 0 The bucket metadata.\n */\n\n/**\n * @callback SetLabelsCallback\n * @param {?Error} err Request error, if any.\n * @param {object} metadata The bucket metadata.\n */\n\n/**\n * Set labels on the bucket.\n *\n * This makes an underlying call to {@link Bucket#setMetadata}, which\n * is a PATCH request. This means an individual label can be overwritten, but\n * unmentioned labels will not be touched.\n *\n * @param {object<string, string>} labels Labels to set on the bucket.\n * @param {object} [options] Configuration options.\n * @param {string} [options.userProject] The ID of the project which will be\n *     billed for the request.\n * @param {SetLabelsCallback} [callback] Callback function.\n * @returns {Promise<SetLabelsResponse>}\n *\n * @example\n * const storage = require('@google-cloud/storage')();\n * const bucket = storage.bucket('albums');\n *\n * const labels = {\n *   labelone: 'labelonevalue',\n *   labeltwo: 'labeltwovalue'\n * };\n *\n * bucket.setLabels(labels, function(err, metadata) {\n *   if (!err) {\n *     // Labels set successfully.\n *   }\n * });\n *\n * //-\n * // If the callback is omitted, we'll return a Promise.\n * //-\n * bucket.setLabels(labels).then(function(data) {\n *   const metadata = data[0];\n * });\n */\n\n\nBucket.prototype.setLabels = function (labels, options, callback) {\n  if (is.fn(options)) {\n    callback = options;\n    options = {};\n  }\n\n  callback = callback || common.util.noop;\n  this.setMetadata({\n    labels: labels\n  }, options, callback);\n};\n/**\n * @typedef {array} SetBucketMetadataResponse\n * @property {object} 0 The bucket metadata.\n */\n\n/**\n * @callback SetBucketMetadataCallback\n * @param {?Error} err Request error, if any.\n * @param {object} metadata The bucket metadata.\n */\n\n/**\n * Set the bucket's metadata.\n *\n * @see [Buckets: patch API Documentation]{@link https://cloud.google.com/storage/docs/json_api/v1/buckets/patch}\n *\n * @param {object<string, *>} metadata The metadata you wish to set.\n * @param {object} [options] Configuration options.\n * @param {string} [options.userProject] The ID of the project which will be\n *     billed for the request.\n * @param {SetBucketMetadataCallback} [callback] Callback function.\n * @returns {Promise<SetBucketMetadataResponse>}\n *\n * @example\n * const storage = require('@google-cloud/storage')();\n * const bucket = storage.bucket('albums');\n *\n * //-\n * // Set website metadata field on the bucket.\n * //-\n * const metadata = {\n *   website: {\n *     mainPageSuffix: 'http://example.com',\n *     notFoundPage: 'http://example.com/404.html'\n *   }\n * };\n *\n * bucket.setMetadata(metadata, function(err, apiResponse) {});\n *\n * //-\n * // Enable versioning for your bucket.\n * //-\n * bucket.setMetadata({\n *   versioning: {\n *     enabled: true\n *   }\n * }, function(err, apiResponse) {});\n *\n * //-\n * // Enable KMS encryption for objects within this bucket.\n * //-\n * bucket.setMetadata({\n *   encryption: {\n *     defaultKmsKeyName: 'projects/grape-spaceship-123/...'\n *   }\n * }, function(err, apiResponse) {});\n *\n * //-\n * // If the callback is omitted, we'll return a Promise.\n * //-\n * bucket.setMetadata(metadata).then(function(data) {\n *   const apiResponse = data[0];\n * });\n */\n\n\nBucket.prototype.setMetadata = function (metadata, options, callback) {\n  var self = this;\n\n  if (is.fn(options)) {\n    callback = options;\n    options = {};\n  }\n\n  callback = callback || common.util.noop;\n  this.request({\n    method: 'PATCH',\n    uri: '',\n    json: metadata,\n    qs: options\n  }, function (err, resp) {\n    if (err) {\n      callback(err, resp);\n      return;\n    }\n\n    self.metadata = resp;\n    callback(null, resp);\n  });\n};\n/**\n * @callback SetStorageClassCallback\n * @param {?Error} err Request error, if any.\n */\n\n/**\n * Set the default storage class for new files in this bucket.\n *\n * @see [Storage Classes]{@link https://cloud.google.com/storage/docs/storage-classes}\n *\n * @param {string} storageClass The new storage class. (`multi_regional`,\n *     `regional`, `standard`, `nearline`, `coldline`, or\n *     `durable_reduced_availability`)\n * @param {object} [options] Configuration options.\n * @param {string} [options.userProject] - The ID of the project which will be\n *     billed for the request.\n * @param {SetStorageClassCallback} [callback] Callback function.\n * @returns {Promise}\n *\n * @example\n * const storage = require('@google-cloud/storage')();\n * const bucket = storage.bucket('albums');\n *\n * bucket.setStorageClass('regional', function(err, apiResponse) {\n *   if (err) {\n *     // Error handling omitted.\n *   }\n *\n *   // The storage class was updated successfully.\n * });\n *\n * //-\n * // If the callback is omitted, we'll return a Promise.\n * //-\n * bucket.setStorageClass('regional').then(function() {});\n */\n\n\nBucket.prototype.setStorageClass = function (storageClass, options, callback) {\n  // In case we get input like `storageClass`, convert to `storage_class`.\n  storageClass = storageClass.replace(/-/g, '_').replace(/([a-z])([A-Z])/g, function (_, low, up) {\n    return low + '_' + up;\n  }).toUpperCase();\n  this.setMetadata({\n    storageClass: storageClass\n  }, options, callback);\n};\n/**\n * Set a user project to be billed for all requests made from this Bucket\n * object and any files referenced from this Bucket object.\n *\n * @param {string} userProject The user project.\n *\n * @example\n * const storage = require('@google-cloud/storage')();\n * const bucket = storage.bucket('albums');\n *\n * bucket.setUserProject('grape-spaceship-123');\n */\n\n\nBucket.prototype.setUserProject = function (userProject) {\n  this.userProject = userProject;\n};\n/**\n * @typedef {array} UploadResponse\n * @property {object} 0 The uploaded {@link File}.\n * @property {object} 1 The full API response.\n */\n\n/**\n * @callback UploadCallback\n * @param {?Error} err Request error, if any.\n * @param {object} metadata The uploaded {@link File}.\n * @param {object} apiResponse The full API response.\n */\n\n/**\n * Upload a file to the bucket. This is a convenience method that wraps\n * {@link File#createWriteStream}.\n *\n * You can specify whether or not an upload is resumable by setting\n * `options.resumable`. *Resumable uploads are enabled by default if your input\n * file is larger than 5 MB.*\n *\n * For faster crc32c computation, you must manually install\n * [`fast-crc32c`](http://www.gitnpm.com/fast-crc32c):\n *\n *     $ npm install --save fast-crc32c\n *\n * @see [Upload Options (Simple or Resumable)]{@link https://cloud.google.com/storage/docs/json_api/v1/how-tos/upload#uploads}\n * @see [Objects: insert API Documentation]{@link https://cloud.google.com/storage/docs/json_api/v1/objects/insert}\n *\n * @param {string} pathString The fully qualified path or url to the file you\n *     wish to upload to your bucket.\n * @param {object} [options] Configuration options.\n * @param {string|File} [options.destination] The place to save\n *     your file. If given a string, the file will be uploaded to the bucket\n *     using the string as a filename. When given a File object, your local file\n *     will be uploaded to the File object's bucket and under the File object's\n *     name. Lastly, when this argument is omitted, the file is uploaded to your\n *     bucket using the name of the local file or the path of the url relative to it's domain.\n * @param {string} [options.encryptionKey] A custom encryption key. See\n *     [Customer-supplied Encryption Keys](https://cloud.google.com/storage/docs/encryption#customer-supplied).\n * @param {boolean} [options.gzip] Automatically gzip the file. This will set\n *     `options.metadata.contentEncoding` to `gzip`.\n * @param {string} [options.kmsKeyName] The name of the Cloud KMS key that will\n *     be used to encrypt the object. Must be in the format:\n *     `projects/my-project/locations/location/keyRings/my-kr/cryptoKeys/my-key`.\n * @param {object} [options.metadata] See an\n *     [Objects: insert request body](https://cloud.google.com/storage/docs/json_api/v1/objects/insert#request_properties_JSON).\n * @param {string} [options.offset] The starting byte of the upload stream, for\n *     resuming an interrupted upload. Defaults to 0.\n * @param {string} [options.predefinedAcl] Apply a predefined set of access\n *     controls to this object.\n *\n *     Acceptable values are:\n *     - **`authenticatedRead`** - Object owner gets `OWNER` access, and\n *       `allAuthenticatedUsers` get `READER` access.\n *\n *     - **`bucketOwnerFullControl`** - Object owner gets `OWNER` access, and\n *       project team owners get `OWNER` access.\n *\n *     - **`bucketOwnerRead`** - Object owner gets `OWNER` access, and project\n *       team owners get `READER` access.\n *\n *     - **`private`** - Object owner gets `OWNER` access.\n *\n *     - **`projectPrivate`** - Object owner gets `OWNER` access, and project\n *       team members get access according to their roles.\n *\n *     - **`publicRead`** - Object owner gets `OWNER` access, and `allUsers` get\n *       `READER` access.\n * @param {boolean} [options.private] Make the uploaded file private. (Alias for\n *     `options.predefinedAcl = 'private'`)\n * @param {boolean} [options.public] Make the uploaded file public. (Alias for\n *     `options.predefinedAcl = 'publicRead'`)\n * @param {boolean} [options.resumable] Force a resumable upload. (default:\n *     true for files larger than 5 MB).\n * @param {string} [options.uri] The URI for an already-created resumable\n *     upload. See {@link File#createResumableUpload}.\n * @param {string} [options.userProject] The ID of the project which will be\n *     billed for the request.\n * @param {string|boolean} [options.validation] Possible values: `\"md5\"`,\n *     `\"crc32c\"`, or `false`. By default, data integrity is validated with an\n *     MD5 checksum for maximum reliability. CRC32c will provide better\n *     performance with less reliability. You may also choose to skip validation\n *     completely, however this is **not recommended**.\n * @param {object} [options.requestOptions] When `pathString` is a URL,\n *     additional [options for the HTTP request](https://github.com/request/request#requestoptions-callback)\n *     could be provided here.\n * @param {UploadCallback} [callback] Callback function.\n * @returns {Promise<UploadResponse>}\n *\n * @example\n * const storage = require('@google-cloud/storage')();\n * const bucket = storage.bucket('albums');\n *\n * //-\n * // Upload a file from a local path.\n * //-\n * bucket.upload('/local/path/image.png', function(err, file, apiResponse) {\n *   // Your bucket now contains:\n *   // - \"image.png\" (with the contents of `/local/path/image.png')\n *\n *   // `file` is an instance of a File object that refers to your new file.\n * });\n *\n * //-\n * // You can also upload a file from a URL.\n * //-\n *\n * bucket.upload('https://example.com/images/image.png', function(err, file, apiResponse) {\n *   // Your bucket now contains:\n *   // - \"image.png\"\n *\n *   // `file` is an instance of a File object that refers to your new file.\n * });\n *\n * //-\n * // It's not always that easy. You will likely want to specify the filename\n * // used when your new file lands in your bucket.\n * //\n * // You may also want to set metadata or customize other options.\n * //-\n * const options = {\n *   destination: 'new-image.png',\n *   resumable: true,\n *   validation: 'crc32c',\n *   metadata: {\n *     metadata: {\n *       event: 'Fall trip to the zoo'\n *     }\n *   }\n * };\n *\n * bucket.upload('local-image.png', options, function(err, file) {\n *   // Your bucket now contains:\n *   // - \"new-image.png\" (with the contents of `local-image.png')\n *\n *   // `file` is an instance of a File object that refers to your new file.\n * });\n *\n * //-\n * // You can also have a file gzip'd on the fly.\n * //-\n * bucket.upload('index.html', { gzip: true }, function(err, file) {\n *   // Your bucket now contains:\n *   // - \"index.html\" (automatically compressed with gzip)\n *\n *   // Downloading the file with `file.download` will automatically decode the\n *   // file.\n * });\n *\n * //-\n * // You may also re-use a File object, {File}, that references\n * // the file you wish to create or overwrite.\n * //-\n * const options = {\n *   destination: bucket.file('existing-file.png'),\n *   resumable: false\n * };\n *\n * bucket.upload('local-img.png', options, function(err, newFile) {\n *   // Your bucket now contains:\n *   // - \"existing-file.png\" (with the contents of `local-img.png')\n *\n *   // Note:\n *   // The `newFile` parameter is equal to `file`.\n * });\n *\n * //-\n * // To use\n * // <a href=\"https://cloud.google.com/storage/docs/encryption#customer-supplied\">\n * // Customer-supplied Encryption Keys</a>, provide the `encryptionKey` option.\n * //-\n * const crypto = require('crypto');\n * const encryptionKey = crypto.randomBytes(32);\n *\n * bucket.upload('img.png', {\n *   encryptionKey: encryptionKey\n * }, function(err, newFile) {\n *   // `img.png` was uploaded with your custom encryption key.\n *\n *   // `newFile` is already configured to use the encryption key when making\n *   // operations on the remote object.\n *\n *   // However, to use your encryption key later, you must create a `File`\n *   // instance with the `key` supplied:\n *   const file = bucket.file('img.png', {\n *     encryptionKey: encryptionKey\n *   });\n *\n *   // Or with `file#setEncryptionKey`:\n *   const file = bucket.file('img.png');\n *   file.setEncryptionKey(encryptionKey);\n * });\n *\n * //-\n * // If the callback is omitted, we'll return a Promise.\n * //-\n * bucket.upload('local-image.png').then(function(data) {\n *   const file = data[0];\n * });\n *\n * //-\n * // Additional options for download request could be provided.\n * //-\n * bucket.upload('https://example.com/images/image.png', {\n *   requestOptions: {\n *     headers: {\n *       'User-Agent': 'curl/7.54.0'\n *     }\n *   }\n * }, function(err, newFile) {\n *   // Custom `User-Agent` header will be used for the download request of\n *   // \"https://example.com/images/image.png\".\n * });\n *\n * @example <caption>include:samples/files.js</caption>\n * region_tag:storage_upload_file\n * Another example:\n *\n * @example <caption>include:samples/encryption.js</caption>\n * region_tag:storage_upload_encrypted_file\n * Example of uploading an encrypted file:\n */\n\n\nBucket.prototype.upload = function (pathString, options, callback) {\n  if (global.GCLOUD_SANDBOX_ENV) {\n    return;\n  }\n\n  var isURL = /^(http|https):/.test(pathString);\n\n  if (is.fn(options)) {\n    callback = options;\n    options = {};\n  }\n\n  options = extend({\n    metadata: {}\n  }, options);\n  var requestOptions = Object.assign({\n    url: pathString\n  }, options.requestOptions);\n  var newFile;\n\n  if (options.destination instanceof File) {\n    newFile = options.destination;\n  } else if (is.string(options.destination)) {\n    // Use the string as the name of the file.\n    newFile = this.file(options.destination, {\n      encryptionKey: options.encryptionKey,\n      kmsKeyName: options.kmsKeyName\n    });\n  } else {\n    // Resort to using the name of the incoming file.\n    var destination = path.basename(pathString);\n    newFile = this.file(destination, {\n      encryptionKey: options.encryptionKey,\n      kmsKeyName: options.kmsKeyName\n    });\n  }\n\n  var contentType = mime.contentType(path.basename(pathString));\n\n  if (contentType && !options.metadata.contentType) {\n    options.metadata.contentType = contentType;\n  }\n\n  if (is.boolean(options.resumable)) {\n    upload();\n  } else if (isURL) {\n    request.head(requestOptions, function (err, resp) {\n      if (err) {\n        callback(err);\n        return;\n      }\n\n      var contentLength = resp.headers['content-length'];\n\n      if (is.number(contentLength)) {\n        options.resumable = contentLength > RESUMABLE_THRESHOLD;\n      }\n\n      upload();\n    });\n  } else {\n    // Determine if the upload should be resumable if it's over the threshold.\n    fs.stat(pathString, function (err, fd) {\n      if (err) {\n        callback(err);\n        return;\n      }\n\n      options.resumable = fd.size > RESUMABLE_THRESHOLD;\n      upload();\n    });\n  }\n\n  function upload() {\n    var sourceStream;\n\n    if (isURL) {\n      sourceStream = request.get(requestOptions);\n    } else {\n      sourceStream = fs.createReadStream(pathString);\n    }\n\n    sourceStream.on('error', callback).pipe(newFile.createWriteStream(options)).on('error', callback).on('finish', function () {\n      callback(null, newFile, newFile.metadata);\n    });\n  }\n};\n/**\n * Iterate over all of a bucket's files, calling `file.makePublic()` (public)\n * or `file.makePrivate()` (private) on each.\n *\n * Operations are performed in parallel, up to 10 at once. The first error\n * breaks the loop, and will execute the provided callback with it. Specify\n * `{ force: true }` to suppress the errors.\n *\n * @private\n *\n * @param {object} options] Configuration options.\n * @param {boolean} [options.force] Suppress errors until all files have been\n *     processed.\n * @param {boolean} [options.private] Make files private.\n * @param {boolean} [options.public] Make files public.\n * @param {string} [options.userProject] The ID of the project which will be\n *     billed for the request.\n * @param {function} callback Callback function.\n */\n\n\nBucket.prototype.makeAllFilesPublicPrivate_ = function (options, callback) {\n  var MAX_PARALLEL_LIMIT = 10;\n  var errors = [];\n  var updatedFiles = [];\n  this.getFiles(options, function (err, files) {\n    if (err) {\n      callback(err);\n      return;\n    }\n\n    function processFile(file, callback) {\n      if (options.public) {\n        file.makePublic(processedCallback);\n      } else if (options.private) {\n        file.makePrivate(options, processedCallback);\n      }\n\n      function processedCallback(err) {\n        if (err) {\n          if (options.force) {\n            errors.push(err);\n            callback();\n            return;\n          }\n\n          callback(err);\n          return;\n        }\n\n        updatedFiles.push(file);\n        callback();\n      }\n    } // Iterate through each file and make it public or private.\n\n\n    async.eachLimit(files, MAX_PARALLEL_LIMIT, processFile, function (err) {\n      if (err || errors.length > 0) {\n        callback(err || errors, updatedFiles);\n        return;\n      }\n\n      callback(null, updatedFiles);\n    });\n  });\n};\n/*! Developer Documentation\n *\n * These methods can be auto-paginated.\n */\n\n\ncommon.paginator.extend(Bucket, 'getFiles');\n/*! Developer Documentation\n *\n * All async methods (except for streams) will return a Promise in the event\n * that a callback is omitted.\n */\n\ncommon.util.promisifyAll(Bucket, {\n  exclude: ['file', 'notification']\n});\n/**\n * Reference to the {@link Bucket} class.\n * @name module:@google-cloud/storage.Bucket\n * @see Bucket\n */\n\nmodule.exports = Bucket;","map":null,"metadata":{},"sourceType":"script"}