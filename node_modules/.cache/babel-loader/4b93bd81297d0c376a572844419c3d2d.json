{"ast":null,"code":"\"use strict\";\n\nvar _classCallCheck = require(\"/Users/cvoisin/Repos/actandcaredev/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _possibleConstructorReturn = require(\"/Users/cvoisin/Repos/actandcaredev/node_modules/@babel/runtime/helpers/possibleConstructorReturn\");\n\nvar _getPrototypeOf = require(\"/Users/cvoisin/Repos/actandcaredev/node_modules/@babel/runtime/helpers/getPrototypeOf\");\n\nvar _inherits = require(\"/Users/cvoisin/Repos/actandcaredev/node_modules/@babel/runtime/helpers/inherits\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar client_1 = require(\"./client\");\n/**\n * Map with short names for each of the requester maker functions. Used in\n * makeClientConstructor\n * @private\n */\n\n\nvar requesterFuncs = {\n  unary: client_1.Client.prototype.makeUnaryRequest,\n  server_stream: client_1.Client.prototype.makeServerStreamRequest,\n  client_stream: client_1.Client.prototype.makeClientStreamRequest,\n  bidi: client_1.Client.prototype.makeBidiStreamRequest\n};\n/**\n * Creates a constructor for a client with the given methods, as specified in\n * the methods argument. The resulting class will have an instance method for\n * each method in the service, which is a partial application of one of the\n * [Client]{@link grpc.Client} request methods, depending on `requestSerialize`\n * and `responseSerialize`, with the `method`, `serialize`, and `deserialize`\n * arguments predefined.\n * @param methods An object mapping method names to\n *     method attributes\n * @param serviceName The fully qualified name of the service\n * @param classOptions An options object.\n * @return New client constructor, which is a subclass of\n *     {@link grpc.Client}, and has the same arguments as that constructor.\n */\n\nfunction makeClientConstructor(methods, serviceName, classOptions) {\n  if (!classOptions) {\n    classOptions = {};\n  }\n\n  var ServiceClientImpl =\n  /*#__PURE__*/\n  function (_client_1$Client) {\n    _inherits(ServiceClientImpl, _client_1$Client);\n\n    function ServiceClientImpl() {\n      _classCallCheck(this, ServiceClientImpl);\n\n      return _possibleConstructorReturn(this, _getPrototypeOf(ServiceClientImpl).apply(this, arguments));\n    }\n\n    return ServiceClientImpl;\n  }(client_1.Client);\n\n  Object.keys(methods).forEach(function (name) {\n    var attrs = methods[name];\n    var methodType; // TODO(murgatroid99): Verify that we don't need this anymore\n\n    if (typeof name === 'string' && name.charAt(0) === '$') {\n      throw new Error('Method names cannot start with $');\n    }\n\n    if (attrs.requestStream) {\n      if (attrs.responseStream) {\n        methodType = 'bidi';\n      } else {\n        methodType = 'client_stream';\n      }\n    } else {\n      if (attrs.responseStream) {\n        methodType = 'server_stream';\n      } else {\n        methodType = 'unary';\n      }\n    }\n\n    var serialize = attrs.requestSerialize;\n    var deserialize = attrs.responseDeserialize;\n    var methodFunc = partial(requesterFuncs[methodType], attrs.path, serialize, deserialize);\n    ServiceClientImpl.prototype[name] = methodFunc; // Associate all provided attributes with the method\n\n    Object.assign(ServiceClientImpl.prototype[name], attrs);\n\n    if (attrs.originalName) {\n      ServiceClientImpl.prototype[attrs.originalName] = ServiceClientImpl.prototype[name];\n    }\n  });\n  ServiceClientImpl.service = methods;\n  return ServiceClientImpl;\n}\n\nexports.makeClientConstructor = makeClientConstructor;\n\nfunction partial(fn, path, serialize, deserialize) {\n  // tslint:disable-next-line:no-any\n  return function () {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return fn.call.apply(fn, [this, path, serialize, deserialize].concat(args));\n  };\n}\n/**\n * Load a gRPC package definition as a gRPC object hierarchy.\n * @param packageDef The package definition object.\n * @return The resulting gRPC object.\n */\n\n\nfunction loadPackageDefinition(packageDef) {\n  var result = {};\n\n  for (var serviceFqn in packageDef) {\n    if (packageDef.hasOwnProperty(serviceFqn)) {\n      var service = packageDef[serviceFqn];\n      var nameComponents = serviceFqn.split('.');\n      var serviceName = nameComponents[nameComponents.length - 1];\n      var current = result;\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = nameComponents.slice(0, -1)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var packageName = _step.value;\n\n          if (!current[packageName]) {\n            current[packageName] = {};\n          }\n\n          current = current[packageName];\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return != null) {\n            _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n\n      current[serviceName] = makeClientConstructor(service, serviceName, {});\n    }\n  }\n\n  return result;\n}\n\nexports.loadPackageDefinition = loadPackageDefinition;","map":null,"metadata":{},"sourceType":"script"}