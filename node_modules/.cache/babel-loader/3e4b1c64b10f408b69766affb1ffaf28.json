{"ast":null,"code":"/**\n * @license\n * Copyright 2015 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\n/**\n * Client module\n *\n * This module contains the factory method for creating Client classes, and the\n * method calling code for all types of methods.\n *\n * @example <caption>Create a client and call a method on it</caption>\n *\n * var proto_obj = grpc.load(proto_file_path);\n * var Client = proto_obj.package.subpackage.ServiceName;\n * var client = new Client(server_address, client_credentials);\n * var call = client.unaryMethod(arguments, callback);\n */\n'use strict';\n\nvar _defineProperty = require(\"/Users/cvoisin/Repos/actandcaredev/node_modules/@babel/runtime/helpers/defineProperty\");\n\nvar _requester_funcs, _deprecated_request_w;\n\nvar client_interceptors = require('./client_interceptors');\n\nvar grpc = require('./grpc_extension');\n\nvar common = require('./common');\n\nvar Metadata = require('./metadata');\n\nvar constants = require('./constants');\n\nvar EventEmitter = require('events').EventEmitter;\n\nvar stream = require('stream');\n\nvar Readable = stream.Readable;\nvar Writable = stream.Writable;\nvar Duplex = stream.Duplex;\nvar methodTypes = constants.methodTypes;\n\nvar util = require('util');\n\nvar version = require('../package.json').version;\n/**\n * Initial response metadata sent by the server when it starts processing the\n * call\n * @event grpc~ClientUnaryCall#metadata\n * @type {grpc.Metadata}\n */\n\n/**\n * Status of the call when it has completed.\n * @event grpc~ClientUnaryCall#status\n * @type grpc~StatusObject\n */\n\n\nutil.inherits(ClientUnaryCall, EventEmitter);\n/**\n * An EventEmitter. Used for unary calls.\n * @constructor grpc~ClientUnaryCall\n * @extends external:EventEmitter\n * @param {grpc.internal~Call} call The call object associated with the request\n */\n\nfunction ClientUnaryCall(call) {\n  EventEmitter.call(this);\n  this.call = call;\n}\n\nutil.inherits(ClientWritableStream, Writable);\n/**\n * A stream that the client can write to. Used for calls that are streaming from\n * the client side.\n * @constructor grpc~ClientWritableStream\n * @extends external:Writable\n * @borrows grpc~ClientUnaryCall#cancel as grpc~ClientWritableStream#cancel\n * @borrows grpc~ClientUnaryCall#getPeer as grpc~ClientWritableStream#getPeer\n * @borrows grpc~ClientUnaryCall#event:metadata as\n *     grpc~ClientWritableStream#metadata\n * @borrows grpc~ClientUnaryCall#event:status as\n *     grpc~ClientWritableStream#status\n * @param {InterceptingCall} call Exposes gRPC request operations, processed by\n *     an interceptor stack.\n */\n\nfunction ClientWritableStream(call) {\n  Writable.call(this, {\n    objectMode: true\n  });\n  this.call = call;\n  var self = this;\n  this.on('finish', function () {\n    self.call.halfClose();\n  });\n}\n/**\n * Write a message to the request stream. If serializing the argument fails,\n * the call will be cancelled and the stream will end with an error.\n * @name grpc~ClientWritableStream#write\n * @kind function\n * @override\n * @param {*} message The message to write. Must be a valid argument to the\n *     serialize function of the corresponding method\n * @param {grpc.writeFlags} flags Flags to modify how the message is written\n * @param {Function} callback Callback for when this chunk of data is flushed\n * @return {boolean} As defined for [Writable]{@link external:Writable}\n */\n\n/**\n * Attempt to write the given chunk. Calls the callback when done. This is an\n * implementation of a method needed for implementing stream.Writable.\n * @private\n * @param {*} chunk The chunk to write\n * @param {grpc.writeFlags} encoding Used to pass write flags\n * @param {function(Error=)} callback Called when the write is complete\n */\n\n\nfunction _write(chunk, encoding, callback) {\n  /* jshint validthis: true */\n  var self = this;\n\n  if (this.writeFailed) {\n    /* Once a write fails, just call the callback immediately to let the caller\n       flush any pending writes. */\n    setImmediate(callback);\n    return;\n  }\n\n  var outerCallback = function outerCallback(err, event) {\n    if (err) {\n      /* Assume that the call is complete and that writing failed because a\n         status was received. In that case, set a flag to discard all future\n         writes */\n      self.writeFailed = true;\n    }\n\n    callback();\n  };\n\n  var context = {\n    encoding: encoding,\n    callback: outerCallback\n  };\n  this.call.sendMessageWithContext(context, chunk);\n}\n\nClientWritableStream.prototype._write = _write;\nutil.inherits(ClientReadableStream, Readable);\n/**\n * A stream that the client can read from. Used for calls that are streaming\n * from the server side.\n * @constructor grpc~ClientReadableStream\n * @extends external:Readable\n * @borrows grpc~ClientUnaryCall#cancel as grpc~ClientReadableStream#cancel\n * @borrows grpc~ClientUnaryCall#getPeer as grpc~ClientReadableStream#getPeer\n * @borrows grpc~ClientUnaryCall#event:metadata as\n *     grpc~ClientReadableStream#metadata\n * @borrows grpc~ClientUnaryCall#event:status as\n *     grpc~ClientReadableStream#status\n * @param {InterceptingCall} call Exposes gRPC request operations, processed by\n *     an interceptor stack.\n */\n\nfunction ClientReadableStream(call) {\n  Readable.call(this, {\n    objectMode: true\n  });\n  this.call = call;\n  this.finished = false;\n  this.reading = false;\n  /* Status generated from reading messages from the server. Overrides the\n   * status from the server if not OK */\n\n  this.read_status = null;\n  /* Status received from the server. */\n\n  this.received_status = null;\n}\n/**\n * Called when all messages from the server have been processed. The status\n * parameter indicates that the call should end with that status. status\n * defaults to OK if not provided.\n * @param {Object!} status The status that the call should end with\n * @private\n */\n\n\nfunction _readsDone(status) {\n  /* jshint validthis: true */\n  if (!status) {\n    status = {\n      code: constants.status.OK,\n      details: 'OK'\n    };\n  }\n\n  if (status.code !== constants.status.OK) {\n    this.call.cancelWithStatus(status.code, status.details);\n  }\n\n  this.finished = true;\n  this.read_status = status;\n\n  this._emitStatusIfDone();\n}\n\nClientReadableStream.prototype._readsDone = _readsDone;\n/**\n * Called to indicate that we have received a status from the server.\n * @private\n */\n\nfunction _receiveStatus(status) {\n  /* jshint validthis: true */\n  this.received_status = status;\n\n  this._emitStatusIfDone();\n}\n\nClientReadableStream.prototype._receiveStatus = _receiveStatus;\n/**\n * If we have both processed all incoming messages and received the status from\n * the server, emit the status. Otherwise, do nothing.\n * @private\n */\n\nfunction _emitStatusIfDone() {\n  /* jshint validthis: true */\n  var status;\n\n  if (this.read_status && this.received_status) {\n    if (this.read_status.code !== constants.status.OK) {\n      status = this.read_status;\n    } else {\n      status = this.received_status;\n    }\n\n    if (status.code === constants.status.OK) {\n      this.push(null);\n    } else {\n      var error = common.createStatusError(status);\n      this.emit('error', error);\n    }\n\n    this.emit('status', status);\n  }\n}\n\nClientReadableStream.prototype._emitStatusIfDone = _emitStatusIfDone;\n/**\n * Read the next object from the stream.\n * @private\n * @param {*} size Ignored because we use objectMode=true\n */\n\nfunction _read(size) {\n  /* jshint validthis: true */\n  if (this.finished) {\n    this.push(null);\n  } else {\n    if (!this.reading) {\n      this.reading = true;\n      var context = {\n        stream: this\n      };\n      this.call.recvMessageWithContext(context);\n    }\n  }\n}\n\nClientReadableStream.prototype._read = _read;\nutil.inherits(ClientDuplexStream, Duplex);\n/**\n * A stream that the client can read from or write to. Used for calls with\n * duplex streaming.\n * @constructor grpc~ClientDuplexStream\n * @extends external:Duplex\n * @borrows grpc~ClientUnaryCall#cancel as grpc~ClientDuplexStream#cancel\n * @borrows grpc~ClientUnaryCall#getPeer as grpc~ClientDuplexStream#getPeer\n * @borrows grpc~ClientWritableStream#write as grpc~ClientDuplexStream#write\n * @borrows grpc~ClientUnaryCall#event:metadata as\n *     grpc~ClientDuplexStream#metadata\n * @borrows grpc~ClientUnaryCall#event:status as\n *     grpc~ClientDuplexStream#status\n * @param {InterceptingCall} call Exposes gRPC request operations, processed by\n *     an interceptor stack.\n */\n\nfunction ClientDuplexStream(call) {\n  Duplex.call(this, {\n    objectMode: true\n  });\n  this.call = call;\n  /* Status generated from reading messages from the server. Overrides the\n   * status from the server if not OK */\n\n  this.read_status = null;\n  /* Status received from the server. */\n\n  this.received_status = null;\n  var self = this;\n  this.on('finish', function () {\n    self.call.halfClose();\n  });\n}\n\nClientDuplexStream.prototype._readsDone = _readsDone;\nClientDuplexStream.prototype._receiveStatus = _receiveStatus;\nClientDuplexStream.prototype._emitStatusIfDone = _emitStatusIfDone;\nClientDuplexStream.prototype._read = _read;\nClientDuplexStream.prototype._write = _write;\n/**\n * Cancel the ongoing call. Results in the call ending with a CANCELLED status,\n * unless it has already ended with some other status.\n * @alias grpc~ClientUnaryCall#cancel\n */\n\nfunction cancel() {\n  /* jshint validthis: true */\n  this.call.cancel();\n}\n\nClientUnaryCall.prototype.cancel = cancel;\nClientReadableStream.prototype.cancel = cancel;\nClientWritableStream.prototype.cancel = cancel;\nClientDuplexStream.prototype.cancel = cancel;\n/**\n * Get the endpoint this call/stream is connected to.\n * @return {string} The URI of the endpoint\n * @alias grpc~ClientUnaryCall#getPeer\n */\n\nfunction getPeer() {\n  /* jshint validthis: true */\n  return this.call.getPeer();\n}\n\nClientUnaryCall.prototype.getPeer = getPeer;\nClientReadableStream.prototype.getPeer = getPeer;\nClientWritableStream.prototype.getPeer = getPeer;\nClientDuplexStream.prototype.getPeer = getPeer;\n/**\n * Any client call type\n * @typedef {(grpc~ClientUnaryCall|grpc~ClientReadableStream|\n *            grpc~ClientWritableStream|grpc~ClientDuplexStream)}\n *     grpc.Client~Call\n */\n\n/**\n * Options that can be set on a call.\n * @typedef {Object} grpc.Client~CallOptions\n * @property {grpc~Deadline} deadline The deadline for the entire call to\n *     complete.\n * @property {string} host Server hostname to set on the call. Only meaningful\n *     if different from the server address used to construct the client.\n * @property {grpc.Client~Call} parent Parent call. Used in servers when\n *     making a call as part of the process of handling a call. Used to\n *     propagate some information automatically, as specified by\n *     propagate_flags.\n * @property {number} propagate_flags Indicates which properties of a parent\n *     call should propagate to this call. Bitwise combination of flags in\n *     {@link grpc.propagate}.\n * @property {grpc.credentials~CallCredentials} credentials The credentials that\n *     should be used to make this particular call.\n */\n\n/**\n * A generic gRPC client. Primarily useful as a base class for generated clients\n * @memberof grpc\n * @constructor\n * @param {string} address Server address to connect to\n * @param {grpc.credentials~ChannelCredentials} credentials Credentials to use\n *     to connect to the server\n * @param {Object} options Options to apply to channel creation\n */\n\nfunction Client(address, credentials, options) {\n  var self = this;\n\n  if (!options) {\n    options = {};\n  } // Resolve interceptor options and assign interceptors to each method\n\n\n  if (Array.isArray(options.interceptor_providers) && Array.isArray(options.interceptors)) {\n    throw new client_interceptors.InterceptorConfigurationError('Both interceptors and interceptor_providers were passed as options ' + 'to the client constructor. Only one of these is allowed.');\n  }\n\n  self.$interceptors = options.interceptors || [];\n  self.$interceptor_providers = options.interceptor_providers || [];\n  Object.keys(self.$method_definitions).forEach(function (method_name) {\n    var method_definition = self.$method_definitions[method_name];\n    self[method_name].interceptors = client_interceptors.resolveInterceptorProviders(self.$interceptor_providers, method_definition).concat(self.$interceptors);\n  });\n  this.$callInvocationTransformer = options.callInvocationTransformer;\n  var channelOverride = options.channelOverride;\n  var channelFactoryOverride = options.channelFactoryOverride; // Exclude channel options which have already been consumed\n\n  var ignoredKeys = ['interceptors', 'interceptor_providers', 'channelOverride', 'channelFactoryOverride', 'callInvocationTransformer'];\n  var channel_options = Object.getOwnPropertyNames(options).reduce(function (acc, key) {\n    if (ignoredKeys.indexOf(key) === -1) {\n      acc[key] = options[key];\n    }\n\n    return acc;\n  }, {});\n  /* Private fields use $ as a prefix instead of _ because it is an invalid\n   * prefix of a method name */\n\n  if (channelOverride) {\n    this.$channel = options.channelOverride;\n  } else {\n    if (channelFactoryOverride) {\n      this.$channel = channelFactoryOverride(address, credentials, channel_options);\n    } else {\n      this.$channel = new grpc.Channel(address, credentials, channel_options);\n    }\n  }\n}\n\nexports.Client = Client;\n\nClient.prototype.resolveCallInterceptors = function (method_definition, interceptors, interceptor_providers) {\n  if (Array.isArray(interceptors) && Array.isArray(interceptor_providers)) {\n    throw new client_interceptors.InterceptorConfigurationError('Both interceptors and interceptor_providers were passed as call ' + 'options. Only one of these is allowed.');\n  }\n\n  if (Array.isArray(interceptors) || Array.isArray(interceptor_providers)) {\n    interceptors = interceptors || [];\n    interceptor_providers = interceptor_providers || [];\n    return client_interceptors.resolveInterceptorProviders(interceptor_providers, method_definition).concat(interceptors);\n  } else {\n    return client_interceptors.resolveInterceptorProviders(this.$interceptor_providers, method_definition).concat(this.$interceptors);\n  }\n};\n/**\n * @callback grpc.Client~requestCallback\n * @param {?grpc~ServiceError} error The error, if the call\n *     failed\n * @param {*} value The response value, if the call succeeded\n */\n\n/**\n * Make a unary request to the given method, using the given serialize\n * and deserialize functions, with the given argument.\n * @param {string} path The path of the method to request\n * @param {grpc~serialize} serialize The serialization function for\n *     inputs\n * @param {grpc~deserialize} deserialize The deserialization\n *     function for outputs\n * @param {*} argument The argument to the call. Should be serializable with\n *     serialize\n * @param {grpc.Metadata=} metadata Metadata to add to the call\n * @param {grpc.Client~CallOptions=} options Options map\n * @param {grpc.Client~requestCallback} callback The callback\n *     for when the response is received\n * @return {grpc~ClientUnaryCall} An event emitter for stream related events\n */\n\n\nClient.prototype.makeUnaryRequest = function (path, serialize, deserialize, argument, metadata, options, callback) {\n  if (typeof options === 'function') {\n    callback = options;\n\n    if (metadata instanceof Metadata) {\n      options = {};\n    } else {\n      options = metadata;\n      metadata = new Metadata();\n    }\n  } else if (typeof metadata === 'function') {\n    callback = metadata;\n    metadata = new Metadata();\n    options = {};\n  }\n\n  if (!metadata) {\n    metadata = new Metadata();\n  }\n\n  if (!options) {\n    options = {};\n  }\n\n  if (!(metadata instanceof Metadata && options instanceof Object && typeof callback === 'function')) {\n    throw new Error('Argument mismatch in makeUnaryRequest');\n  }\n\n  var method_definition = options.method_definition = {\n    path: path,\n    requestStream: false,\n    responseStream: false,\n    requestSerialize: serialize,\n    responseDeserialize: deserialize\n  };\n  metadata = metadata.clone();\n  var callProperties = {\n    argument: argument,\n    metadata: metadata,\n    call: new ClientUnaryCall(),\n    channel: this.$channel,\n    methodDefinition: method_definition,\n    callOptions: options,\n    callback: callback\n  }; // Transform call properties if specified.\n\n  if (this.$callInvocationTransformer) {\n    callProperties = this.$callInvocationTransformer(callProperties);\n  }\n\n  var callOptions = callProperties.callOptions;\n  var methodDefinition = callProperties.methodDefinition;\n  var interceptors = Client.prototype.resolveCallInterceptors.call(this, methodDefinition, callOptions.interceptors, callOptions.interceptor_providers);\n  var intercepting_call = client_interceptors.getInterceptingCall(methodDefinition, callOptions, interceptors, callProperties.channel, callProperties.callback);\n  var emitter = callProperties.call;\n  emitter.call = intercepting_call;\n  var last_listener = client_interceptors.getLastListener(methodDefinition, emitter, callProperties.callback);\n  intercepting_call.start(callProperties.metadata, last_listener);\n  intercepting_call.sendMessage(callProperties.argument);\n  intercepting_call.halfClose();\n  return emitter;\n};\n/**\n * Make a client stream request to the given method, using the given serialize\n * and deserialize functions, with the given argument.\n * @param {string} path The path of the method to request\n * @param {grpc~serialize} serialize The serialization function for\n *     inputs\n * @param {grpc~deserialize} deserialize The deserialization\n *     function for outputs\n * @param {grpc.Metadata=} metadata Array of metadata key/value pairs to add to\n *     the call\n * @param {grpc.Client~CallOptions=} options Options map\n * @param {grpc.Client~requestCallback} callback The callback for when the\n *     response is received\n * @return {grpc~ClientWritableStream} An event emitter for stream related\n *     events\n */\n\n\nClient.prototype.makeClientStreamRequest = function (path, serialize, deserialize, metadata, options, callback) {\n  if (typeof options === 'function') {\n    callback = options;\n\n    if (metadata instanceof Metadata) {\n      options = {};\n    } else {\n      options = metadata;\n      metadata = new Metadata();\n    }\n  } else if (typeof metadata === 'function') {\n    callback = metadata;\n    metadata = new Metadata();\n    options = {};\n  }\n\n  if (!metadata) {\n    metadata = new Metadata();\n  }\n\n  if (!options) {\n    options = {};\n  }\n\n  if (!(metadata instanceof Metadata && options instanceof Object && typeof callback === 'function')) {\n    throw new Error('Argument mismatch in makeClientStreamRequest');\n  }\n\n  var method_definition = options.method_definition = {\n    path: path,\n    requestStream: true,\n    responseStream: false,\n    requestSerialize: serialize,\n    responseDeserialize: deserialize\n  };\n  metadata = metadata.clone();\n  var callProperties = {\n    metadata: metadata,\n    call: new ClientWritableStream(),\n    channel: this.$channel,\n    methodDefinition: method_definition,\n    callOptions: options,\n    callback: callback\n  }; // Transform call properties if specified.\n\n  if (this.$callInvocationTransformer) {\n    callProperties = this.$callInvocationTransformer(callProperties);\n  }\n\n  var callOptions = callProperties.callOptions;\n  var methodDefinition = callProperties.methodDefinition;\n  var interceptors = Client.prototype.resolveCallInterceptors.call(this, methodDefinition, callOptions.interceptors, callOptions.interceptor_providers);\n  var intercepting_call = client_interceptors.getInterceptingCall(methodDefinition, callOptions, interceptors, callProperties.channel, callProperties.callback);\n  var emitter = callProperties.call;\n  emitter.call = intercepting_call;\n  var last_listener = client_interceptors.getLastListener(methodDefinition, emitter, callProperties.callback);\n  intercepting_call.start(callProperties.metadata, last_listener);\n  return emitter;\n};\n/**\n * Make a server stream request to the given method, with the given serialize\n * and deserialize function, using the given argument\n * @param {string} path The path of the method to request\n * @param {grpc~serialize} serialize The serialization function for inputs\n * @param {grpc~deserialize} deserialize The deserialization\n *     function for outputs\n * @param {*} argument The argument to the call. Should be serializable with\n *     serialize\n * @param {grpc.Metadata=} metadata Array of metadata key/value pairs to add to\n *     the call\n * @param {grpc.Client~CallOptions=} options Options map\n * @return {grpc~ClientReadableStream} An event emitter for stream related\n *     events\n */\n\n\nClient.prototype.makeServerStreamRequest = function (path, serialize, deserialize, argument, metadata, options) {\n  if (!(metadata instanceof Metadata)) {\n    options = metadata;\n    metadata = new Metadata();\n  }\n\n  if (!(options instanceof Object)) {\n    options = {};\n  }\n\n  if (!(metadata instanceof Metadata && options instanceof Object)) {\n    throw new Error('Argument mismatch in makeServerStreamRequest');\n  }\n\n  var method_definition = options.method_definition = {\n    path: path,\n    requestStream: false,\n    responseStream: true,\n    requestSerialize: serialize,\n    responseDeserialize: deserialize\n  };\n  metadata = metadata.clone();\n  var callProperties = {\n    argument: argument,\n    metadata: metadata,\n    call: new ClientReadableStream(),\n    channel: this.$channel,\n    methodDefinition: method_definition,\n    callOptions: options\n  }; // Transform call properties if specified.\n\n  if (this.$callInvocationTransformer) {\n    callProperties = this.$callInvocationTransformer(callProperties);\n  }\n\n  var callOptions = callProperties.callOptions;\n  var methodDefinition = callProperties.methodDefinition;\n  var interceptors = Client.prototype.resolveCallInterceptors.call(this, methodDefinition, callOptions.interceptors, callOptions.interceptor_providers);\n  var emitter = callProperties.call;\n  var intercepting_call = client_interceptors.getInterceptingCall(methodDefinition, callOptions, interceptors, callProperties.channel, emitter);\n  emitter.call = intercepting_call;\n  var last_listener = client_interceptors.getLastListener(methodDefinition, emitter);\n  intercepting_call.start(callProperties.metadata, last_listener);\n  intercepting_call.sendMessage(callProperties.argument);\n  intercepting_call.halfClose();\n  return emitter;\n};\n/**\n * Make a bidirectional stream request with this method on the given channel.\n * @param {string} path The path of the method to request\n * @param {grpc~serialize} serialize The serialization function for inputs\n * @param {grpc~deserialize} deserialize The deserialization\n *     function for outputs\n * @param {grpc.Metadata=} metadata Array of metadata key/value\n *     pairs to add to the call\n * @param {grpc.Client~CallOptions=} options Options map\n * @return {grpc~ClientDuplexStream} An event emitter for stream related events\n */\n\n\nClient.prototype.makeBidiStreamRequest = function (path, serialize, deserialize, metadata, options) {\n  if (!(metadata instanceof Metadata)) {\n    options = metadata;\n    metadata = new Metadata();\n  }\n\n  if (!(options instanceof Object)) {\n    options = {};\n  }\n\n  if (!(metadata instanceof Metadata && options instanceof Object)) {\n    throw new Error('Argument mismatch in makeBidiStreamRequest');\n  }\n\n  var method_definition = options.method_definition = {\n    path: path,\n    requestStream: true,\n    responseStream: true,\n    requestSerialize: serialize,\n    responseDeserialize: deserialize\n  };\n  metadata = metadata.clone();\n  var callProperties = {\n    metadata: metadata,\n    call: new ClientDuplexStream(),\n    channel: this.$channel,\n    methodDefinition: method_definition,\n    callOptions: options\n  }; // Transform call properties if specified.\n\n  if (this.$callInvocationTransformer) {\n    callProperties = this.$callInvocationTransformer(callProperties);\n  }\n\n  var callOptions = callProperties.callOptions;\n  var methodDefinition = callProperties.methodDefinition;\n  var interceptors = Client.prototype.resolveCallInterceptors.call(this, methodDefinition, callOptions.interceptors, callOptions.interceptor_providers);\n  var emitter = callProperties.call;\n  var intercepting_call = client_interceptors.getInterceptingCall(methodDefinition, callOptions, interceptors, callProperties.channel, emitter);\n  emitter.call = intercepting_call;\n  var last_listener = client_interceptors.getLastListener(methodDefinition, emitter);\n  intercepting_call.start(callProperties.metadata, last_listener);\n  return emitter;\n};\n/**\n * Close this client.\n */\n\n\nClient.prototype.close = function () {\n  this.$channel.close();\n};\n/**\n * Return the underlying channel object for the specified client\n * @return {Channel} The channel\n */\n\n\nClient.prototype.getChannel = function () {\n  return this.$channel;\n};\n/**\n * Wait for the client to be ready. The callback will be called when the\n * client has successfully connected to the server, and it will be called\n * with an error if the attempt to connect to the server has unrecoverablly\n * failed or if the deadline expires. This function will make the channel\n * start connecting if it has not already done so.\n * @param {grpc~Deadline} deadline When to stop waiting for a connection.\n * @param {function(Error)} callback The callback to call when done attempting\n *     to connect.\n */\n\n\nClient.prototype.waitForReady = function (deadline, callback) {\n  var self = this;\n\n  var checkState = function checkState(err) {\n    if (err) {\n      callback(new Error('Failed to connect before the deadline'));\n      return;\n    }\n\n    var new_state;\n\n    try {\n      new_state = self.$channel.getConnectivityState(true);\n    } catch (e) {\n      callback(new Error('The channel has been closed'));\n      return;\n    }\n\n    if (new_state === grpc.connectivityState.READY) {\n      callback();\n    } else if (new_state === grpc.connectivityState.FATAL_FAILURE) {\n      callback(new Error('Failed to connect to server'));\n    } else {\n      try {\n        self.$channel.watchConnectivityState(new_state, deadline, checkState);\n      } catch (e) {\n        callback(new Error('The channel has been closed'));\n      }\n    }\n  };\n  /* Force a single round of polling to ensure that the channel state is up\n   * to date */\n\n\n  grpc.forcePoll();\n  setImmediate(checkState);\n};\n/**\n * Map with short names for each of the requester maker functions. Used in\n * makeClientConstructor\n * @private\n */\n\n\nvar requester_funcs = (_requester_funcs = {}, _defineProperty(_requester_funcs, methodTypes.UNARY, Client.prototype.makeUnaryRequest), _defineProperty(_requester_funcs, methodTypes.CLIENT_STREAMING, Client.prototype.makeClientStreamRequest), _defineProperty(_requester_funcs, methodTypes.SERVER_STREAMING, Client.prototype.makeServerStreamRequest), _defineProperty(_requester_funcs, methodTypes.BIDI_STREAMING, Client.prototype.makeBidiStreamRequest), _requester_funcs);\n\nfunction getDefaultValues(metadata, options) {\n  var res = {};\n  res.metadata = metadata || new Metadata();\n  res.options = options || {};\n  return res;\n}\n/**\n * Map with wrappers for each type of requester function to make it use the old\n * argument order with optional arguments after the callback.\n * @access private\n */\n\n\nvar deprecated_request_wrap = (_deprecated_request_w = {}, _defineProperty(_deprecated_request_w, methodTypes.UNARY, function (makeUnaryRequest) {\n  return function makeWrappedUnaryRequest(argument, callback, metadata, options) {\n    /* jshint validthis: true */\n    var opt_args = getDefaultValues(metadata, options);\n    return makeUnaryRequest.call(this, argument, opt_args.metadata, opt_args.options, callback);\n  };\n}), _defineProperty(_deprecated_request_w, methodTypes.CLIENT_STREAMING, function (makeServerStreamRequest) {\n  return function makeWrappedClientStreamRequest(callback, metadata, options) {\n    /* jshint validthis: true */\n    var opt_args = getDefaultValues(metadata, options);\n    return makeServerStreamRequest.call(this, opt_args.metadata, opt_args.options, callback);\n  };\n}), _defineProperty(_deprecated_request_w, methodTypes.SERVER_STREAMING, function (x) {\n  return x;\n}), _defineProperty(_deprecated_request_w, methodTypes.BIDI_STREAMING, function (x) {\n  return x;\n}), _deprecated_request_w);\n/**\n * Creates a constructor for a client with the given methods, as specified in\n * the methods argument. The resulting class will have an instance method for\n * each method in the service, which is a partial application of one of the\n * [Client]{@link grpc.Client} request methods, depending on `requestSerialize`\n * and `responseSerialize`, with the `method`, `serialize`, and `deserialize`\n * arguments predefined.\n * @memberof grpc\n * @alias grpc~makeGenericClientConstructor\n * @param {grpc~ServiceDefinition} methods An object mapping method names to\n *     method attributes\n * @param {string} serviceName The fully qualified name of the service\n * @param {Object} class_options An options object.\n * @param {boolean=} [class_options.deprecatedArgumentOrder=false] Indicates\n *     that the old argument order should be used for methods, with optional\n *     arguments at the end instead of the callback at the end. This option\n *     is only a temporary stopgap measure to smooth an API breakage.\n *     It is deprecated, and new code should not use it.\n * @return {function} New client constructor, which is a subclass of\n *     {@link grpc.Client}, and has the same arguments as that constructor.\n */\n\nexports.makeClientConstructor = function (methods, serviceName, class_options) {\n  if (!class_options) {\n    class_options = {};\n  }\n\n  function ServiceClient(address, credentials, options) {\n    Client.call(this, address, credentials, options);\n  }\n\n  util.inherits(ServiceClient, Client);\n  ServiceClient.prototype.$method_definitions = methods;\n  ServiceClient.prototype.$method_names = {};\n  Object.keys(methods).forEach(function (name) {\n    var attrs = methods[name];\n\n    if (name.indexOf('$') === 0) {\n      throw new Error('Method names cannot start with $');\n    }\n\n    var method_type = common.getMethodType(attrs);\n\n    var method_func = function method_func() {\n      return requester_funcs[method_type].apply(this, [attrs.path, attrs.requestSerialize, attrs.responseDeserialize].concat([].slice.call(arguments)));\n    };\n\n    if (class_options.deprecatedArgumentOrder) {\n      ServiceClient.prototype[name] = deprecated_request_wrap[method_type](method_func);\n    } else {\n      ServiceClient.prototype[name] = method_func;\n    }\n\n    ServiceClient.prototype.$method_names[attrs.path] = name; // Associate all provided attributes with the method\n\n    Object.assign(ServiceClient.prototype[name], attrs);\n\n    if (attrs.originalName) {\n      ServiceClient.prototype[attrs.originalName] = ServiceClient.prototype[name];\n    }\n  });\n  ServiceClient.service = methods;\n  return ServiceClient;\n};\n/**\n * Return the underlying channel object for the specified client\n * @memberof grpc\n * @alias grpc~getClientChannel\n * @param {grpc.Client} client The client\n * @return {Channel} The channel\n * @see grpc.Client#getChannel\n */\n\n\nexports.getClientChannel = function (client) {\n  return Client.prototype.getChannel.call(client);\n};\n/**\n * Gets a map of client method names to interceptor stacks.\n * @param {grpc.Client} client\n * @returns {Object.<string, Interceptor[]>}\n */\n\n\nexports.getClientInterceptors = function (client) {\n  return Object.keys(client.$method_definitions).reduce(function (acc, key) {\n    if (typeof key === 'string') {\n      acc[key] = client[key].interceptors;\n    }\n\n    return acc;\n  }, {});\n};\n/**\n * Wait for the client to be ready. The callback will be called when the\n * client has successfully connected to the server, and it will be called\n * with an error if the attempt to connect to the server has unrecoverablly\n * failed or if the deadline expires. This function will make the channel\n * start connecting if it has not already done so.\n * @memberof grpc\n * @alias grpc~waitForClientReady\n * @param {grpc.Client} client The client to wait on\n * @param {grpc~Deadline} deadline When to stop waiting for a connection. Pass\n *     Infinity to wait forever.\n * @param {function(Error)} callback The callback to call when done attempting\n *     to connect.\n * @see grpc.Client#waitForReady\n */\n\n\nexports.waitForClientReady = function (client, deadline, callback) {\n  Client.prototype.waitForReady.call(client, deadline, callback);\n};\n\nexports.StatusBuilder = client_interceptors.StatusBuilder;\nexports.ListenerBuilder = client_interceptors.ListenerBuilder;\nexports.RequesterBuilder = client_interceptors.RequesterBuilder;\nexports.InterceptingCall = client_interceptors.InterceptingCall;","map":null,"metadata":{},"sourceType":"script"}