{"ast":null,"code":"'use strict';\n\nexports.__esModule = true;\n\nvar _getIterator2 = require('babel-runtime/core-js/get-iterator');\n\nvar _getIterator3 = _interopRequireDefault(_getIterator2);\n\nvar _Rect = require('../geom/Rect');\n\nvar _Rect2 = _interopRequireDefault(_Rect);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nvar LEFT = 0;\nvar RIGHT = 1;\nvar BELOW = 1;\nvar INSIDE = 2;\nvar ABOVE = 3;\nvar INTERIOR = 1;\nvar EXTERIOR = 2;\nvar BELOW_TO_INSIDE = BELOW << 4 | INSIDE;\nvar BELOW_TO_ABOVE = BELOW << 4 | ABOVE;\nvar INSIDE_TO_BELOW = INSIDE << 4 | BELOW;\nvar INSIDE_TO_ABOVE = INSIDE << 4 | ABOVE;\nvar ABOVE_TO_INSIDE = ABOVE << 4 | INSIDE;\nvar ABOVE_TO_BELOW = ABOVE << 4 | BELOW;\n\nvar xIntersection = function xIntersection(e, t, n) {\n  var r = e - n.y;\n  var i = t.y - n.y;\n  return r / i * (t.x - n.x) + n.x;\n};\n\nvar splitLineRect = function splitLineRect(lineRect, polygon, type) {\n  var minY = lineRect.y;\n  var maxY = lineRect.maxY;\n  var markers = [];\n  var wrapState = BELOW;\n  var min = Infinity;\n  var max = -Infinity;\n\n  for (var i = 0; i < polygon.contours.length; i++) {\n    var contour = polygon.contours[i];\n    var index = -1;\n    var state = -1; // Find the first point outside the line rect.\n\n    do {\n      var point = contour[++index];\n      state = point.y <= minY ? BELOW : point.y >= maxY ? ABOVE : INSIDE;\n    } while (state === INSIDE && index < contour.length - 1); // Contour is entirely inside the line rect. Skip it.\n\n\n    if (state === INSIDE) {\n      continue;\n    }\n\n    var dir = type === EXTERIOR ? 1 : -1;\n    var idx = type === EXTERIOR ? index : contour.length + index;\n    var currentPoint = void 0;\n\n    for (var _index = 0; _index <= contour.length; _index++, idx += dir) {\n      var _point = contour[idx % contour.length];\n\n      if (_index === 0) {\n        currentPoint = _point;\n        state = _point.y <= minY ? BELOW : _point.y >= maxY ? ABOVE : INSIDE;\n        continue;\n      }\n\n      var s = _point.y <= minY ? BELOW : _point.y >= maxY ? ABOVE : INSIDE;\n      var x = _point.x;\n\n      if (s !== state) {\n        var stateChangeType = state << 4 | s;\n\n        switch (stateChangeType) {\n          case BELOW_TO_INSIDE:\n            {\n              // console.log('BELOW_TO_INSIDE')\n              var xIntercept = xIntersection(minY, _point, currentPoint);\n              min = Math.min(xIntercept, x);\n              max = Math.max(xIntercept, x);\n              wrapState = BELOW;\n              break;\n            }\n\n          case BELOW_TO_ABOVE:\n            {\n              // console.log('BELOW_TO_ABOVE')\n              var x1 = xIntersection(minY, _point, currentPoint);\n              var x2 = xIntersection(maxY, _point, currentPoint);\n              markers.push({\n                type: LEFT,\n                position: Math.max(x1, x2)\n              });\n              break;\n            }\n\n          case ABOVE_TO_INSIDE:\n            {\n              // console.log('ABOVE_TO_INSIDE')\n              var _xIntercept = xIntersection(maxY, _point, currentPoint);\n\n              min = Math.min(_xIntercept, x);\n              max = Math.max(_xIntercept, x);\n              wrapState = ABOVE;\n              break;\n            }\n\n          case ABOVE_TO_BELOW:\n            {\n              // console.log('ABOVE_TO_BELOW')\n              var _x = xIntersection(minY, _point, currentPoint);\n\n              var _x2 = xIntersection(maxY, _point, currentPoint);\n\n              markers.push({\n                type: RIGHT,\n                position: Math.min(_x, _x2)\n              });\n              break;\n            }\n\n          case INSIDE_TO_ABOVE:\n            {\n              // console.log('INSIDE_TO_ABOVE')\n              var _x3 = xIntersection(maxY, _point, currentPoint);\n\n              max = Math.max(max, _x3);\n              markers.push({\n                type: LEFT,\n                position: max\n              });\n\n              if (wrapState === ABOVE) {\n                min = Math.min(min, _x3);\n                markers.push({\n                  type: RIGHT,\n                  position: min\n                });\n              }\n\n              break;\n            }\n\n          case INSIDE_TO_BELOW:\n            {\n              // console.log('INSIDE_TO_BELOW')\n              var _x4 = xIntersection(minY, _point, currentPoint);\n\n              min = Math.min(min, _x4);\n              markers.push({\n                type: RIGHT,\n                position: min\n              });\n\n              if (wrapState === BELOW) {\n                max = Math.max(max, _x4);\n                markers.push({\n                  type: LEFT,\n                  position: max\n                });\n              }\n\n              break;\n            }\n\n          default:\n            throw new Error('Unknown state change');\n        }\n\n        state = s;\n      } else if (s === INSIDE) {\n        min = Math.min(min, x);\n        max = Math.max(max, x);\n      }\n\n      currentPoint = _point;\n    }\n  }\n\n  markers.sort(function (a, b) {\n    return a.position - b.position;\n  });\n  var G = 0;\n\n  if (type === '' || markers.length > 0 && markers[0].type === LEFT) {\n    G++;\n  }\n\n  var minX = lineRect.x;\n  var maxX = lineRect.maxX;\n  var height = lineRect.height;\n  var rects = [];\n\n  for (var _iterator = markers, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : (0, _getIterator3.default)(_iterator);;) {\n    var _ref;\n\n    if (_isArray) {\n      if (_i >= _iterator.length) break;\n      _ref = _iterator[_i++];\n    } else {\n      _i = _iterator.next();\n      if (_i.done) break;\n      _ref = _i.value;\n    }\n\n    var marker = _ref;\n\n    if (marker.type === RIGHT) {\n      if (G === 0) {\n        var p = Math.min(maxX, marker.position);\n\n        if (p >= minX) {\n          rects.push(new _Rect2.default(minX, minY, p - minX, height));\n        }\n      }\n\n      G++;\n    } else {\n      G--;\n\n      if (G === 0 && marker.position > minX) {\n        minX = marker.position;\n      }\n    }\n  }\n\n  if (G === 0 && maxX >= minX) {\n    rects.push(new _Rect2.default(minX, minY, maxX - minX, height));\n  }\n\n  return rects;\n};\n/**\r\n * A LineFragmentGenerator splits line rectangles into fragments,\r\n * wrapping inside a container's polygon, and outside its exclusion polygon.\r\n */\n\n\nvar generateLineFragments = function generateLineFragments(lineRect, container) {\n  var exclusion = container.exclusionPolygon;\n  var rects = splitLineRect(lineRect, container.polygon, INTERIOR);\n\n  if (exclusion) {\n    var res = [];\n\n    for (var _iterator2 = rects, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : (0, _getIterator3.default)(_iterator2);;) {\n      var _ref2;\n\n      if (_isArray2) {\n        if (_i2 >= _iterator2.length) break;\n        _ref2 = _iterator2[_i2++];\n      } else {\n        _i2 = _iterator2.next();\n        if (_i2.done) break;\n        _ref2 = _i2.value;\n      }\n\n      var rect = _ref2;\n      res.push.apply(res, splitLineRect(rect, exclusion, EXTERIOR));\n    }\n\n    return res;\n  }\n\n  return rects;\n};\n\nvar generateFragments = function generateFragments(paragraphRect, lineHeight, container) {\n  var lineFragements = [];\n  var yCount = paragraphRect.y;\n\n  while (paragraphRect.height + paragraphRect.y >= yCount + lineHeight) {\n    var lineRect = new _Rect2.default(paragraphRect.x, yCount, paragraphRect.width, lineHeight);\n    lineFragements.push.apply(lineFragements, generateLineFragments(lineRect, container));\n    yCount += lineHeight;\n  }\n\n  return lineFragements;\n};\n\nexports.default = generateFragments;","map":null,"metadata":{},"sourceType":"script"}