{"ast":null,"code":"/*! firebase-admin v6.5.0 */\n\"use strict\";\n/*!\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar credential_1 = require(\"./auth/credential\");\n\nvar validator = require(\"./utils/validator\");\n\nvar deep_copy_1 = require(\"./utils/deep-copy\");\n\nvar error_1 = require(\"./utils/error\");\n/**\n * Internals of a FirebaseApp instance.\n */\n\n\nvar FirebaseAppInternals =\n/** @class */\nfunction () {\n  function FirebaseAppInternals(credential_) {\n    this.credential_ = credential_;\n    this.isDeleted_ = false;\n    this.tokenListeners_ = [];\n  }\n  /**\n   * Gets an auth token for the associated app.\n   *\n   * @param {boolean} forceRefresh Whether or not to force a token refresh.\n   * @return {Promise<FirebaseAccessToken>} A Promise that will be fulfilled with the current or\n   *   new token.\n   */\n\n\n  FirebaseAppInternals.prototype.getToken = function (forceRefresh) {\n    var _this = this;\n\n    var expired = this.cachedToken_ && this.cachedToken_.expirationTime < Date.now();\n\n    if (this.cachedTokenPromise_ && !forceRefresh && !expired) {\n      return this.cachedTokenPromise_.catch(function (error) {\n        // Update the cached token promise to avoid caching errors. Set it to resolve with the\n        // cached token if we have one (and return that promise since the token has still not\n        // expired).\n        if (_this.cachedToken_) {\n          _this.cachedTokenPromise_ = Promise.resolve(_this.cachedToken_);\n          return _this.cachedTokenPromise_;\n        } // Otherwise, set the cached token promise to null so that it will force a refresh next\n        // time getToken() is called.\n\n\n        _this.cachedTokenPromise_ = null; // And re-throw the caught error.\n\n        throw error;\n      });\n    } else {\n      // Clear the outstanding token refresh timeout. This is a noop if the timeout is undefined.\n      clearTimeout(this.tokenRefreshTimeout_); // this.credential_ may be an external class; resolving it in a promise helps us\n      // protect against exceptions and upgrades the result to a promise in all cases.\n\n      this.cachedTokenPromise_ = Promise.resolve(this.credential_.getAccessToken()).then(function (result) {\n        // Since the developer can provide the credential implementation, we want to weakly verify\n        // the return type until the type is properly exported.\n        if (!validator.isNonNullObject(result) || typeof result.expires_in !== 'number' || typeof result.access_token !== 'string') {\n          throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_CREDENTIAL, \"Invalid access token generated: \\\"\" + JSON.stringify(result) + \"\\\". Valid access \" + 'tokens must be an object with the \"expires_in\" (number) and \"access_token\" ' + '(string) properties.');\n        }\n\n        var token = {\n          accessToken: result.access_token,\n          expirationTime: Date.now() + result.expires_in * 1000\n        };\n        var hasAccessTokenChanged = _this.cachedToken_ && _this.cachedToken_.accessToken !== token.accessToken;\n        var hasExpirationChanged = _this.cachedToken_ && _this.cachedToken_.expirationTime !== token.expirationTime;\n\n        if (!_this.cachedToken_ || hasAccessTokenChanged || hasExpirationChanged) {\n          _this.cachedToken_ = token;\n\n          _this.tokenListeners_.forEach(function (listener) {\n            listener(token.accessToken);\n          });\n        } // Establish a timeout to proactively refresh the token every minute starting at five\n        // minutes before it expires. Once a token refresh succeeds, no further retries are\n        // needed; if it fails, retry every minute until the token expires (resulting in a total\n        // of four retries: at 4, 3, 2, and 1 minutes).\n\n\n        var refreshTimeInSeconds = result.expires_in - 5 * 60;\n        var numRetries = 4; // In the rare cases the token is short-lived (that is, it expires in less than five\n        // minutes from when it was fetched), establish the timeout to refresh it after the\n        // current minute ends and update the number of retries that should be attempted before\n        // the token expires.\n\n        if (refreshTimeInSeconds <= 0) {\n          refreshTimeInSeconds = result.expires_in % 60;\n          numRetries = Math.floor(result.expires_in / 60) - 1;\n        } // The token refresh timeout keeps the Node.js process alive, so only create it if this\n        // instance has not already been deleted.\n\n\n        if (numRetries && !_this.isDeleted_) {\n          _this.setTokenRefreshTimeout(refreshTimeInSeconds * 1000, numRetries);\n        }\n\n        return token;\n      }).catch(function (error) {\n        var errorMessage = typeof error === 'string' ? error : error.message;\n        errorMessage = 'Credential implementation provided to initializeApp() via the ' + '\"credential\" property failed to fetch a valid Google OAuth2 access token with the ' + (\"following error: \\\"\" + errorMessage + \"\\\".\");\n\n        if (errorMessage.indexOf('invalid_grant') !== -1) {\n          errorMessage += ' There are two likely causes: (1) your server time is not properly ' + 'synced or (2) your certificate key file has been revoked. To solve (1), re-sync the ' + 'time on your server. To solve (2), make sure the key ID for your key file is still ' + 'present at https://console.firebase.google.com/iam-admin/serviceaccounts/project. If ' + 'not, generate a new key file at ' + 'https://console.firebase.google.com/project/_/settings/serviceaccounts/adminsdk.';\n        }\n\n        throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_CREDENTIAL, errorMessage);\n      });\n      return this.cachedTokenPromise_;\n    }\n  };\n  /**\n   * Adds a listener that is called each time a token changes.\n   *\n   * @param {function(string)} listener The listener that will be called with each new token.\n   */\n\n\n  FirebaseAppInternals.prototype.addAuthTokenListener = function (listener) {\n    this.tokenListeners_.push(listener);\n\n    if (this.cachedToken_) {\n      listener(this.cachedToken_.accessToken);\n    }\n  };\n  /**\n   * Removes a token listener.\n   *\n   * @param {function(string)} listener The listener to remove.\n   */\n\n\n  FirebaseAppInternals.prototype.removeAuthTokenListener = function (listener) {\n    this.tokenListeners_ = this.tokenListeners_.filter(function (other) {\n      return other !== listener;\n    });\n  };\n  /**\n   * Deletes the FirebaseAppInternals instance.\n   */\n\n\n  FirebaseAppInternals.prototype.delete = function () {\n    this.isDeleted_ = true; // Clear the token refresh timeout so it doesn't keep the Node.js process alive.\n\n    clearTimeout(this.tokenRefreshTimeout_);\n  };\n  /**\n   * Establishes timeout to refresh the Google OAuth2 access token used by the SDK.\n   *\n   * @param {number} delayInMilliseconds The delay to use for the timeout.\n   * @param {number} numRetries The number of times to retry fetching a new token if the prior fetch\n   *   failed.\n   */\n\n\n  FirebaseAppInternals.prototype.setTokenRefreshTimeout = function (delayInMilliseconds, numRetries) {\n    var _this = this;\n\n    this.tokenRefreshTimeout_ = setTimeout(function () {\n      _this.getToken(\n      /* forceRefresh */\n      true).catch(function (error) {\n        // Ignore the error since this might just be an intermittent failure. If we really cannot\n        // refresh the token, an error will be logged once the existing token expires and we try\n        // to fetch a fresh one.\n        if (numRetries > 0) {\n          _this.setTokenRefreshTimeout(60 * 1000, numRetries - 1);\n        }\n      });\n    }, delayInMilliseconds);\n  };\n\n  return FirebaseAppInternals;\n}();\n\nexports.FirebaseAppInternals = FirebaseAppInternals;\n/**\n * Global context object for a collection of services using a shared authentication state.\n */\n\nvar FirebaseApp =\n/** @class */\nfunction () {\n  function FirebaseApp(options, name, firebaseInternals_) {\n    var _this = this;\n\n    this.firebaseInternals_ = firebaseInternals_;\n    this.services_ = {};\n    this.isDeleted_ = false;\n    this.name_ = name;\n    this.options_ = deep_copy_1.deepCopy(options);\n\n    if (!validator.isNonNullObject(this.options_)) {\n      throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_APP_OPTIONS, \"Invalid Firebase app options passed as the first argument to initializeApp() for the \" + (\"app named \\\"\" + this.name_ + \"\\\". Options must be a non-null object.\"));\n    }\n\n    var hasCredential = 'credential' in this.options_;\n\n    if (!hasCredential) {\n      this.options_.credential = new credential_1.ApplicationDefaultCredential();\n    }\n\n    var credential = this.options_.credential;\n\n    if (typeof credential !== 'object' || credential === null || typeof credential.getAccessToken !== 'function') {\n      throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_APP_OPTIONS, \"Invalid Firebase app options passed as the first argument to initializeApp() for the \" + (\"app named \\\"\" + this.name_ + \"\\\". The \\\"credential\\\" property must be an object which implements \") + \"the Credential interface.\");\n    }\n\n    Object.keys(firebaseInternals_.serviceFactories).forEach(function (serviceName) {\n      // Defer calling createService() until the service is accessed\n      _this[serviceName] = _this.getService_.bind(_this, serviceName);\n    });\n    this.INTERNAL = new FirebaseAppInternals(this.options_.credential);\n  }\n  /**\n   * Returns the Auth service instance associated with this app.\n   *\n   * @return {Auth} The Auth service instance of this app.\n   */\n\n\n  FirebaseApp.prototype.auth = function () {\n    var _this = this;\n\n    return this.ensureService_('auth', function () {\n      var authService = require('./auth/auth').Auth;\n\n      return new authService(_this);\n    });\n  };\n  /**\n   * Returns the Database service for the specified URL, and the current app.\n   *\n   * @return {Database} The Database service instance of this app.\n   */\n\n\n  FirebaseApp.prototype.database = function (url) {\n    var _this = this;\n\n    var service = this.ensureService_('database', function () {\n      var dbService = require('./database/database').DatabaseService;\n\n      return new dbService(_this);\n    });\n    return service.getDatabase(url);\n  };\n  /**\n   * Returns the Messaging service instance associated with this app.\n   *\n   * @return {Messaging} The Messaging service instance of this app.\n   */\n\n\n  FirebaseApp.prototype.messaging = function () {\n    var _this = this;\n\n    return this.ensureService_('messaging', function () {\n      var messagingService = require('./messaging/messaging').Messaging;\n\n      return new messagingService(_this);\n    });\n  };\n  /**\n   * Returns the Storage service instance associated with this app.\n   *\n   * @return {Storage} The Storage service instance of this app.\n   */\n\n\n  FirebaseApp.prototype.storage = function () {\n    var _this = this;\n\n    return this.ensureService_('storage', function () {\n      var storageService = require('./storage/storage').Storage;\n\n      return new storageService(_this);\n    });\n  };\n\n  FirebaseApp.prototype.firestore = function () {\n    var _this = this;\n\n    var service = this.ensureService_('firestore', function () {\n      var firestoreService = require('./firestore/firestore').FirestoreService;\n\n      return new firestoreService(_this);\n    });\n    return service.client;\n  };\n  /**\n   * Returns the InstanceId service instance associated with this app.\n   *\n   * @return {InstanceId} The InstanceId service instance of this app.\n   */\n\n\n  FirebaseApp.prototype.instanceId = function () {\n    var _this = this;\n\n    return this.ensureService_('iid', function () {\n      var iidService = require('./instance-id/instance-id').InstanceId;\n\n      return new iidService(_this);\n    });\n  };\n  /**\n   * Returns the ProjectManagement service instance associated with this app.\n   *\n   * @return {ProjectManagement} The ProjectManagement service instance of this app.\n   */\n\n\n  FirebaseApp.prototype.projectManagement = function () {\n    var _this = this;\n\n    return this.ensureService_('project-management', function () {\n      var projectManagementService = require('./project-management/project-management').ProjectManagement;\n\n      return new projectManagementService(_this);\n    });\n  };\n\n  Object.defineProperty(FirebaseApp.prototype, \"name\", {\n    /**\n     * Returns the name of the FirebaseApp instance.\n     *\n     * @return {string} The name of the FirebaseApp instance.\n     */\n    get: function get() {\n      this.checkDestroyed_();\n      return this.name_;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(FirebaseApp.prototype, \"options\", {\n    /**\n     * Returns the options for the FirebaseApp instance.\n     *\n     * @return {FirebaseAppOptions} The options for the FirebaseApp instance.\n     */\n    get: function get() {\n      this.checkDestroyed_();\n      return deep_copy_1.deepCopy(this.options_);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\n   * Deletes the FirebaseApp instance.\n   *\n   * @return {Promise<void>} An empty Promise fulfilled once the FirebaseApp instance is deleted.\n   */\n\n  FirebaseApp.prototype.delete = function () {\n    var _this = this;\n\n    this.checkDestroyed_();\n    this.firebaseInternals_.removeApp(this.name_);\n    this.INTERNAL.delete();\n    return Promise.all(Object.keys(this.services_).map(function (serviceName) {\n      return _this.services_[serviceName].INTERNAL.delete();\n    })).then(function () {\n      _this.services_ = {};\n      _this.isDeleted_ = true;\n    });\n  };\n\n  FirebaseApp.prototype.ensureService_ = function (serviceName, initializer) {\n    this.checkDestroyed_();\n    var service;\n\n    if (serviceName in this.services_) {\n      service = this.services_[serviceName];\n    } else {\n      service = initializer();\n      this.services_[serviceName] = service;\n    }\n\n    return service;\n  };\n  /**\n   * Returns the service instance associated with this FirebaseApp instance (creating it on demand\n   * if needed). This is used for looking up monkeypatched service instances.\n   *\n   * @param {string} serviceName The name of the service instance to return.\n   * @return {FirebaseServiceInterface} The service instance with the provided name.\n   */\n\n\n  FirebaseApp.prototype.getService_ = function (serviceName) {\n    this.checkDestroyed_();\n\n    if (!(serviceName in this.services_)) {\n      this.services_[serviceName] = this.firebaseInternals_.serviceFactories[serviceName](this, this.extendApp_.bind(this));\n    }\n\n    return this.services_[serviceName];\n  };\n  /**\n   * Callback function used to extend an App instance at the time of service instance creation.\n   */\n\n\n  FirebaseApp.prototype.extendApp_ = function (props) {\n    deep_copy_1.deepExtend(this, props);\n  };\n  /**\n   * Throws an Error if the FirebaseApp instance has already been deleted.\n   */\n\n\n  FirebaseApp.prototype.checkDestroyed_ = function () {\n    if (this.isDeleted_) {\n      throw new error_1.FirebaseAppError(error_1.AppErrorCodes.APP_DELETED, \"Firebase app named \\\"\" + this.name_ + \"\\\" has already been deleted.\");\n    }\n  };\n\n  return FirebaseApp;\n}();\n\nexports.FirebaseApp = FirebaseApp;","map":null,"metadata":{},"sourceType":"script"}