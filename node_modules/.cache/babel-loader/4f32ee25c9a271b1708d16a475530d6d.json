{"ast":null,"code":"\"use strict\";\n/**\n * Copyright 2013 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nvar __extends = this && this.__extends || function () {\n  var extendStatics = Object.setPrototypeOf || {\n    __proto__: []\n  } instanceof Array && function (d, b) {\n    d.__proto__ = b;\n  } || function (d, b) {\n    for (var p in b) {\n      if (b.hasOwnProperty(p)) d[p] = b[p];\n    }\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : new P(function (resolve) {\n        resolve(result.value);\n      }).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nvar __generator = this && this.__generator || function (thisArg, body) {\n  var _ = {\n    label: 0,\n    sent: function sent() {\n      if (t[0] & 1) throw t[1];\n      return t[1];\n    },\n    trys: [],\n    ops: []\n  },\n      f,\n      y,\n      t,\n      g;\n  return g = {\n    next: verb(0),\n    \"throw\": verb(1),\n    \"return\": verb(2)\n  }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function () {\n    return this;\n  }), g;\n\n  function verb(n) {\n    return function (v) {\n      return step([n, v]);\n    };\n  }\n\n  function step(op) {\n    if (f) throw new TypeError(\"Generator is already executing.\");\n\n    while (_) {\n      try {\n        if (f = 1, y && (t = y[op[0] & 2 ? \"return\" : op[0] ? \"throw\" : \"next\"]) && !(t = t.call(y, op[1])).done) return t;\n        if (y = 0, t) op = [0, t.value];\n\n        switch (op[0]) {\n          case 0:\n          case 1:\n            t = op;\n            break;\n\n          case 4:\n            _.label++;\n            return {\n              value: op[1],\n              done: false\n            };\n\n          case 5:\n            _.label++;\n            y = op[1];\n            op = [0];\n            continue;\n\n          case 7:\n            op = _.ops.pop();\n\n            _.trys.pop();\n\n            continue;\n\n          default:\n            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n              _ = 0;\n              continue;\n            }\n\n            if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n              _.label = op[1];\n              break;\n            }\n\n            if (op[0] === 6 && _.label < t[1]) {\n              _.label = t[1];\n              t = op;\n              break;\n            }\n\n            if (t && _.label < t[2]) {\n              _.label = t[2];\n\n              _.ops.push(op);\n\n              break;\n            }\n\n            if (t[2]) _.ops.pop();\n\n            _.trys.pop();\n\n            continue;\n        }\n\n        op = body.call(thisArg, _);\n      } catch (e) {\n        op = [6, e];\n        y = 0;\n      } finally {\n        f = t = 0;\n      }\n    }\n\n    if (op[0] & 5) throw op[1];\n    return {\n      value: op[0] ? op[1] : void 0,\n      done: true\n    };\n  }\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar gtoken_1 = require(\"gtoken\");\n\nvar jwtaccess_1 = require(\"./jwtaccess\");\n\nvar oauth2client_1 = require(\"./oauth2client\");\n\nvar isString = require('lodash.isstring');\n\nvar JWT =\n/** @class */\nfunction (_super) {\n  __extends(JWT, _super);\n\n  function JWT(optionsOrEmail, keyFile, key, scopes, subject) {\n    var _this = this;\n\n    var opts = optionsOrEmail && typeof optionsOrEmail === 'object' ? optionsOrEmail : {\n      email: optionsOrEmail,\n      keyFile: keyFile,\n      key: key,\n      scopes: scopes,\n      subject: subject\n    };\n    _this = _super.call(this, {\n      eagerRefreshThresholdMillis: opts.eagerRefreshThresholdMillis\n    }) || this;\n    _this.email = opts.email;\n    _this.keyFile = opts.keyFile;\n    _this.key = opts.key;\n    _this.scopes = opts.scopes;\n    _this.subject = opts.subject;\n    _this.additionalClaims = opts.additionalClaims;\n    _this.credentials = {\n      refresh_token: 'jwt-placeholder',\n      expiry_date: 1\n    };\n    return _this;\n  }\n  /**\n   * Creates a copy of the credential with the specified scopes.\n   * @param scopes List of requested scopes or a single scope.\n   * @return The cloned instance.\n   */\n\n\n  JWT.prototype.createScoped = function (scopes) {\n    return new JWT({\n      email: this.email,\n      keyFile: this.keyFile,\n      key: this.key,\n      scopes: scopes,\n      subject: this.subject,\n      additionalClaims: this.additionalClaims\n    });\n  };\n  /**\n   * Obtains the metadata to be sent with the request.\n   *\n   * @param url the URI being authorized.\n   */\n\n\n  JWT.prototype.getRequestMetadataAsync = function (url) {\n    return __awaiter(this, void 0, void 0, function () {\n      var tokens;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            if (!(!this.apiKey && this.createScopedRequired() && url)) return [3\n            /*break*/\n            , 4];\n            if (!(this.additionalClaims && this.additionalClaims.target_audience)) return [3\n            /*break*/\n            , 2];\n            return [4\n            /*yield*/\n            , this.refreshToken()];\n\n          case 1:\n            tokens = _a.sent().tokens;\n            return [2\n            /*return*/\n            , {\n              headers: {\n                Authorization: \"Bearer \" + tokens.id_token\n              }\n            }];\n\n          case 2:\n            // no scopes have been set, but a uri has been provided. Use JWTAccess\n            // credentials.\n            if (!this.access) {\n              this.access = new jwtaccess_1.JWTAccess(this.email, this.key);\n            }\n\n            return [2\n            /*return*/\n            , this.access.getRequestMetadata(url, this.additionalClaims)];\n\n          case 3:\n            return [3\n            /*break*/\n            , 5];\n\n          case 4:\n            return [2\n            /*return*/\n            , _super.prototype.getRequestMetadataAsync.call(this, url)];\n\n          case 5:\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n  /**\n   * Indicates whether the credential requires scopes to be created by calling\n   * createScoped before use.\n   * @return false if createScoped does not need to be called.\n   */\n\n\n  JWT.prototype.createScopedRequired = function () {\n    // If scopes is null, always return true.\n    if (this.scopes) {\n      // For arrays, check the array length.\n      if (this.scopes instanceof Array) {\n        return this.scopes.length === 0;\n      } // For others, convert to a string and check the length.\n\n\n      return String(this.scopes).length === 0;\n    }\n\n    return true;\n  };\n\n  JWT.prototype.authorize = function (callback) {\n    if (callback) {\n      this.authorizeAsync().then(function (r) {\n        return callback(null, r);\n      }).catch(callback);\n    } else {\n      return this.authorizeAsync();\n    }\n  };\n\n  JWT.prototype.authorizeAsync = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var result;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , this.refreshToken()];\n\n          case 1:\n            result = _a.sent();\n\n            if (!result) {\n              throw new Error('No result returned');\n            }\n\n            this.credentials = result.tokens;\n            this.credentials.refresh_token = 'jwt-placeholder';\n            this.key = this.gtoken.key;\n            this.email = this.gtoken.iss;\n            return [2\n            /*return*/\n            , result.tokens];\n        }\n      });\n    });\n  };\n  /**\n   * Refreshes the access token.\n   * @param refreshToken ignored\n   * @private\n   */\n\n\n  JWT.prototype.refreshTokenNoCache = function (refreshToken) {\n    return __awaiter(this, void 0, void 0, function () {\n      var gtoken, token, tokens;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            gtoken = this.createGToken();\n            return [4\n            /*yield*/\n            , gtoken.getToken()];\n\n          case 1:\n            token = _a.sent();\n            tokens = {\n              access_token: token,\n              token_type: 'Bearer',\n              expiry_date: gtoken.expiresAt,\n              // tslint:disable-next-line no-any\n              id_token: gtoken.rawToken.id_token\n            };\n            this.emit('tokens', tokens);\n            return [2\n            /*return*/\n            , {\n              res: null,\n              tokens: tokens\n            }];\n        }\n      });\n    });\n  };\n  /**\n   * Create a gToken if it doesn't already exist.\n   */\n\n\n  JWT.prototype.createGToken = function () {\n    if (!this.gtoken) {\n      this.gtoken = new gtoken_1.GoogleToken({\n        iss: this.email,\n        sub: this.subject,\n        scope: this.scopes,\n        keyFile: this.keyFile,\n        key: this.key,\n        additionalClaims: this.additionalClaims\n      });\n    }\n\n    return this.gtoken;\n  };\n  /**\n   * Create a JWT credentials instance using the given input options.\n   * @param json The input object.\n   */\n\n\n  JWT.prototype.fromJSON = function (json) {\n    if (!json) {\n      throw new Error('Must pass in a JSON object containing the service account auth settings.');\n    }\n\n    if (!json.client_email) {\n      throw new Error('The incoming JSON object does not contain a client_email field');\n    }\n\n    if (!json.private_key) {\n      throw new Error('The incoming JSON object does not contain a private_key field');\n    } // Extract the relevant information from the json key file.\n\n\n    this.email = json.client_email;\n    this.key = json.private_key;\n    this.projectId = json.project_id;\n  };\n\n  JWT.prototype.fromStream = function (inputStream, callback) {\n    if (callback) {\n      this.fromStreamAsync(inputStream).then(function (r) {\n        return callback();\n      }).catch(callback);\n    } else {\n      return this.fromStreamAsync(inputStream);\n    }\n  };\n\n  JWT.prototype.fromStreamAsync = function (inputStream) {\n    var _this = this;\n\n    return new Promise(function (resolve, reject) {\n      if (!inputStream) {\n        throw new Error('Must pass in a stream containing the service account auth settings.');\n      }\n\n      var s = '';\n      inputStream.setEncoding('utf8');\n      inputStream.on('data', function (chunk) {\n        s += chunk;\n      });\n      inputStream.on('end', function () {\n        try {\n          var data = JSON.parse(s);\n\n          _this.fromJSON(data);\n\n          resolve();\n        } catch (e) {\n          reject(e);\n        }\n      });\n    });\n  };\n  /**\n   * Creates a JWT credentials instance using an API Key for authentication.\n   * @param apiKey The API Key in string form.\n   */\n\n\n  JWT.prototype.fromAPIKey = function (apiKey) {\n    if (!isString(apiKey)) {\n      throw new Error('Must provide an API Key string.');\n    }\n\n    this.apiKey = apiKey;\n  };\n  /**\n   * Using the key or keyFile on the JWT client, obtain an object that contains\n   * the key and the client email.\n   */\n\n\n  JWT.prototype.getCredentials = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var gtoken, creds;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            if (!this.key) return [3\n            /*break*/\n            , 1];\n            return [2\n            /*return*/\n            , {\n              private_key: this.key,\n              client_email: this.email\n            }];\n\n          case 1:\n            if (!this.keyFile) return [3\n            /*break*/\n            , 3];\n            gtoken = this.createGToken();\n            return [4\n            /*yield*/\n            , gtoken.getCredentials(this.keyFile)];\n\n          case 2:\n            creds = _a.sent();\n            return [2\n            /*return*/\n            , {\n              private_key: creds.privateKey,\n              client_email: creds.clientEmail\n            }];\n\n          case 3:\n            throw new Error('A key or a keyFile must be provided to getCredentials.');\n        }\n      });\n    });\n  };\n\n  return JWT;\n}(oauth2client_1.OAuth2Client);\n\nexports.JWT = JWT;","map":null,"metadata":{},"sourceType":"script"}