{"ast":null,"code":"/*! firebase-admin v6.5.0 */\n\"use strict\";\n/*!\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n}); // Use untyped import syntax for Node built-ins\n\nvar fs = require(\"fs\");\n\nvar os = require(\"os\");\n\nvar path = require(\"path\");\n\nvar error_1 = require(\"../utils/error\");\n\nvar api_request_1 = require(\"../utils/api-request\");\n\nvar GOOGLE_TOKEN_AUDIENCE = 'https://accounts.google.com/o/oauth2/token';\nvar GOOGLE_AUTH_TOKEN_HOST = 'accounts.google.com';\nvar GOOGLE_AUTH_TOKEN_PATH = '/o/oauth2/token'; // NOTE: the Google Metadata Service uses HTTP over a vlan\n\nvar GOOGLE_METADATA_SERVICE_HOST = 'metadata.google.internal';\nvar GOOGLE_METADATA_SERVICE_PATH = '/computeMetadata/v1beta1/instance/service-accounts/default/token';\n\nvar configDir = function () {\n  // Windows has a dedicated low-rights location for apps at ~/Application Data\n  var sys = os.platform();\n\n  if (sys && sys.length >= 3 && sys.substring(0, 3).toLowerCase() === 'win') {\n    return process.env.APPDATA;\n  } // On *nix the gcloud cli creates a . dir.\n\n\n  return process.env.HOME && path.resolve(process.env.HOME, '.config');\n}();\n\nvar GCLOUD_CREDENTIAL_SUFFIX = 'gcloud/application_default_credentials.json';\nvar GCLOUD_CREDENTIAL_PATH = configDir && path.resolve(configDir, GCLOUD_CREDENTIAL_SUFFIX);\nvar REFRESH_TOKEN_HOST = 'www.googleapis.com';\nvar REFRESH_TOKEN_PATH = '/oauth2/v4/token';\nvar ONE_HOUR_IN_SECONDS = 60 * 60;\nvar JWT_ALGORITHM = 'RS256';\n\nfunction copyAttr(to, from, key, alt) {\n  var tmp = from[key] || from[alt];\n\n  if (typeof tmp !== 'undefined') {\n    to[key] = tmp;\n  }\n}\n\nvar RefreshToken =\n/** @class */\nfunction () {\n  function RefreshToken(json) {\n    copyAttr(this, json, 'clientId', 'client_id');\n    copyAttr(this, json, 'clientSecret', 'client_secret');\n    copyAttr(this, json, 'refreshToken', 'refresh_token');\n    copyAttr(this, json, 'type', 'type');\n    var errorMessage;\n\n    if (typeof this.clientId !== 'string' || !this.clientId) {\n      errorMessage = 'Refresh token must contain a \"client_id\" property.';\n    } else if (typeof this.clientSecret !== 'string' || !this.clientSecret) {\n      errorMessage = 'Refresh token must contain a \"client_secret\" property.';\n    } else if (typeof this.refreshToken !== 'string' || !this.refreshToken) {\n      errorMessage = 'Refresh token must contain a \"refresh_token\" property.';\n    } else if (typeof this.type !== 'string' || !this.type) {\n      errorMessage = 'Refresh token must contain a \"type\" property.';\n    }\n\n    if (typeof errorMessage !== 'undefined') {\n      throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_CREDENTIAL, errorMessage);\n    }\n  }\n  /*\n   * Tries to load a RefreshToken from a path. If the path is not present, returns null.\n   * Throws if data at the path is invalid.\n   */\n\n\n  RefreshToken.fromPath = function (filePath) {\n    var jsonString;\n\n    try {\n      jsonString = fs.readFileSync(filePath, 'utf8');\n    } catch (ignored) {\n      // Ignore errors if the file is not present, as this is sometimes an expected condition\n      return null;\n    }\n\n    try {\n      return new RefreshToken(JSON.parse(jsonString));\n    } catch (error) {\n      // Throw a nicely formed error message if the file contents cannot be parsed\n      throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_CREDENTIAL, 'Failed to parse refresh token file: ' + error);\n    }\n  };\n\n  return RefreshToken;\n}();\n\nexports.RefreshToken = RefreshToken;\n/**\n * A struct containing the properties necessary to use service-account JSON credentials.\n */\n\nvar Certificate =\n/** @class */\nfunction () {\n  function Certificate(json) {\n    if (typeof json !== 'object' || json === null) {\n      throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_CREDENTIAL, 'Certificate object must be an object.');\n    }\n\n    copyAttr(this, json, 'projectId', 'project_id');\n    copyAttr(this, json, 'privateKey', 'private_key');\n    copyAttr(this, json, 'clientEmail', 'client_email');\n    var errorMessage;\n\n    if (typeof this.privateKey !== 'string' || !this.privateKey) {\n      errorMessage = 'Certificate object must contain a string \"private_key\" property.';\n    } else if (typeof this.clientEmail !== 'string' || !this.clientEmail) {\n      errorMessage = 'Certificate object must contain a string \"client_email\" property.';\n    }\n\n    if (typeof errorMessage !== 'undefined') {\n      throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_CREDENTIAL, errorMessage);\n    }\n\n    var forge = require('node-forge');\n\n    try {\n      forge.pki.privateKeyFromPem(this.privateKey);\n    } catch (error) {\n      throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_CREDENTIAL, 'Failed to parse private key: ' + error);\n    }\n  }\n\n  Certificate.fromPath = function (filePath) {\n    // Node bug encountered in v6.x. fs.readFileSync hangs when path is a 0 or 1.\n    if (typeof filePath !== 'string') {\n      throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_CREDENTIAL, 'Failed to parse certificate key file: TypeError: path must be a string');\n    }\n\n    try {\n      return new Certificate(JSON.parse(fs.readFileSync(filePath, 'utf8')));\n    } catch (error) {\n      // Throw a nicely formed error message if the file contents cannot be parsed\n      throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_CREDENTIAL, 'Failed to parse certificate key file: ' + error);\n    }\n  };\n\n  return Certificate;\n}();\n\nexports.Certificate = Certificate;\n/**\n * Obtain a new OAuth2 token by making a remote service call.\n */\n\nfunction requestAccessToken(client, request) {\n  return client.send(request).then(function (resp) {\n    var json = resp.data;\n\n    if (json.error) {\n      var errorMessage = 'Error fetching access token: ' + json.error;\n\n      if (json.error_description) {\n        errorMessage += ' (' + json.error_description + ')';\n      }\n\n      throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_CREDENTIAL, errorMessage);\n    } else if (!json.access_token || !json.expires_in) {\n      throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_CREDENTIAL, \"Unexpected response while fetching access token: \" + JSON.stringify(json));\n    } else {\n      return json;\n    }\n  }).catch(function (err) {\n    throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_CREDENTIAL, \"Failed to parse access token response: \" + err.toString());\n  });\n}\n/**\n * Implementation of Credential that uses a service account certificate.\n */\n\n\nvar CertCredential =\n/** @class */\nfunction () {\n  function CertCredential(serviceAccountPathOrObject, httpAgent) {\n    this.certificate = typeof serviceAccountPathOrObject === 'string' ? Certificate.fromPath(serviceAccountPathOrObject) : new Certificate(serviceAccountPathOrObject);\n    this.httpClient = new api_request_1.HttpClient();\n    this.httpAgent = httpAgent;\n  }\n\n  CertCredential.prototype.getAccessToken = function () {\n    var token = this.createAuthJwt_();\n    var postData = 'grant_type=urn%3Aietf%3Aparams%3Aoauth%3A' + 'grant-type%3Ajwt-bearer&assertion=' + token;\n    var request = {\n      method: 'POST',\n      url: \"https://\" + GOOGLE_AUTH_TOKEN_HOST + GOOGLE_AUTH_TOKEN_PATH,\n      headers: {\n        'Content-Type': 'application/x-www-form-urlencoded'\n      },\n      data: postData,\n      httpAgent: this.httpAgent\n    };\n    return requestAccessToken(this.httpClient, request);\n  };\n\n  CertCredential.prototype.getCertificate = function () {\n    return this.certificate;\n  };\n\n  CertCredential.prototype.createAuthJwt_ = function () {\n    var claims = {\n      scope: ['https://www.googleapis.com/auth/cloud-platform', 'https://www.googleapis.com/auth/firebase.database', 'https://www.googleapis.com/auth/firebase.messaging', 'https://www.googleapis.com/auth/identitytoolkit', 'https://www.googleapis.com/auth/userinfo.email'].join(' ')\n    };\n\n    var jwt = require('jsonwebtoken'); // This method is actually synchronous so we can capture and return the buffer.\n\n\n    return jwt.sign(claims, this.certificate.privateKey, {\n      audience: GOOGLE_TOKEN_AUDIENCE,\n      expiresIn: ONE_HOUR_IN_SECONDS,\n      issuer: this.certificate.clientEmail,\n      algorithm: JWT_ALGORITHM\n    });\n  };\n\n  return CertCredential;\n}();\n\nexports.CertCredential = CertCredential;\n/**\n * Implementation of Credential that gets access tokens from refresh tokens.\n */\n\nvar RefreshTokenCredential =\n/** @class */\nfunction () {\n  function RefreshTokenCredential(refreshTokenPathOrObject, httpAgent) {\n    this.refreshToken = typeof refreshTokenPathOrObject === 'string' ? RefreshToken.fromPath(refreshTokenPathOrObject) : new RefreshToken(refreshTokenPathOrObject);\n    this.httpClient = new api_request_1.HttpClient();\n    this.httpAgent = httpAgent;\n  }\n\n  RefreshTokenCredential.prototype.getAccessToken = function () {\n    var postData = 'client_id=' + this.refreshToken.clientId + '&' + 'client_secret=' + this.refreshToken.clientSecret + '&' + 'refresh_token=' + this.refreshToken.refreshToken + '&' + 'grant_type=refresh_token';\n    var request = {\n      method: 'POST',\n      url: \"https://\" + REFRESH_TOKEN_HOST + REFRESH_TOKEN_PATH,\n      headers: {\n        'Content-Type': 'application/x-www-form-urlencoded'\n      },\n      data: postData,\n      httpAgent: this.httpAgent\n    };\n    return requestAccessToken(this.httpClient, request);\n  };\n\n  RefreshTokenCredential.prototype.getCertificate = function () {\n    return null;\n  };\n\n  return RefreshTokenCredential;\n}();\n\nexports.RefreshTokenCredential = RefreshTokenCredential;\n/**\n * Implementation of Credential that gets access tokens from the metadata service available\n * in the Google Cloud Platform. This authenticates the process as the default service account\n * of an App Engine instance or Google Compute Engine machine.\n */\n\nvar MetadataServiceCredential =\n/** @class */\nfunction () {\n  function MetadataServiceCredential(httpAgent) {\n    this.httpClient = new api_request_1.HttpClient();\n    this.httpAgent = httpAgent;\n  }\n\n  MetadataServiceCredential.prototype.getAccessToken = function () {\n    var request = {\n      method: 'GET',\n      url: \"http://\" + GOOGLE_METADATA_SERVICE_HOST + GOOGLE_METADATA_SERVICE_PATH,\n      httpAgent: this.httpAgent\n    };\n    return requestAccessToken(this.httpClient, request);\n  };\n\n  MetadataServiceCredential.prototype.getCertificate = function () {\n    return null;\n  };\n\n  return MetadataServiceCredential;\n}();\n\nexports.MetadataServiceCredential = MetadataServiceCredential;\n/**\n * ApplicationDefaultCredential implements the process for loading credentials as\n * described in https://developers.google.com/identity/protocols/application-default-credentials\n */\n\nvar ApplicationDefaultCredential =\n/** @class */\nfunction () {\n  function ApplicationDefaultCredential(httpAgent) {\n    if (process.env.GOOGLE_APPLICATION_CREDENTIALS) {\n      var serviceAccount = Certificate.fromPath(process.env.GOOGLE_APPLICATION_CREDENTIALS);\n      this.credential_ = new CertCredential(serviceAccount, httpAgent);\n      return;\n    } // It is OK to not have this file. If it is present, it must be valid.\n\n\n    var refreshToken = RefreshToken.fromPath(GCLOUD_CREDENTIAL_PATH);\n\n    if (refreshToken) {\n      this.credential_ = new RefreshTokenCredential(refreshToken, httpAgent);\n      return;\n    }\n\n    this.credential_ = new MetadataServiceCredential(httpAgent);\n  }\n\n  ApplicationDefaultCredential.prototype.getAccessToken = function () {\n    return this.credential_.getAccessToken();\n  };\n\n  ApplicationDefaultCredential.prototype.getCertificate = function () {\n    return this.credential_.getCertificate();\n  }; // Used in testing to verify we are delegating to the correct implementation.\n\n\n  ApplicationDefaultCredential.prototype.getCredential = function () {\n    return this.credential_;\n  };\n\n  return ApplicationDefaultCredential;\n}();\n\nexports.ApplicationDefaultCredential = ApplicationDefaultCredential;","map":null,"metadata":{},"sourceType":"script"}