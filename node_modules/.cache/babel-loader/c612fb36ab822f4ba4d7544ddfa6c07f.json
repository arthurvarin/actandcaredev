{"ast":null,"code":"\"use strict\";\n/*\n * Copyright 2016, Google Inc.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are\n * met:\n *\n *     * Redistributions of source code must retain the above copyright\n * notice, this list of conditions and the following disclaimer.\n *     * Redistributions in binary form must reproduce the above\n * copyright notice, this list of conditions and the following disclaimer\n * in the documentation and/or other materials provided with the\n * distribution.\n *     * Neither the name of Google Inc. nor the names of its\n * contributors may be used to endorse or promote products derived from\n * this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\nvar _possibleConstructorReturn = require(\"/Users/cvoisin/Repos/actandcaredev/node_modules/@babel/runtime/helpers/possibleConstructorReturn\");\n\nvar _getPrototypeOf = require(\"/Users/cvoisin/Repos/actandcaredev/node_modules/@babel/runtime/helpers/getPrototypeOf\");\n\nvar _inherits = require(\"/Users/cvoisin/Repos/actandcaredev/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _classCallCheck = require(\"/Users/cvoisin/Repos/actandcaredev/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/cvoisin/Repos/actandcaredev/node_modules/@babel/runtime/helpers/createClass\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\n * Provides behavior that supports request bundling.\n */\n\nvar at = require(\"lodash.at\");\n\nvar api_callable_1 = require(\"./api_callable\");\n/**\n * A function which does nothing. Used for an empty cancellation funciton.\n * @private\n */\n\n\nfunction noop() {}\n/**\n * Compute the identifier of the `obj`. The objects of the same ID\n * will be bundled together.\n *\n * @param {Object} obj - The request object.\n * @param {String[]} discriminatorFields - The array of field names.\n *   A field name may include '.' as a separator, which is used to\n *   indicate object traversal.\n * @return {String|undefined} - the identifier string, or undefined if any\n *   discriminator.\n *   fields do not exist.\n */\n\n\nfunction computeBundleId(obj, discriminatorFields) {\n  var ids = [];\n  var hasIds = false;\n\n  for (var i = 0; i < discriminatorFields.length; ++i) {\n    var id = at(obj, discriminatorFields[i])[0];\n\n    if (id === undefined) {\n      ids.push(null);\n    } else {\n      hasIds = true;\n      ids.push(id);\n    }\n  }\n\n  if (!hasIds) {\n    return undefined;\n  }\n\n  return JSON.stringify(ids);\n}\n\nexports.computeBundleId = computeBundleId;\n/**\n * Creates a deep copy of the object with the consideration of subresponse\n * fields for bundling.\n *\n * @param {Object} obj - The source object.\n * @param {Object?} subresponseInfo - The information to copy the subset of\n *   the field for the response. Do nothing if it's null.\n * @param {String} subresponseInfo.field - The field name.\n * @param {number} subresponseInfo.start - The offset where the copying\n *   element should starts with.\n * @param {number} subresponseInfo.end - The ending index where the copying\n *   region of the elements ends.\n * @return {Object} The copied object.\n * @private\n */\n\nfunction deepCopyForResponse( // tslint:disable-next-line no-any\nobj, subresponseInfo) {\n  // tslint:disable-next-line no-any\n  var result;\n\n  if (obj === null) {\n    return null;\n  }\n\n  if (obj === undefined) {\n    return undefined;\n  }\n\n  if (Array.isArray(obj)) {\n    result = [];\n    obj.forEach(function (element) {\n      result.push(deepCopyForResponse(element, null));\n    });\n    return result;\n  } // Some objects (such as ByteBuffer) have copy method.\n\n\n  if (obj.copy !== undefined) {\n    return obj.copy();\n  } // ArrayBuffer should be copied through slice().\n\n\n  if (obj instanceof ArrayBuffer) {\n    return obj.slice(0);\n  }\n\n  if (typeof obj === 'object') {\n    result = {};\n    Object.keys(obj).forEach(function (key) {\n      if (subresponseInfo && key === subresponseInfo.field && Array.isArray(obj[key])) {\n        // Note that subresponses are not deep-copied. This is safe because\n        // those subresponses are not shared among callbacks.\n        result[key] = obj[key].slice(subresponseInfo.start, subresponseInfo.end);\n      } else {\n        result[key] = deepCopyForResponse(obj[key], null);\n      }\n    });\n    return result;\n  }\n\n  return obj;\n}\n\nexports.deepCopyForResponse = deepCopyForResponse;\n\nvar Task =\n/*#__PURE__*/\nfunction () {\n  /**\n   * A task coordinates the execution of a single bundle.\n   *\n   * @param {function} apiCall - The function to conduct calling API.\n   * @param {Object} bundlingRequest - The base request object to be used\n   *   for the actual API call.\n   * @param {string} bundledField - The name of the field in bundlingRequest\n   *   to be bundled.\n   * @param {string=} subresponseField - The name of the field in the response\n   *   to be passed to the callback.\n   * @constructor\n   * @private\n   */\n  function Task(apiCall, bundlingRequest, bundledField, subresponseField) {\n    _classCallCheck(this, Task);\n\n    this._apiCall = apiCall;\n    this._request = bundlingRequest;\n    this._bundledField = bundledField;\n    this._subresponseField = subresponseField;\n    this._data = [];\n  }\n  /**\n   * Returns the number of elements in a task.\n   * @return {number} The number of elements.\n   */\n\n\n  _createClass(Task, [{\n    key: \"getElementCount\",\n    value: function getElementCount() {\n      var count = 0;\n\n      for (var i = 0; i < this._data.length; ++i) {\n        count += this._data[i].elements.length;\n      }\n\n      return count;\n    }\n    /**\n     * Returns the total byte size of the elements in a task.\n     * @return {number} The byte size.\n     */\n\n  }, {\n    key: \"getRequestByteSize\",\n    value: function getRequestByteSize() {\n      var size = 0;\n\n      for (var i = 0; i < this._data.length; ++i) {\n        size += this._data[i].bytes;\n      }\n\n      return size;\n    }\n    /**\n     * Invokes the actual API call with current elements.\n     * @return {string[]} - the list of ids for invocations to be run.\n     */\n\n  }, {\n    key: \"run\",\n    value: function run() {\n      if (this._data.length === 0) {\n        return [];\n      }\n\n      var request = this._request;\n      var elements = [];\n      var ids = [];\n\n      for (var i = 0; i < this._data.length; ++i) {\n        elements.push.apply(elements, this._data[i].elements);\n        ids.push(this._data[i].callback.id);\n      }\n\n      request[this._bundledField] = elements;\n      var self = this;\n      this.callCanceller = this._apiCall(request, function (err, response) {\n        var responses = [];\n\n        if (err) {\n          self._data.forEach(function () {\n            responses.push(null);\n          });\n        } else {\n          var subresponseInfo = null;\n\n          if (self._subresponseField) {\n            subresponseInfo = {\n              field: self._subresponseField,\n              start: 0\n            };\n          }\n\n          self._data.forEach(function (data) {\n            if (subresponseInfo) {\n              subresponseInfo.end = subresponseInfo.start + data.elements.length;\n            }\n\n            responses.push(deepCopyForResponse(response, subresponseInfo));\n\n            if (subresponseInfo) {\n              subresponseInfo.start = subresponseInfo.end;\n            }\n          });\n        }\n\n        for (var _i = 0; _i < self._data.length; ++_i) {\n          if (self._data[_i].cancelled) {\n            self._data[_i].callback(new Error('cancelled'));\n          } else {\n            self._data[_i].callback(err, responses[_i]);\n          }\n        }\n      });\n      return ids;\n    }\n    /**\n     * Appends the list of elements into the task.\n     * @param {Object[]} elements - the new list of elements.\n     * @param {number} bytes - the byte size required to encode elements in the API.\n     * @param {APICallback} callback - the callback of the method call.\n     */\n\n  }, {\n    key: \"extend\",\n    value: function extend(elements, bytes, callback) {\n      this._data.push({\n        elements: elements,\n        bytes: bytes,\n        callback: callback\n      });\n    }\n    /**\n     * Cancels a part of elements.\n     * @param {string} id - The identifier of the part of elements.\n     * @return {boolean} Whether the entire task will be canceled or not.\n     */\n\n  }, {\n    key: \"cancel\",\n    value: function cancel(id) {\n      if (this.callCanceller) {\n        var allCancelled = true;\n\n        this._data.forEach(function (d) {\n          if (d.callback.id === id) {\n            d.cancelled = true;\n          }\n\n          if (!d.cancelled) {\n            allCancelled = false;\n          }\n        });\n\n        if (allCancelled) {\n          this.callCanceller.cancel();\n        }\n\n        return allCancelled;\n      }\n\n      for (var i = 0; i < this._data.length; ++i) {\n        if (this._data[i].callback.id === id) {\n          this._data[i].callback(new Error('cancelled'));\n\n          this._data.splice(i, 1);\n\n          break;\n        }\n      }\n\n      return this._data.length === 0;\n    }\n  }]);\n\n  return Task;\n}();\n\nexports.Task = Task;\n\nvar BundleExecutor =\n/*#__PURE__*/\nfunction () {\n  /**\n   * Organizes requests for an api service that requires to bundle them.\n   *\n   * @param {BundleOptions} bundleOptions - configures strategy this instance\n   *   uses when executing bundled functions.\n   * @param {BundleDescriptor} bundleDescriptor - the description of the bundling.\n   * @constructor\n   */\n  function BundleExecutor(bundleOptions, bundleDescriptor) {\n    _classCallCheck(this, BundleExecutor);\n\n    this._options = bundleOptions;\n    this._descriptor = bundleDescriptor;\n    this._tasks = {};\n    this._timers = {};\n    this._invocations = {};\n    this._invocationId = 0;\n  }\n  /**\n   * Schedule a method call.\n   *\n   * @param {function} apiCall - the function for an API call.\n   * @param {Object} request - the request object to be bundled with others.\n   * @param {APICallback} callback - the callback to be called when the method finished.\n   * @return {function()} - the function to cancel the scheduled invocation.\n   */\n\n\n  _createClass(BundleExecutor, [{\n    key: \"schedule\",\n    value: function schedule(apiCall, request, callback) {\n      var _this = this;\n\n      var bundleId = computeBundleId(request, this._descriptor.requestDiscriminatorFields);\n      callback = callback || noop;\n\n      if (bundleId === undefined) {\n        console.warn('The request does not have enough information for request bundling. ' + 'Invoking immediately. Request: ' + JSON.stringify(request) + ' discriminator fields: ' + this._descriptor.requestDiscriminatorFields);\n        return apiCall(request, callback);\n      }\n\n      if (!(bundleId in this._tasks)) {\n        this._tasks[bundleId] = new Task(apiCall, request, this._descriptor.bundledField, this._descriptor.subresponseField);\n      }\n\n      var task = this._tasks[bundleId];\n      callback.id = String(this._invocationId++);\n      this._invocations[callback.id] = bundleId;\n      var bundledField = request[this._descriptor.bundledField];\n      var elementCount = bundledField.length;\n      var requestBytes = 0;\n      var self = this;\n      bundledField.forEach(function (obj) {\n        requestBytes += _this._descriptor.byteLengthFunction(obj);\n      });\n      var countLimit = this._options.elementCountLimit || 0;\n      var byteLimit = this._options.requestByteLimit || 0;\n\n      if (countLimit > 0 && elementCount >= countLimit || byteLimit > 0 && requestBytes >= byteLimit) {\n        var message;\n\n        if (countLimit > 0 && elementCount >= countLimit) {\n          message = 'The number of elements ' + elementCount + ' exceeds the limit ' + this._options.elementCountLimit;\n        } else {\n          message = 'The required bytes ' + requestBytes + ' exceeds the limit ' + this._options.requestByteLimit;\n        }\n\n        callback(new Error(message));\n        return {\n          cancel: noop\n        };\n      }\n\n      var existingCount = task.getElementCount();\n      var existingBytes = task.getRequestByteSize();\n\n      if (countLimit > 0 && elementCount + existingCount >= countLimit || byteLimit > 0 && requestBytes + existingBytes >= byteLimit) {\n        this._runNow(bundleId);\n\n        this._tasks[bundleId] = new Task(apiCall, request, this._descriptor.bundledField, this._descriptor.subresponseField);\n        task = this._tasks[bundleId];\n      }\n\n      task.extend(bundledField, requestBytes, callback);\n      var ret = {\n        cancel: function cancel() {\n          self._cancel(callback.id);\n        }\n      };\n      var countThreshold = this._options.elementCountThreshold || 0;\n      var sizeThreshold = this._options.requestByteThreshold || 0;\n\n      if (countThreshold > 0 && task.getElementCount() >= countThreshold || sizeThreshold > 0 && task.getRequestByteSize() >= sizeThreshold) {\n        this._runNow(bundleId);\n\n        return ret;\n      }\n\n      if (!(bundleId in this._timers) && this._options.delayThreshold > 0) {\n        this._timers[bundleId] = setTimeout(function () {\n          delete _this._timers[bundleId];\n\n          _this._runNow(bundleId);\n        }, this._options.delayThreshold);\n      }\n\n      return ret;\n    }\n    /**\n     * Clears scheduled timeout if it exists.\n     *\n     * @param {String} bundleId - the id for the task whose timeout needs to be\n     *   cleared.\n     * @private\n     */\n\n  }, {\n    key: \"_maybeClearTimeout\",\n    value: function _maybeClearTimeout(bundleId) {\n      if (bundleId in this._timers) {\n        var timerId = this._timers[bundleId];\n        delete this._timers[bundleId];\n        clearTimeout(timerId);\n      }\n    }\n    /**\n     * Cancels an event.\n     *\n     * @param {String} id - The id for the event in the task.\n     * @private\n     */\n\n  }, {\n    key: \"_cancel\",\n    value: function _cancel(id) {\n      if (!(id in this._invocations)) {\n        return;\n      }\n\n      var bundleId = this._invocations[id];\n\n      if (!(bundleId in this._tasks)) {\n        return;\n      }\n\n      var task = this._tasks[bundleId];\n      delete this._invocations[id];\n\n      if (task.cancel(id)) {\n        this._maybeClearTimeout(bundleId);\n\n        delete this._tasks[bundleId];\n      }\n    }\n    /**\n     * Invokes a task.\n     *\n     * @param {String} bundleId - The id for the task.\n     * @private\n     */\n\n  }, {\n    key: \"_runNow\",\n    value: function _runNow(bundleId) {\n      var _this2 = this;\n\n      if (!(bundleId in this._tasks)) {\n        console.warn('no such bundleid: ' + bundleId);\n        return;\n      }\n\n      this._maybeClearTimeout(bundleId);\n\n      var task = this._tasks[bundleId];\n      delete this._tasks[bundleId];\n      task.run().forEach(function (id) {\n        delete _this2._invocations[id];\n      });\n    }\n  }]);\n\n  return BundleExecutor;\n}();\n\nexports.BundleExecutor = BundleExecutor;\n\nvar Bundleable =\n/*#__PURE__*/\nfunction (_api_callable_1$Norma) {\n  _inherits(Bundleable, _api_callable_1$Norma);\n\n  /**\n   * Creates an API caller that bundles requests.\n   *\n   * @private\n   * @constructor\n   * @param {BundleExecutor} bundler - bundles API calls.\n   */\n  function Bundleable(bundler) {\n    var _this3;\n\n    _classCallCheck(this, Bundleable);\n\n    _this3 = _possibleConstructorReturn(this, _getPrototypeOf(Bundleable).call(this));\n    _this3.bundler = bundler;\n    return _this3;\n  } // tslint:disable-next-line no-any\n\n\n  _createClass(Bundleable, [{\n    key: \"call\",\n    value: function call(apiCall, argument, settings, status) {\n      var _this4 = this;\n\n      if (settings.isBundling) {\n        status.call(function (argument, callback) {\n          _this4.bundler.schedule(apiCall, argument, callback);\n        }, argument);\n      } else {\n        api_callable_1.NormalApiCaller.prototype.call.call(this, apiCall, argument, settings, status);\n      }\n    }\n  }]);\n\n  return Bundleable;\n}(api_callable_1.NormalApiCaller);\n\nexports.Bundleable = Bundleable;\n\nvar BundleDescriptor =\n/*#__PURE__*/\nfunction () {\n  /**\n   * Describes the structure of bundled call.\n   *\n   * requestDiscriminatorFields may include '.' as a separator, which is used to\n   * indicate object traversal. This allows fields in nested objects to be used\n   * to determine what request to bundle.\n   *\n   * @property {String} bundledField\n   * @property {String} requestDiscriminatorFields\n   * @property {String} subresponseField\n   * @property {Function} byteLengthFunction\n   *\n   * @param {String} bundledField - the repeated field in the request message\n   *   that will have its elements aggregated by bundling.\n   * @param {String} requestDiscriminatorFields - a list of fields in the\n   *   target request message class that are used to detemrine which request\n   *   messages should be bundled together.\n   * @param {String} subresponseField - an optional field, when present it\n   *   indicates the field in the response message that should be used to\n   *   demultiplex the response into multiple response messages.\n   * @param {Function} byteLengthFunction - a function to obtain the byte\n   *   length to be consumed for the bundled field messages. Because Node.JS\n   *   protobuf.js/gRPC uses builtin Objects for the user-visible data and\n   *   internally they are encoded/decoded in protobuf manner, this function\n   *   is actually necessary to calculate the byte length.\n   * @constructor\n   */\n  function BundleDescriptor(bundledField, requestDiscriminatorFields, subresponseField, byteLengthFunction) {\n    _classCallCheck(this, BundleDescriptor);\n\n    if (!byteLengthFunction && typeof subresponseField === 'function') {\n      byteLengthFunction = subresponseField;\n      subresponseField = null;\n    }\n\n    this.bundledField = bundledField;\n    this.requestDiscriminatorFields = requestDiscriminatorFields;\n    this.subresponseField = subresponseField;\n    this.byteLengthFunction = byteLengthFunction;\n  }\n  /**\n   * Returns a new API caller.\n   * @private\n   * @param {CallSettings} settings - the current settings.\n   * @return {Bundleable} - the new bundling API caller.\n   */\n\n\n  _createClass(BundleDescriptor, [{\n    key: \"apiCaller\",\n    value: function apiCaller(settings) {\n      return new Bundleable(new BundleExecutor(settings.bundleOptions, this));\n    }\n  }]);\n\n  return BundleDescriptor;\n}();\n\nexports.BundleDescriptor = BundleDescriptor;","map":null,"metadata":{},"sourceType":"script"}